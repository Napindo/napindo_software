"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj2, key2, value) => key2 in obj2 ? __defProp(obj2, key2, { enumerable: true, configurable: true, writable: true, value }) : obj2[key2] = value;
var __publicField = (obj2, key2, value) => __defNormalProp(obj2, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var _a, _b;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const electron = require("electron");
const node_url = require("node:url");
const path$2 = require("node:path");
const require$$0$3 = require("events");
const require$$1$1 = require("tty");
const require$$1$2 = require("util");
const require$$0$2 = require("os");
const require$$4$1 = require("timers");
const require$$0$4 = require("stream");
const crypto$2 = require("crypto");
const require$$0$8 = require("dns");
const require$$3$1 = require("constants");
const http$1 = require("http");
const https$2 = require("https");
const require$$0$5 = require("buffer");
const os$1 = require("node:os");
const util$5 = require("node:util");
const process$1 = require("node:process");
const require$$0$6 = require("net");
const require$$1$3 = require("tls");
const require$$2$1 = require("assert");
const require$$5$2 = require("url");
const http$2 = require("node:http");
const https$3 = require("node:https");
const zlib = require("node:zlib");
const node_stream = require("node:stream");
const fs$3 = require("fs");
const path$1 = require("path");
const child_process = require("child_process");
const require$$0$7 = require("dgram");
const require$$2$2 = require("punycode");
const require$$1$4 = require("string_decoder");
var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const child_process__namespace = /* @__PURE__ */ _interopNamespaceDefault(child_process);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var tedious$1 = { exports: {} };
var base = { exports: {} };
var src$1 = { exports: {} };
var browser = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms$1;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable2;
    createDebug.enable = enable2;
    createDebug.enabled = enabled2;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable2(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable2() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name2) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name2, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name2, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports$1.storage.getItem("debug") || exports$1.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports$1);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$0$2;
  const tty = require$$1$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign4) => sign4 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module2, exports$1) {
    const tty = require$$1$1;
    const util = require$$1$2;
    exports$1.init = init2;
    exports$1.log = log2;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj2, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj2[prop] = val;
      return obj2;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys3 = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys3.length; i++) {
        debug2.inspectOpts[keys3[i]] = exports$1.inspectOpts[keys3[i]];
      }
    }
    module2.exports = requireCommon()(exports$1);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src$1.exports = requireBrowser();
} else {
  src$1.exports = requireNode$1();
}
var srcExports = src$1.exports;
var lib$1 = {};
var connectionString = {};
Object.defineProperty(connectionString, "__esModule", { value: true });
var CollectionMode;
(function(CollectionMode2) {
  CollectionMode2[CollectionMode2["key"] = 0] = "key";
  CollectionMode2[CollectionMode2["value"] = 1] = "value";
})(CollectionMode || (CollectionMode = {}));
const CONFIG = Object.freeze({
  key: {
    terminator: "=",
    quotes: {}
  },
  value: {
    terminator: ";",
    quotes: {
      '"': '"',
      "'": "'",
      "{": "}"
    }
  }
});
function connectionStringParser(connectionString2, parserConfig = CONFIG) {
  const parsed = {};
  let collectionMode = CollectionMode.key;
  let started = false;
  let finished = false;
  let quoted = false;
  let quote = "";
  let buffer2 = "";
  let currentKey = "";
  let pointer = 0;
  function start() {
    started = true;
  }
  function finish() {
    finished = true;
  }
  function reset() {
    started = false;
    finished = false;
    quoted = false;
    quote = "";
    buffer2 = "";
  }
  function config() {
    return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
  }
  function isTerminator(char2) {
    return config().terminator === char2;
  }
  function isStartQuote(char2) {
    return Object.keys(config().quotes).some((val) => char2 === val);
  }
  function isEndQuote(char2) {
    return quoted && char2 === config().quotes[quote];
  }
  function push(char2) {
    buffer2 += char2;
  }
  function collect() {
    if (!quoted) {
      buffer2 = buffer2.trim();
    }
    switch (collectionMode) {
      case CollectionMode.key:
        currentKey = buffer2.toLowerCase();
        collectionMode = CollectionMode.value;
        break;
      case CollectionMode.value:
        collectionMode = CollectionMode.key;
        parsed[currentKey] = buffer2;
        currentKey = "";
        break;
    }
    reset();
  }
  while (pointer < connectionString2.length) {
    const current = connectionString2.charAt(pointer);
    if (!finished) {
      if (!started) {
        if (current.trim()) {
          start();
          if (isStartQuote(current)) {
            quoted = true;
            quote = current;
          } else {
            push(current);
          }
        }
      } else {
        if (quoted && isEndQuote(current)) {
          const next = connectionString2.charAt(pointer + 1);
          if (current === next) {
            push(current);
            pointer++;
          } else {
            finish();
          }
        } else if (!quoted && isTerminator(current)) {
          const next = connectionString2.charAt(pointer + 1);
          if (current === next) {
            push(current);
            pointer++;
          } else {
            collect();
          }
        } else {
          push(current);
        }
      }
    } else if (isTerminator(current)) {
      collect();
    } else if (current.trim()) {
      throw new Error("Malformed connection string");
    }
    pointer++;
  }
  if (quoted && !finished) {
    throw new Error("Connection string terminated unexpectedly");
  } else {
    collect();
  }
  return parsed;
}
connectionString.default = connectionStringParser;
var sqlConnectionString = {};
(function(exports$1) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.SCHEMA = exports$1.SchemaTypes = void 0;
  const connection_string_1 = __importDefault2(connectionString);
  var SchemaTypes;
  (function(SchemaTypes2) {
    SchemaTypes2[SchemaTypes2["BOOL"] = 0] = "BOOL";
    SchemaTypes2[SchemaTypes2["STRING"] = 1] = "STRING";
    SchemaTypes2[SchemaTypes2["NUMBER"] = 2] = "NUMBER";
  })(SchemaTypes = exports$1.SchemaTypes || (exports$1.SchemaTypes = {}));
  exports$1.SCHEMA = {
    "Application Name": {
      type: SchemaTypes.STRING,
      aliases: ["App"],
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    },
    "ApplicationIntent": {
      type: SchemaTypes.STRING,
      allowedValues: ["ReadOnly", "ReadWrite"],
      default: "ReadWrite"
    },
    "Asynchronous Processing": {
      type: SchemaTypes.BOOL,
      default: false,
      aliases: ["Async"]
    },
    "AttachDBFilename": {
      type: SchemaTypes.STRING,
      aliases: ["Extended Properties", "Initial File Name"]
    },
    "Authentication": {
      type: SchemaTypes.STRING,
      allowedValues: ["Active Directory Integrated", "Active Directory Password", "Sql Password"]
    },
    "Column Encryption Setting": {
      type: SchemaTypes.STRING
    },
    "Connection Timeout": {
      type: SchemaTypes.NUMBER,
      aliases: ["Connect Timeout", "Timeout"],
      default: 15
    },
    "Connection Lifetime": {
      type: SchemaTypes.NUMBER,
      aliases: ["Load Balance Timeout"],
      default: 0
    },
    "ConnectRetryCount": {
      type: SchemaTypes.NUMBER,
      default: 1,
      validator(val) {
        return val > 0 && val <= 255;
      }
    },
    "ConnectRetryInterval": {
      type: SchemaTypes.NUMBER,
      default: 10
    },
    "Context Connection": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Current Language": {
      aliases: ["Language"],
      type: SchemaTypes.STRING,
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    },
    "Data Source": {
      aliases: ["Addr", "Address", "Server", "Network Address"],
      type: SchemaTypes.STRING
    },
    "Encrypt": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Enlist": {
      type: SchemaTypes.BOOL,
      default: true
    },
    "Failover Partner": {
      type: SchemaTypes.STRING
    },
    "Initial Catalog": {
      type: SchemaTypes.STRING,
      aliases: ["Database"],
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    },
    "Integrated Security": {
      type: SchemaTypes.BOOL,
      aliases: ["Trusted_Connection"],
      coerce(val) {
        return val === "sspi" || null;
      }
    },
    "Max Pool Size": {
      type: SchemaTypes.NUMBER,
      default: 100,
      validator(val) {
        return val >= 1;
      }
    },
    "Min Pool Size": {
      type: SchemaTypes.NUMBER,
      default: 0,
      validator(val) {
        return val >= 0;
      }
    },
    "MultipleActiveResultSets": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "MultiSubnetFailover": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Network Library": {
      type: SchemaTypes.STRING,
      aliases: ["Network", "Net"],
      allowedValues: ["dbnmpntw", "dbmsrpcn", "dbmsadsn", "dbmsgnet", "dbmslpcn", "dbmsspxn", "dbmssocn", "Dbmsvinn"]
    },
    "Packet Size": {
      type: SchemaTypes.NUMBER,
      default: 8e3,
      validator(val) {
        return val >= 512 && val <= 32768;
      }
    },
    "Password": {
      type: SchemaTypes.STRING,
      aliases: ["PWD"],
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    },
    "Persist Security Info": {
      type: SchemaTypes.BOOL,
      aliases: ["PersistSecurityInfo"],
      default: false
    },
    "PoolBlockingPeriod": {
      type: SchemaTypes.NUMBER,
      default: 0,
      coerce(val) {
        if (typeof val !== "string") {
          return null;
        }
        switch (val.toLowerCase()) {
          case "alwaysblock":
            return 1;
          case "auto":
            return 0;
          case "neverblock":
            return 2;
        }
        return null;
      }
    },
    "Pooling": {
      type: SchemaTypes.BOOL,
      default: true
    },
    "Replication": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Transaction Binding": {
      type: SchemaTypes.STRING,
      allowedValues: ["Implicit Unbind", "Explicit Unbind"],
      default: "Implicit Unbind"
    },
    "TransparentNetworkIPResolution": {
      type: SchemaTypes.BOOL,
      default: true
    },
    "TrustServerCertificate": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Type System Version": {
      type: SchemaTypes.STRING,
      allowedValues: ["SQL Server 2012", "SQL Server 2008", "SQL Server 2005", "Latest"]
    },
    "User ID": {
      type: SchemaTypes.STRING,
      aliases: ["UID"],
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    },
    "User Instance": {
      type: SchemaTypes.BOOL,
      default: false
    },
    "Workstation ID": {
      type: SchemaTypes.STRING,
      aliases: ["WSID"],
      validator(val) {
        return typeof val === "string" && val.length <= 128;
      }
    }
  };
  function guessType(value) {
    if (value.trim() === "") {
      return SchemaTypes.STRING;
    }
    const asNum = parseInt(value, 10);
    if (!Number.isNaN(asNum) && asNum.toString() === value) {
      return SchemaTypes.NUMBER;
    }
    if (["true", "false", "yes", "no"].includes(value.toLowerCase())) {
      return SchemaTypes.BOOL;
    }
    return SchemaTypes.STRING;
  }
  function coerce2(value, type2, coercer) {
    if (coercer) {
      const coerced = coercer(value);
      if (coerced !== null) {
        return coerced;
      }
    }
    switch (type2) {
      case SchemaTypes.BOOL:
        if (["true", "yes", "1"].includes(value.toLowerCase())) {
          return true;
        }
        if (["false", "no", "0"].includes(value.toLowerCase())) {
          return false;
        }
        return value;
      case SchemaTypes.NUMBER:
        return parseInt(value, 10);
    }
    return value;
  }
  function validate2(value, allowedValues, validator) {
    let valid2 = true;
    if (validator) {
      valid2 = validator(value);
    }
    if (valid2) {
      valid2 = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
    }
    return valid2;
  }
  function parseSqlConnectionString2(connectionString2, canonicalProps = false, allowUnknown = false, strict = false, schema = exports$1.SCHEMA) {
    const flattenedSchema = Object.entries(schema).reduce((flattened, [key2, item]) => {
      var _a2;
      Object.assign(flattened, {
        [key2.toLowerCase()]: item
      });
      return ((_a2 = item.aliases) === null || _a2 === void 0 ? void 0 : _a2.reduce((accum, alias) => {
        return Object.assign(accum, {
          [alias.toLowerCase()]: {
            ...item,
            canonical: key2.toLowerCase()
          }
        });
      }, flattened)) || flattened;
    }, {});
    return Object.entries((0, connection_string_1.default)(connectionString2)).reduce((config, [prop, value]) => {
      if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
        return Object.assign(config, {
          [prop]: coerce2(value, guessType(value))
        });
      }
      let coercedValue = coerce2(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
      if (strict && !validate2(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
        coercedValue = flattenedSchema[prop].default;
      }
      const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
      return Object.assign(config, {
        [propName]: coercedValue
      });
    }, {});
  }
  exports$1.default = parseSqlConnectionString2;
})(sqlConnectionString);
var builder = {};
Object.defineProperty(builder, "__esModule", { value: true });
builder.buildConnectionString = void 0;
function isQuoted(val) {
  if (val[0] !== "{") {
    return false;
  }
  for (let i = 1; i < val.length; i++) {
    if (val[i] === "}") {
      if (i + 1 === val.length) {
        return true;
      } else if (val[i + 1] !== "}") {
        return false;
      } else {
        i++;
      }
    }
  }
  return false;
}
function needsQuotes(val) {
  var _a2;
  return !isQuoted(val) && !!((_a2 = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a2 === void 0 ? void 0 : _a2.length);
}
function encodeTuple(key2, value) {
  if (value === null || value === void 0) {
    return [key2, ""];
  }
  switch (typeof value) {
    case "boolean":
      return [key2, value ? "Yes" : "No"];
    default: {
      const strVal = value.toString();
      if (needsQuotes(strVal)) {
        return [key2, `{${strVal.replace(/}/g, "}}")}}`];
      }
      return [key2, strVal];
    }
  }
}
function buildConnectionString(data) {
  return Object.entries(data).map(([key2, value]) => {
    return encodeTuple(key2.trim(), value).join("=");
  }).join(";");
}
builder.buildConnectionString = buildConnectionString;
(function(exports$1) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$12) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding2(exports$12, m, p);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.parseSqlConnectionString = exports$1.parseConnectionString = void 0;
  const connection_string_1 = __importDefault2(connectionString);
  exports$1.parseConnectionString = connection_string_1.default;
  const sql_connection_string_1 = __importDefault2(sqlConnectionString);
  exports$1.parseSqlConnectionString = sql_connection_string_1.default;
  __exportStar(builder, exports$1);
})(lib$1);
var tarn$1 = { exports: {} };
var Pool$1 = {};
var PendingOperation$1 = {};
var TimeoutError$2 = {};
Object.defineProperty(TimeoutError$2, "__esModule", { value: true });
let TimeoutError$1 = class TimeoutError extends Error {
};
TimeoutError$2.TimeoutError = TimeoutError$1;
var utils$1 = {};
var PromiseInspection$1 = {};
Object.defineProperty(PromiseInspection$1, "__esModule", { value: true });
class PromiseInspection {
  constructor(args) {
    this._value = args.value;
    this._error = args.error;
  }
  value() {
    return this._value;
  }
  reason() {
    return this._error;
  }
  isRejected() {
    return !!this._error;
  }
  isFulfilled() {
    return !!this._value;
  }
}
PromiseInspection$1.PromiseInspection = PromiseInspection;
Object.defineProperty(utils$1, "__esModule", { value: true });
const PromiseInspection_1 = PromiseInspection$1;
function defer() {
  let resolve = null;
  let reject = null;
  const promise = new Promise((resolver, rejecter) => {
    resolve = resolver;
    reject = rejecter;
  });
  return {
    promise,
    resolve,
    reject
  };
}
utils$1.defer = defer;
function now() {
  return Date.now();
}
utils$1.now = now;
function duration(t1, t2) {
  return Math.abs(t2 - t1);
}
utils$1.duration = duration;
function checkOptionalTime(time2) {
  if (typeof time2 === "undefined") {
    return true;
  }
  return checkRequiredTime(time2);
}
utils$1.checkOptionalTime = checkOptionalTime;
function checkRequiredTime(time2) {
  return typeof time2 === "number" && time2 === Math.round(time2) && time2 > 0;
}
utils$1.checkRequiredTime = checkRequiredTime;
function delay$2(millis) {
  return new Promise((resolve) => setTimeout(resolve, millis));
}
utils$1.delay = delay$2;
function reflect(promise) {
  return promise.then((value) => {
    return new PromiseInspection_1.PromiseInspection({ value });
  }).catch((error2) => {
    return new PromiseInspection_1.PromiseInspection({ error: error2 });
  });
}
utils$1.reflect = reflect;
function tryPromise(cb) {
  try {
    const result = cb();
    return Promise.resolve(result);
  } catch (err) {
    return Promise.reject(err);
  }
}
utils$1.tryPromise = tryPromise;
Object.defineProperty(PendingOperation$1, "__esModule", { value: true });
const TimeoutError_1 = TimeoutError$2;
const utils_1$2 = utils$1;
class PendingOperation {
  constructor(timeoutMillis) {
    this.timeoutMillis = timeoutMillis;
    this.deferred = utils_1$2.defer();
    this.possibleTimeoutCause = null;
    this.isRejected = false;
    this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
      if (err instanceof TimeoutError_1.TimeoutError) {
        if (this.possibleTimeoutCause) {
          err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
        } else {
          err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
        }
      }
      this.isRejected = true;
      return Promise.reject(err);
    });
  }
  abort() {
    this.reject(new Error("aborted"));
  }
  reject(err) {
    this.deferred.reject(err);
  }
  resolve(value) {
    this.deferred.resolve(value);
  }
}
PendingOperation$1.PendingOperation = PendingOperation;
function timeout(promise, time2) {
  return new Promise((resolve, reject) => {
    const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time2);
    promise.then((result) => {
      clearTimeout(timeoutHandle);
      resolve(result);
    }).catch((err) => {
      clearTimeout(timeoutHandle);
      reject(err);
    });
  });
}
var Resource$1 = {};
Object.defineProperty(Resource$1, "__esModule", { value: true });
const utils_1$1 = utils$1;
class Resource {
  constructor(resource) {
    this.resource = resource;
    this.resource = resource;
    this.timestamp = utils_1$1.now();
    this.deferred = utils_1$1.defer();
  }
  get promise() {
    return this.deferred.promise;
  }
  resolve() {
    this.deferred.resolve(void 0);
    return new Resource(this.resource);
  }
}
Resource$1.Resource = Resource;
Object.defineProperty(Pool$1, "__esModule", { value: true });
const PendingOperation_1 = PendingOperation$1;
const Resource_1 = Resource$1;
const utils_1 = utils$1;
const events_1$1 = require$$0$3;
const timers_1 = require$$4$1;
class Pool {
  constructor(opt) {
    this.destroyed = false;
    this.emitter = new events_1$1.EventEmitter();
    opt = opt || {};
    if (!opt.create) {
      throw new Error("Tarn: opt.create function most be provided");
    }
    if (!opt.destroy) {
      throw new Error("Tarn: opt.destroy function most be provided");
    }
    if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
      throw new Error("Tarn: opt.min must be an integer >= 0");
    }
    if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
      throw new Error("Tarn: opt.max must be an integer > 0");
    }
    if (opt.min > opt.max) {
      throw new Error("Tarn: opt.max is smaller than opt.min");
    }
    if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
      throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
    }
    if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
      throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
    }
    if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
      throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
    }
    if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
      throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
    }
    if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
      throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
    }
    if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
      throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
    }
    const allowedKeys = {
      create: true,
      validate: true,
      destroy: true,
      log: true,
      min: true,
      max: true,
      acquireTimeoutMillis: true,
      createTimeoutMillis: true,
      destroyTimeoutMillis: true,
      idleTimeoutMillis: true,
      reapIntervalMillis: true,
      createRetryIntervalMillis: true,
      propagateCreateError: true
    };
    for (const key2 of Object.keys(opt)) {
      if (!allowedKeys[key2]) {
        throw new Error(`Tarn: unsupported option opt.${key2}`);
      }
    }
    this.creator = opt.create;
    this.destroyer = opt.destroy;
    this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
    this.log = opt.log || (() => {
    });
    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
    this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
    this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
    this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
    this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
    this.propagateCreateError = !!opt.propagateCreateError;
    this.min = opt.min;
    this.max = opt.max;
    this.used = [];
    this.free = [];
    this.pendingCreates = [];
    this.pendingAcquires = [];
    this.pendingDestroys = [];
    this.pendingValidations = [];
    this.destroyed = false;
    this.interval = null;
    this.eventId = 1;
  }
  numUsed() {
    return this.used.length;
  }
  numFree() {
    return this.free.length;
  }
  numPendingAcquires() {
    return this.pendingAcquires.length;
  }
  numPendingValidations() {
    return this.pendingValidations.length;
  }
  numPendingCreates() {
    return this.pendingCreates.length;
  }
  acquire() {
    const eventId = this.eventId++;
    this._executeEventHandlers("acquireRequest", eventId);
    const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
    this.pendingAcquires.push(pendingAcquire);
    pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
      this._executeEventHandlers("acquireSuccess", eventId, resource);
      return resource;
    }).catch((err) => {
      this._executeEventHandlers("acquireFail", eventId, err);
      remove(this.pendingAcquires, pendingAcquire);
      return Promise.reject(err);
    });
    this._tryAcquireOrCreate();
    return pendingAcquire;
  }
  release(resource) {
    this._executeEventHandlers("release", resource);
    for (let i = 0, l = this.used.length; i < l; ++i) {
      const used = this.used[i];
      if (used.resource === resource) {
        this.used.splice(i, 1);
        this.free.push(used.resolve());
        this._tryAcquireOrCreate();
        return true;
      }
    }
    return false;
  }
  isEmpty() {
    return [
      this.numFree(),
      this.numUsed(),
      this.numPendingAcquires(),
      this.numPendingValidations(),
      this.numPendingCreates()
    ].reduce((total, value) => total + value) === 0;
  }
  /**
   * Reaping cycle.
   */
  check() {
    const timestamp = utils_1.now();
    const newFree = [];
    const minKeep = this.min - this.used.length;
    const maxDestroy = this.free.length - minKeep;
    let numDestroyed = 0;
    this.free.forEach((free) => {
      if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
        numDestroyed++;
        this._destroy(free.resource);
      } else {
        newFree.push(free);
      }
    });
    this.free = newFree;
    if (this.isEmpty()) {
      this._stopReaping();
    }
  }
  destroy() {
    const eventId = this.eventId++;
    this._executeEventHandlers("poolDestroyRequest", eventId);
    this._stopReaping();
    this.destroyed = true;
    return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
      return new Promise((resolve, reject) => {
        if (this.numPendingValidations() === 0) {
          resolve();
          return;
        }
        const interval = setInterval(() => {
          if (this.numPendingValidations() === 0) {
            timers_1.clearInterval(interval);
            resolve();
          }
        }, 100);
      });
    }).then(() => {
      return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
    }).then(() => {
      return Promise.all(this.pendingAcquires.map((acquire) => {
        acquire.abort();
        return utils_1.reflect(acquire.promise);
      }));
    }).then(() => {
      return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
    }).then(() => {
      return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
    }).then(() => {
      this.free = [];
      this.pendingAcquires = [];
    })).then((res) => {
      this._executeEventHandlers("poolDestroySuccess", eventId);
      this.emitter.removeAllListeners();
      return res;
    });
  }
  on(event, listener) {
    this.emitter.on(event, listener);
  }
  removeListener(event, listener) {
    this.emitter.removeListener(event, listener);
  }
  removeAllListeners(event) {
    this.emitter.removeAllListeners(event);
  }
  /**
   * The most important method that is called always when resources
   * are created / destroyed / acquired / released. In other words
   * every time when resources are moved from used to free or vice
   * versa.
   *
   * Either assigns free resources to pendingAcquires or creates new
   * resources if there is room for it in the pool.
   */
  _tryAcquireOrCreate() {
    if (this.destroyed) {
      return;
    }
    if (this._hasFreeResources()) {
      this._doAcquire();
    } else if (this._shouldCreateMoreResources()) {
      this._doCreate();
    }
  }
  _hasFreeResources() {
    return this.free.length > 0;
  }
  _doAcquire() {
    while (this._canAcquire()) {
      const pendingAcquire = this.pendingAcquires.shift();
      const free = this.free.pop();
      if (free === void 0 || pendingAcquire === void 0) {
        const errMessage = "this.free was empty while trying to acquire resource";
        this.log(`Tarn: ${errMessage}`, "warn");
        throw new Error(`Internal error, should never happen. ${errMessage}`);
      }
      this.pendingValidations.push(pendingAcquire);
      this.used.push(free);
      const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
      pendingAcquire.promise.catch((err) => {
        abortAbleValidation.abort();
      });
      abortAbleValidation.promise.catch((err) => {
        this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
        return false;
      }).then((validationSuccess) => {
        try {
          if (validationSuccess && !pendingAcquire.isRejected) {
            this._startReaping();
            pendingAcquire.resolve(free.resource);
          } else {
            remove(this.used, free);
            if (!validationSuccess) {
              this._destroy(free.resource);
              setTimeout(() => {
                this._tryAcquireOrCreate();
              }, 0);
            } else {
              this.free.push(free);
            }
            if (!pendingAcquire.isRejected) {
              this.pendingAcquires.unshift(pendingAcquire);
            }
          }
        } finally {
          remove(this.pendingValidations, pendingAcquire);
        }
      });
      this._validateResource(free.resource).then((validationSuccess) => {
        abortAbleValidation.resolve(validationSuccess);
      }).catch((err) => {
        abortAbleValidation.reject(err);
      });
    }
  }
  _canAcquire() {
    return this.free.length > 0 && this.pendingAcquires.length > 0;
  }
  _validateResource(resource) {
    try {
      return Promise.resolve(this.validate(resource));
    } catch (err) {
      return Promise.reject(err);
    }
  }
  _shouldCreateMoreResources() {
    return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
  }
  _doCreate() {
    const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
    const pendingCreate = this._create();
    pendingCreate.promise.then(() => {
      this._tryAcquireOrCreate();
      return null;
    }).catch((err) => {
      if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
        this.pendingAcquires[0].reject(err);
      }
      pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
        pendingAcquire.possibleTimeoutCause = err;
      });
      utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
    });
  }
  _create() {
    const eventId = this.eventId++;
    this._executeEventHandlers("createRequest", eventId);
    const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
    pendingCreate.promise = pendingCreate.promise.catch((err) => {
      if (remove(this.pendingCreates, pendingCreate)) {
        this._executeEventHandlers("createFail", eventId, err);
      }
      throw err;
    });
    this.pendingCreates.push(pendingCreate);
    callbackOrPromise(this.creator).then((resource) => {
      if (pendingCreate.isRejected) {
        this.destroyer(resource);
        return null;
      }
      remove(this.pendingCreates, pendingCreate);
      this.free.push(new Resource_1.Resource(resource));
      pendingCreate.resolve(resource);
      this._executeEventHandlers("createSuccess", eventId, resource);
      return null;
    }).catch((err) => {
      if (pendingCreate.isRejected) {
        return null;
      }
      if (remove(this.pendingCreates, pendingCreate)) {
        this._executeEventHandlers("createFail", eventId, err);
      }
      pendingCreate.reject(err);
      return null;
    });
    return pendingCreate;
  }
  _destroy(resource) {
    const eventId = this.eventId++;
    this._executeEventHandlers("destroyRequest", eventId, resource);
    const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
    const retVal = Promise.resolve().then(() => this.destroyer(resource));
    retVal.then(() => {
      pendingDestroy.resolve(resource);
    }).catch((err) => {
      pendingDestroy.reject(err);
    });
    this.pendingDestroys.push(pendingDestroy);
    return pendingDestroy.promise.then((res) => {
      this._executeEventHandlers("destroySuccess", eventId, resource);
      return res;
    }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
      const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
      this.pendingDestroys.splice(index, 1);
      return res;
    });
  }
  _logDestroyerError(eventId, resource, err) {
    this._executeEventHandlers("destroyFail", eventId, resource, err);
    this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
  }
  _startReaping() {
    if (!this.interval) {
      this._executeEventHandlers("startReaping");
      this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
    }
  }
  _stopReaping() {
    if (this.interval !== null) {
      this._executeEventHandlers("stopReaping");
      timers_1.clearInterval(this.interval);
    }
    this.interval = null;
  }
  _executeEventHandlers(eventName, ...args) {
    const listeners = this.emitter.listeners(eventName);
    listeners.forEach((listener) => {
      try {
        listener(...args);
      } catch (err) {
        this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
      }
    });
  }
}
Pool$1.Pool = Pool;
function remove(arr, item) {
  const idx = arr.indexOf(item);
  if (idx === -1) {
    return false;
  } else {
    arr.splice(idx, 1);
    return true;
  }
}
function callbackOrPromise(func) {
  return new Promise((resolve, reject) => {
    const callback = (err, resource) => {
      if (err) {
        reject(err);
      } else {
        resolve(resource);
      }
    };
    utils_1.tryPromise(() => func(callback)).then((res) => {
      if (res) {
        resolve(res);
      }
    }).catch((err) => {
      reject(err);
    });
  });
}
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  const Pool_1 = Pool$1;
  exports$1.Pool = Pool_1.Pool;
  const TimeoutError_12 = TimeoutError$2;
  exports$1.TimeoutError = TimeoutError_12.TimeoutError;
  module2.exports = {
    Pool: Pool_1.Pool,
    TimeoutError: TimeoutError_12.TimeoutError
  };
})(tarn$1, tarn$1.exports);
var tarnExports = tarn$1.exports;
const IDS$7 = /* @__PURE__ */ new WeakMap();
const INCREMENT = {
  Connection: 1,
  ConnectionPool: 1,
  Request: 1,
  Transaction: 1,
  PreparedStatement: 1
};
var utils = {
  objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
  IDS: {
    get: IDS$7.get.bind(IDS$7),
    add: (object, type2, id) => {
      if (id) return IDS$7.set(object, id);
      IDS$7.set(object, INCREMENT[type2]++);
    }
  }
};
let MSSQLError$6 = class MSSQLError extends Error {
  /**
   * Creates a new ConnectionError.
   *
   * @param {String} message Error message.
   * @param {String} [code] Error code.
   */
  constructor(message2, code) {
    if (message2 instanceof Error) {
      super(message2.message);
      this.code = message2.code || code;
      Error.captureStackTrace(this, this.constructor);
      Object.defineProperty(this, "originalError", { enumerable: true, value: message2 });
    } else {
      super(message2);
      this.code = code;
    }
    this.name = "MSSQLError";
  }
};
var mssqlError = MSSQLError$6;
const MSSQLError$5 = mssqlError;
let ConnectionError$5 = class ConnectionError extends MSSQLError$5 {
  /**
   * Creates a new ConnectionError.
   *
   * @param {String} message Error message.
   * @param {String} [code] Error code.
   */
  constructor(message2, code) {
    super(message2, code);
    this.name = "ConnectionError";
  }
};
var connectionError = ConnectionError$5;
var shared$5 = { exports: {} };
var datatypes = { exports: {} };
(function(module2) {
  const objectHasProperty2 = utils.objectHasProperty;
  const inspect2 = Symbol.for("nodejs.util.inspect.custom");
  const TYPES2 = {
    VarChar(length) {
      return { type: TYPES2.VarChar, length };
    },
    NVarChar(length) {
      return { type: TYPES2.NVarChar, length };
    },
    Text() {
      return { type: TYPES2.Text };
    },
    Int() {
      return { type: TYPES2.Int };
    },
    BigInt() {
      return { type: TYPES2.BigInt };
    },
    TinyInt() {
      return { type: TYPES2.TinyInt };
    },
    SmallInt() {
      return { type: TYPES2.SmallInt };
    },
    Bit() {
      return { type: TYPES2.Bit };
    },
    Float() {
      return { type: TYPES2.Float };
    },
    Numeric(precision, scale) {
      return { type: TYPES2.Numeric, precision, scale };
    },
    Decimal(precision, scale) {
      return { type: TYPES2.Decimal, precision, scale };
    },
    Real() {
      return { type: TYPES2.Real };
    },
    Date() {
      return { type: TYPES2.Date };
    },
    DateTime() {
      return { type: TYPES2.DateTime };
    },
    DateTime2(scale) {
      return { type: TYPES2.DateTime2, scale };
    },
    DateTimeOffset(scale) {
      return { type: TYPES2.DateTimeOffset, scale };
    },
    SmallDateTime() {
      return { type: TYPES2.SmallDateTime };
    },
    Time(scale) {
      return { type: TYPES2.Time, scale };
    },
    UniqueIdentifier() {
      return { type: TYPES2.UniqueIdentifier };
    },
    SmallMoney() {
      return { type: TYPES2.SmallMoney };
    },
    Money() {
      return { type: TYPES2.Money };
    },
    Binary(length) {
      return { type: TYPES2.Binary, length };
    },
    VarBinary(length) {
      return { type: TYPES2.VarBinary, length };
    },
    Image() {
      return { type: TYPES2.Image };
    },
    Xml() {
      return { type: TYPES2.Xml };
    },
    Char(length) {
      return { type: TYPES2.Char, length };
    },
    NChar(length) {
      return { type: TYPES2.NChar, length };
    },
    NText() {
      return { type: TYPES2.NText };
    },
    TVP(tvpType) {
      return { type: TYPES2.TVP, tvpType };
    },
    UDT() {
      return { type: TYPES2.UDT };
    },
    Geography() {
      return { type: TYPES2.Geography };
    },
    Geometry() {
      return { type: TYPES2.Geometry };
    },
    Variant() {
      return { type: TYPES2.Variant };
    }
  };
  module2.exports.TYPES = TYPES2;
  module2.exports.DECLARATIONS = {};
  const zero = function(value, length) {
    if (length == null) length = 2;
    value = String(value);
    if (value.length < length) {
      for (let i = 1; i <= length - value.length; i++) {
        value = `0${value}`;
      }
    }
    return value;
  };
  for (const key2 in TYPES2) {
    if (objectHasProperty2(TYPES2, key2)) {
      const value = TYPES2[key2];
      value.declaration = key2.toLowerCase();
      module2.exports.DECLARATIONS[value.declaration] = value;
      ((key3, value2) => {
        value2[inspect2] = () => `[sql.${key3}]`;
      })(key2, value);
    }
  }
  module2.exports.declare = (type2, options) => {
    switch (type2) {
      case TYPES2.VarChar:
      case TYPES2.VarBinary:
        return `${type2.declaration} (${options.length > 8e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
      case TYPES2.NVarChar:
        return `${type2.declaration} (${options.length > 4e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
      case TYPES2.Char:
      case TYPES2.NChar:
      case TYPES2.Binary:
        return `${type2.declaration} (${options.length == null ? 1 : options.length})`;
      case TYPES2.Decimal:
      case TYPES2.Numeric:
        return `${type2.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`;
      case TYPES2.Time:
      case TYPES2.DateTime2:
      case TYPES2.DateTimeOffset:
        return `${type2.declaration} (${options.scale == null ? 7 : options.scale})`;
      case TYPES2.TVP:
        return `${options.tvpType} readonly`;
      default:
        return type2.declaration;
    }
  };
  module2.exports.cast = (value, type2, options) => {
    if (value == null) {
      return null;
    }
    switch (typeof value) {
      case "string":
        return `N'${value.replace(/'/g, "''")}'`;
      case "number":
        return value;
      case "boolean":
        return value ? 1 : 0;
      case "object":
        if (value instanceof Date) {
          let ns = value.getUTCMilliseconds() / 1e3;
          if (value.nanosecondDelta != null) {
            ns += value.nanosecondDelta;
          }
          const scale = options.scale == null ? 7 : options.scale;
          if (scale > 0) {
            ns = String(ns).substr(1, scale + 1);
          } else {
            ns = "";
          }
          return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`;
        } else if (Buffer.isBuffer(value)) {
          return `0x${value.toString("hex")}`;
        }
        return null;
      default:
        return null;
    }
  };
})(datatypes);
var datatypesExports = datatypes.exports;
const TYPES$4 = datatypesExports.TYPES;
const declareType = datatypesExports.declare;
const objectHasProperty$3 = utils.objectHasProperty;
const MAX = 65535;
const JSON_COLUMN_ID$1 = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
function Table$1(name2) {
  if (name2) {
    const parsed = Table$1.parseName(name2);
    this.name = parsed.name;
    this.schema = parsed.schema;
    this.database = parsed.database;
    this.path = (this.database ? `[${this.database}].` : "") + (this.schema ? `[${this.schema}].` : "") + `[${this.name}]`;
    this.temporary = this.name.charAt(0) === "#";
  }
  this.columns = [];
  this.rows = [];
  Object.defineProperty(this.columns, "add", {
    value(name3, column, options) {
      if (column == null) {
        throw new Error("Column data type is not defined.");
      }
      if (column instanceof Function) {
        column = column();
      }
      options = options || {};
      column.name = name3;
      ["nullable", "primary", "identity", "readOnly", "length"].forEach((prop) => {
        if (objectHasProperty$3(options, prop)) {
          column[prop] = options[prop];
        }
      });
      return this.push(column);
    }
  });
  Object.defineProperty(
    this.rows,
    "add",
    {
      value() {
        return this.push(Array.prototype.slice.call(arguments));
      }
    }
  );
  Object.defineProperty(
    this.rows,
    "clear",
    {
      value() {
        return this.splice(0, this.length);
      }
    }
  );
}
Table$1.prototype._makeBulk = function _makeBulk() {
  for (let i = 0; i < this.columns.length; i++) {
    const col = this.columns[i];
    switch (col.type) {
      case TYPES$4.Date:
      case TYPES$4.DateTime:
      case TYPES$4.DateTime2:
        for (let j = 0; j < this.rows.length; j++) {
          const dateValue = this.rows[j][i];
          if (typeof dateValue === "string" || typeof dateValue === "number") {
            const date2 = new Date(dateValue);
            if (isNaN(date2.getDate())) {
              throw new TypeError("Invalid date value passed to bulk rows");
            }
            this.rows[j][i] = date2;
          }
        }
        break;
      case TYPES$4.Xml:
        col.type = TYPES$4.NVarChar(MAX).type;
        break;
      case TYPES$4.UDT:
      case TYPES$4.Geography:
      case TYPES$4.Geometry:
        col.type = TYPES$4.VarBinary(MAX).type;
        break;
    }
  }
  return this;
};
Table$1.prototype.declare = function declare() {
  const pkey = this.columns.filter((col) => col.primary === true).map((col) => `[${col.name}]`);
  const cols = this.columns.map((col) => {
    const def = [`[${col.name}] ${declareType(col.type, col)}`];
    if (col.nullable === true) {
      def.push("null");
    } else if (col.nullable === false) {
      def.push("not null");
    }
    if (col.primary === true && pkey.length === 1) {
      def.push("primary key");
    }
    return def.join(" ");
  });
  const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(", ")})` : "";
  return `create table ${this.path} (${cols.join(", ")}${constraint})`;
};
Table$1.fromRecordset = function fromRecordset(recordset, name2) {
  const t2 = new this(name2);
  for (const colName in recordset.columns) {
    if (objectHasProperty$3(recordset.columns, colName)) {
      const col = recordset.columns[colName];
      t2.columns.add(colName, {
        type: col.type,
        length: col.length,
        scale: col.scale,
        precision: col.precision
      }, {
        nullable: col.nullable,
        identity: col.identity,
        readOnly: col.readOnly
      });
    }
  }
  if (t2.columns.length === 1 && t2.columns[0].name === JSON_COLUMN_ID$1) {
    for (let i = 0; i < recordset.length; i++) {
      t2.rows.add(JSON.stringify(recordset[i]));
    }
  } else {
    for (let i = 0; i < recordset.length; i++) {
      t2.rows.add.apply(t2.rows, t2.columns.map((col) => recordset[i][col.name]));
    }
  }
  return t2;
};
Table$1.parseName = function parseName(name2) {
  const length = name2.length;
  let cursor = -1;
  let buffer2 = "";
  let escaped = false;
  const path2 = [];
  while (++cursor < length) {
    const char2 = name2.charAt(cursor);
    if (char2 === "[") {
      if (escaped) {
        buffer2 += char2;
      } else {
        escaped = true;
      }
    } else if (char2 === "]") {
      if (escaped) {
        escaped = false;
      } else {
        throw new Error("Invalid table name.");
      }
    } else if (char2 === ".") {
      if (escaped) {
        buffer2 += char2;
      } else {
        path2.push(buffer2);
        buffer2 = "";
      }
    } else {
      buffer2 += char2;
    }
  }
  if (buffer2) {
    path2.push(buffer2);
  }
  switch (path2.length) {
    case 1:
      return {
        name: path2[0],
        schema: null,
        database: null
      };
    case 2:
      return {
        name: path2[1],
        schema: path2[0],
        database: null
      };
    case 3:
      return {
        name: path2[2],
        schema: path2[1],
        database: path2[0]
      };
    default:
      throw new Error("Invalid table name.");
  }
};
var table = Table$1;
(function(module2) {
  const TYPES2 = datatypesExports.TYPES;
  const Table2 = table;
  let PromiseLibrary = Promise;
  const driver = {};
  const map = [];
  map.register = function(jstype, sqltype) {
    for (let index = 0; index < this.length; index++) {
      const item = this[index];
      if (item.js === jstype) {
        this.splice(index, 1);
        break;
      }
    }
    this.push({
      js: jstype,
      sql: sqltype
    });
    return null;
  };
  map.register(String, TYPES2.NVarChar);
  map.register(Number, TYPES2.Int);
  map.register(Boolean, TYPES2.Bit);
  map.register(Date, TYPES2.DateTime);
  map.register(Buffer, TYPES2.VarBinary);
  map.register(Table2, TYPES2.TVP);
  const getTypeByValue = function(value) {
    if (value === null || value === void 0) {
      return TYPES2.NVarChar;
    }
    switch (typeof value) {
      case "string":
        for (const item of Array.from(map)) {
          if (item.js === String) {
            return item.sql;
          }
        }
        return TYPES2.NVarChar;
      case "number":
      case "bigint":
        if (value % 1 === 0) {
          if (value < -2147483648 || value > 2147483647) {
            return TYPES2.BigInt;
          } else {
            return TYPES2.Int;
          }
        } else {
          return TYPES2.Float;
        }
      case "boolean":
        for (const item of Array.from(map)) {
          if (item.js === Boolean) {
            return item.sql;
          }
        }
        return TYPES2.Bit;
      case "object":
        for (const item of Array.from(map)) {
          if (value instanceof item.js) {
            return item.sql;
          }
        }
        return TYPES2.NVarChar;
      default:
        return TYPES2.NVarChar;
    }
  };
  module2.exports = {
    driver,
    getTypeByValue,
    map
  };
  Object.defineProperty(module2.exports, "Promise", {
    get: () => {
      return PromiseLibrary;
    },
    set: (value) => {
      PromiseLibrary = value;
    }
  });
  Object.defineProperty(module2.exports, "valueHandler", {
    enumerable: true,
    value: /* @__PURE__ */ new Map(),
    writable: false,
    configurable: false
  });
})(shared$5);
var sharedExports = shared$5.exports;
var rfdc_1 = rfdc;
function copyBuffer(cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur);
  }
  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
}
function rfdc(opts) {
  opts = opts || {};
  if (opts.circles) return rfdcCircles(opts);
  const constructorHandlers = /* @__PURE__ */ new Map();
  constructorHandlers.set(Date, (o) => new Date(o));
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
  if (opts.constructorHandlers) {
    for (const handler3 of opts.constructorHandlers) {
      constructorHandlers.set(handler3[0], handler3[1]);
    }
  }
  let handler2 = null;
  return opts.proto ? cloneProto : clone2;
  function cloneArray(a, fn) {
    const keys3 = Object.keys(a);
    const a2 = new Array(keys3.length);
    for (let i = 0; i < keys3.length; i++) {
      const k = keys3[i];
      const cur = a[k];
      if (typeof cur !== "object" || cur === null) {
        a2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler2(cur, fn);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        a2[k] = fn(cur);
      }
    }
    return a2;
  }
  function clone2(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, clone2);
    if (o.constructor !== Object && (handler2 = constructorHandlers.get(o.constructor))) {
      return handler2(o, clone2);
    }
    const o2 = {};
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue;
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler2(cur, clone2);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = clone2(cur);
      }
    }
    return o2;
  }
  function cloneProto(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, cloneProto);
    if (o.constructor !== Object && (handler2 = constructorHandlers.get(o.constructor))) {
      return handler2(o, cloneProto);
    }
    const o2 = {};
    for (const k in o) {
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler2(cur, cloneProto);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = cloneProto(cur);
      }
    }
    return o2;
  }
}
function rfdcCircles(opts) {
  const refs = [];
  const refsNew = [];
  const constructorHandlers = /* @__PURE__ */ new Map();
  constructorHandlers.set(Date, (o) => new Date(o));
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
  if (opts.constructorHandlers) {
    for (const handler3 of opts.constructorHandlers) {
      constructorHandlers.set(handler3[0], handler3[1]);
    }
  }
  let handler2 = null;
  return opts.proto ? cloneProto : clone2;
  function cloneArray(a, fn) {
    const keys3 = Object.keys(a);
    const a2 = new Array(keys3.length);
    for (let i = 0; i < keys3.length; i++) {
      const k = keys3[i];
      const cur = a[k];
      if (typeof cur !== "object" || cur === null) {
        a2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler2(cur, fn);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        const index = refs.indexOf(cur);
        if (index !== -1) {
          a2[k] = refsNew[index];
        } else {
          a2[k] = fn(cur);
        }
      }
    }
    return a2;
  }
  function clone2(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, clone2);
    if (o.constructor !== Object && (handler2 = constructorHandlers.get(o.constructor))) {
      return handler2(o, clone2);
    }
    const o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue;
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler2(cur, clone2);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        const i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = clone2(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2;
  }
  function cloneProto(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, cloneProto);
    if (o.constructor !== Object && (handler2 = constructorHandlers.get(o.constructor))) {
      return handler2(o, cloneProto);
    }
    const o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (const k in o) {
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler2 = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler2(cur, cloneProto);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        const i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = cloneProto(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2;
  }
}
var _default = rfdc_1();
const MSSQLError$4 = mssqlError;
let PreparedStatementError$2 = class PreparedStatementError extends MSSQLError$4 {
  /**
   * Creates a new PreparedStatementError.
   *
   * @param {String} message Error message.
   * @param {String} [code] Error code.
   */
  constructor(message2, code) {
    super(message2, code);
    this.name = "PreparedStatementError";
  }
};
var preparedStatementError = PreparedStatementError$2;
const MSSQLError$3 = mssqlError;
let RequestError$4 = class RequestError extends MSSQLError$3 {
  /**
   * Creates a new RequestError.
   *
   * @param {String} message Error message.
   * @param {String} [code] Error code.
   */
  constructor(message2, code) {
    super(message2, code);
    if (message2 instanceof Error) {
      if (message2.info) {
        this.number = message2.info.number || message2.code;
        this.lineNumber = message2.info.lineNumber;
        this.state = message2.info.state || message2.sqlstate;
        this.class = message2.info.class;
        this.serverName = message2.info.serverName;
        this.procName = message2.info.procName;
      } else {
        this.number = message2.code;
        this.lineNumber = message2.lineNumber;
        this.state = message2.sqlstate;
        this.class = message2.severity;
        this.serverName = message2.serverName;
        this.procName = message2.procName;
      }
    }
    this.name = "RequestError";
    const parsedMessage = /^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/.exec(this.message);
    if (parsedMessage) {
      this.message = parsedMessage[1];
    }
  }
};
var requestError = RequestError$4;
const MSSQLError$2 = mssqlError;
let TransactionError$4 = class TransactionError extends MSSQLError$2 {
  /**
   * Creates a new TransactionError.
   *
   * @param {String} message Error message.
   * @param {String} [code] Error code.
   */
  constructor(message2, code) {
    super(message2, code);
    this.name = "TransactionError";
  }
};
var transactionError = TransactionError$4;
const ConnectionError$4 = connectionError;
const MSSQLError$1 = mssqlError;
const PreparedStatementError$1 = preparedStatementError;
const RequestError$3 = requestError;
const TransactionError$3 = transactionError;
var error = {
  ConnectionError: ConnectionError$4,
  MSSQLError: MSSQLError$1,
  PreparedStatementError: PreparedStatementError$1,
  RequestError: RequestError$3,
  TransactionError: TransactionError$3
};
const { EventEmitter: EventEmitter$4 } = require$$0$3;
const debug$c = srcExports("mssql:base");
const { parseSqlConnectionString } = lib$1;
const tarn = tarnExports;
const { IDS: IDS$6 } = utils;
const ConnectionError$3 = connectionError;
const shared$4 = sharedExports;
const clone = _default;
const { MSSQLError: MSSQLError2 } = error;
let ConnectionPool$1 = class ConnectionPool extends EventEmitter$4 {
  /**
   * Create new Connection.
   *
   * @param {Object|String} config Connection configuration object or connection string.
   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
   */
  constructor(config, callback) {
    super();
    IDS$6.add(this, "ConnectionPool");
    debug$c("pool(%d): created", IDS$6.get(this));
    this._connectStack = [];
    this._closeStack = [];
    this._connected = false;
    this._connecting = false;
    this._healthy = false;
    if (typeof config === "string") {
      try {
        this.config = this.constructor.parseConnectionString(config);
      } catch (ex) {
        if (typeof callback === "function") {
          return setImmediate(callback, ex);
        }
        throw ex;
      }
    } else {
      this.config = clone(config);
    }
    this.config.port = this.config.port || 1433;
    this.config.options = this.config.options || {};
    this.config.stream = this.config.stream || false;
    this.config.parseJSON = this.config.parseJSON || false;
    this.config.arrayRowMode = this.config.arrayRowMode || false;
    this.config.validateConnection = "validateConnection" in this.config ? this.config.validateConnection : true;
    const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
    if (namedServer) {
      this.config.server = namedServer[1];
      this.config.options.instanceName = namedServer[2];
    }
    if (typeof this.config.options.useColumnNames !== "undefined" && this.config.options.useColumnNames !== true) {
      const ex = new MSSQLError2("Invalid options `useColumnNames`, use `arrayRowMode` instead");
      if (typeof callback === "function") {
        return setImmediate(callback, ex);
      }
      throw ex;
    }
    if (typeof callback === "function") {
      this.connect(callback);
    }
  }
  get connected() {
    return this._connected;
  }
  get connecting() {
    return this._connecting;
  }
  get healthy() {
    return this._healthy;
  }
  static parseConnectionString(connectionString2) {
    return this._parseConnectionString(connectionString2);
  }
  static _parseAuthenticationType(type2, entries) {
    switch (type2.toLowerCase()) {
      case "active directory integrated":
        if (entries.includes("token")) {
          return "azure-active-directory-access-token";
        } else if (["client id", "client secret", "tenant id"].every((entry) => entries.includes(entry))) {
          return "azure-active-directory-service-principal-secret";
        } else if (["client id", "msi endpoint", "msi secret"].every((entry) => entries.includes(entry))) {
          return "azure-active-directory-msi-app-service";
        } else if (["client id", "msi endpoint"].every((entry) => entries.includes(entry))) {
          return "azure-active-directory-msi-vm";
        }
        return "azure-active-directory-default";
      case "active directory password":
        return "azure-active-directory-password";
      case "ntlm":
        return "ntlm";
      default:
        return "default";
    }
  }
  static _parseConnectionString(connectionString2) {
    const parsed = parseSqlConnectionString(connectionString2, true, true);
    return Object.entries(parsed).reduce((config, [key2, value]) => {
      switch (key2) {
        case "application name":
          break;
        case "applicationintent":
          Object.assign(config.options, {
            readOnlyIntent: value === "readonly"
          });
          break;
        case "asynchronous processing":
          break;
        case "attachdbfilename":
          break;
        case "authentication":
          Object.assign(config, {
            authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
          });
          break;
        case "column encryption setting":
          break;
        case "connection timeout":
          Object.assign(config, {
            connectionTimeout: value * 1e3
          });
          break;
        case "connection lifetime":
          break;
        case "connectretrycount":
          break;
        case "connectretryinterval":
          Object.assign(config.options, {
            connectionRetryInterval: value * 1e3
          });
          break;
        case "context connection":
          break;
        case "client id":
          Object.assign(config, {
            clientId: value
          });
          break;
        case "client secret":
          Object.assign(config, {
            clientSecret: value
          });
          break;
        case "current language":
          Object.assign(config.options, {
            language: value
          });
          break;
        case "data source": {
          let server = value;
          let instanceName;
          let port = 1433;
          if (/^np:/i.test(server)) {
            throw new Error("Connection via Named Pipes is not supported.");
          }
          if (/^tcp:/i.test(server)) {
            server = server.substr(4);
          }
          const namedServerParts = /^(.*)\\(.*)$/.exec(server);
          if (namedServerParts) {
            server = namedServerParts[1].trim();
            instanceName = namedServerParts[2].trim();
          }
          const serverParts = /^(.*),(.*)$/.exec(server);
          if (serverParts) {
            server = serverParts[1].trim();
            port = parseInt(serverParts[2].trim(), 10);
          } else {
            const instanceParts = /^(.*),(.*)$/.exec(instanceName);
            if (instanceParts) {
              instanceName = instanceParts[1].trim();
              port = parseInt(instanceParts[2].trim(), 10);
            }
          }
          if (server === "." || server === "(.)" || server.toLowerCase() === "(localdb)" || server.toLowerCase() === "(local)") {
            server = "localhost";
          }
          Object.assign(config, {
            port,
            server
          });
          if (instanceName) {
            Object.assign(config.options, {
              instanceName
            });
          }
          break;
        }
        case "encrypt":
          Object.assign(config.options, {
            encrypt: !!value
          });
          break;
        case "enlist":
          break;
        case "failover partner":
          break;
        case "initial catalog":
          Object.assign(config, {
            database: value
          });
          break;
        case "integrated security":
          break;
        case "max pool size":
          Object.assign(config.pool, {
            max: value
          });
          break;
        case "min pool size":
          Object.assign(config.pool, {
            min: value
          });
          break;
        case "msi endpoint":
          Object.assign(config, {
            msiEndpoint: value
          });
          break;
        case "msi secret":
          Object.assign(config, {
            msiSecret: value
          });
          break;
        case "multipleactiveresultsets":
          break;
        case "multisubnetfailover":
          Object.assign(config.options, {
            multiSubnetFailover: value
          });
          break;
        case "network library":
          break;
        case "packet size":
          Object.assign(config.options, {
            packetSize: value
          });
          break;
        case "password":
          Object.assign(config, {
            password: value
          });
          break;
        case "persist security info":
          break;
        case "poolblockingperiod":
          break;
        case "pooling":
          break;
        case "replication":
          break;
        case "tenant id":
          Object.assign(config, {
            tenantId: value
          });
          break;
        case "token":
          Object.assign(config, {
            token: value
          });
          break;
        case "transaction binding":
          Object.assign(config.options, {
            enableImplicitTransactions: value.toLowerCase() === "implicit unbind"
          });
          break;
        case "transparentnetworkipresolution":
          break;
        case "trustservercertificate":
          Object.assign(config.options, {
            trustServerCertificate: value
          });
          break;
        case "type system version":
          break;
        case "user id": {
          let user = value;
          let domain;
          const domainUser = /^(.*)\\(.*)$/.exec(user);
          if (domainUser) {
            domain = domainUser[1];
            user = domainUser[2];
          }
          if (domain) {
            Object.assign(config, {
              domain
            });
          }
          if (user) {
            Object.assign(config, {
              user
            });
          }
          break;
        }
        case "user instance":
          break;
        case "workstation id":
          Object.assign(config.options, {
            workstationId: value
          });
          break;
        case "request timeout":
          Object.assign(config, {
            requestTimeout: parseInt(value, 10)
          });
          break;
        case "stream":
          Object.assign(config, {
            stream: !!value
          });
          break;
        case "useutc":
          Object.assign(config.options, {
            useUTC: !!value
          });
          break;
        case "parsejson":
          Object.assign(config, {
            parseJSON: !!value
          });
          break;
      }
      return config;
    }, { options: {}, pool: {} });
  }
  /**
   * Acquire connection from this connection pool.
   *
   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
   * @return {ConnectionPool|Promise}
   */
  acquire(requester, callback) {
    const acquirePromise = shared$4.Promise.resolve(this._acquire().promise).catch((err) => {
      this.emit("error", err);
      throw err;
    });
    if (typeof callback === "function") {
      acquirePromise.then((connection2) => callback(null, connection2, this.config)).catch(callback);
      return this;
    }
    return acquirePromise;
  }
  _acquire() {
    if (!this.pool) {
      return shared$4.Promise.reject(new ConnectionError$3("Connection not yet open.", "ENOTOPEN"));
    } else if (this.pool.destroyed) {
      return shared$4.Promise.reject(new ConnectionError$3("Connection is closing", "ENOTOPEN"));
    }
    return this.pool.acquire();
  }
  /**
   * Release connection back to the pool.
   *
   * @param {Connection} connection Previously acquired connection.
   * @return {ConnectionPool}
   */
  release(connection2) {
    debug$c("connection(%d): released", IDS$6.get(connection2));
    if (this.pool) {
      this.pool.release(connection2);
    }
    return this;
  }
  /**
   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
   *
   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
   * @return {ConnectionPool|Promise}
   */
  connect(callback) {
    if (typeof callback === "function") {
      this._connect(callback);
      return this;
    }
    return new shared$4.Promise((resolve, reject) => {
      return this._connect((err) => {
        if (err) return reject(err);
        resolve(this);
      });
    });
  }
  /**
   * @private
   * @param {basicCallback} callback
   */
  _connect(callback) {
    if (this._connected) {
      debug$c("pool(%d): already connected, executing connect callback immediately", IDS$6.get(this));
      return setImmediate(callback, null, this);
    }
    this._connectStack.push(callback);
    if (this._connecting) {
      return;
    }
    this._connecting = true;
    debug$c("pool(%d): connecting", IDS$6.get(this));
    this._poolCreate().then((connection2) => {
      debug$c("pool(%d): connected", IDS$6.get(this));
      this._healthy = true;
      return this._poolDestroy(connection2).then(() => {
        this.pool = new tarn.Pool(
          Object.assign({
            create: () => this._poolCreate().then((connection3) => {
              this._healthy = true;
              return connection3;
            }).catch((err) => {
              if (this.pool.numUsed() + this.pool.numFree() <= 0) {
                this._healthy = false;
              }
              throw err;
            }),
            validate: this._poolValidate.bind(this),
            destroy: this._poolDestroy.bind(this),
            max: 10,
            min: 0,
            idleTimeoutMillis: 3e4,
            propagateCreateError: true
          }, this.config.pool)
        );
        this._connecting = false;
        this._connected = true;
      });
    }).then(() => {
      this._connectStack.forEach((cb) => {
        setImmediate(cb, null, this);
      });
    }).catch((err) => {
      this._connecting = false;
      this._connectStack.forEach((cb) => {
        setImmediate(cb, err);
      });
    }).then(() => {
      this._connectStack = [];
    });
  }
  get size() {
    return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();
  }
  get available() {
    return this.pool.numFree();
  }
  get pending() {
    return this.pool.numPendingAcquires();
  }
  get borrowed() {
    return this.pool.numUsed();
  }
  /**
   * Close all active connections in the pool.
   *
   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
   * @return {ConnectionPool|Promise}
   */
  close(callback) {
    if (typeof callback === "function") {
      this._close(callback);
      return this;
    }
    return new shared$4.Promise((resolve, reject) => {
      this._close((err) => {
        if (err) return reject(err);
        resolve(this);
      });
    });
  }
  /**
   * @private
   * @param {basicCallback} callback
   */
  _close(callback) {
    if (this._connecting) {
      debug$c("pool(%d): close called while connecting", IDS$6.get(this));
      setImmediate(callback, new ConnectionError$3("Cannot close a pool while it is connecting"));
    }
    if (!this.pool) {
      debug$c("pool(%d): already closed, executing close callback immediately", IDS$6.get(this));
      return setImmediate(callback, null);
    }
    this._closeStack.push(callback);
    if (this.pool.destroyed) return;
    this._connecting = this._connected = this._healthy = false;
    this.pool.destroy().then(() => {
      debug$c("pool(%d): pool closed, removing pool reference and executing close callbacks", IDS$6.get(this));
      this.pool = null;
      this._closeStack.forEach((cb) => {
        setImmediate(cb, null);
      });
    }).catch((err) => {
      this.pool = null;
      this._closeStack.forEach((cb) => {
        setImmediate(cb, err);
      });
    }).then(() => {
      this._closeStack = [];
    });
  }
  /**
   * Returns new request using this connection.
   *
   * @return {Request}
   */
  request() {
    return new shared$4.driver.Request(this);
  }
  /**
   * Returns new transaction using this connection.
   *
   * @return {Transaction}
   */
  transaction() {
    return new shared$4.driver.Transaction(this);
  }
  /**
   * Creates a new query using this connection from a tagged template string.
   *
   * @variation 1
   * @param {Array} strings Array of string literals.
   * @param {...*} keys Values.
   * @return {Request}
   */
  /**
   * Execute the SQL command.
   *
   * @variation 2
   * @param {String} command T-SQL command to be executed.
   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  query() {
    if (typeof arguments[0] === "string") {
      return new shared$4.driver.Request(this).query(arguments[0], arguments[1]);
    }
    const values2 = Array.prototype.slice.call(arguments);
    const strings = values2.shift();
    return new shared$4.driver.Request(this)._template(strings, values2, "query");
  }
  /**
   * Creates a new batch using this connection from a tagged template string.
   *
   * @variation 1
   * @param {Array} strings Array of string literals.
   * @param {...*} keys Values.
   * @return {Request}
   */
  /**
   * Execute the SQL command.
   *
   * @variation 2
   * @param {String} command T-SQL command to be executed.
   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  batch() {
    if (typeof arguments[0] === "string") {
      return new shared$4.driver.Request(this).batch(arguments[0], arguments[1]);
    }
    const values2 = Array.prototype.slice.call(arguments);
    const strings = values2.shift();
    return new shared$4.driver.Request(this)._template(strings, values2, "batch");
  }
};
var connectionPool$1 = ConnectionPool$1;
var globalConnection$3 = { exports: {} };
(function(module2) {
  const shared2 = sharedExports;
  let globalConnection2 = null;
  const globalConnectionHandlers = {};
  function connect(config, callback) {
    if (!globalConnection2) {
      globalConnection2 = new shared2.driver.ConnectionPool(config);
      for (const event in globalConnectionHandlers) {
        for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
          globalConnection2.on(event, globalConnectionHandlers[event][i]);
        }
      }
      const ogClose = globalConnection2.close;
      const globalClose = function(callback2) {
        for (const event in globalConnectionHandlers) {
          for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
            this.removeListener(event, globalConnectionHandlers[event][i]);
          }
        }
        this.on("error", (err) => {
          if (globalConnectionHandlers.error) {
            for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
              globalConnectionHandlers.error[i].call(this, err);
            }
          }
        });
        globalConnection2 = null;
        return ogClose.call(this, callback2);
      };
      globalConnection2.close = globalClose.bind(globalConnection2);
    }
    if (typeof callback === "function") {
      return globalConnection2.connect((err, connection2) => {
        if (err) {
          globalConnection2 = null;
        }
        callback(err, connection2);
      });
    }
    return globalConnection2.connect().catch((err) => {
      globalConnection2 = null;
      return shared2.Promise.reject(err);
    });
  }
  function close(callback) {
    if (globalConnection2) {
      const gc = globalConnection2;
      globalConnection2 = null;
      return gc.close(callback);
    }
    if (typeof callback === "function") {
      setImmediate(callback);
      return null;
    }
    return new shared2.Promise((resolve) => {
      resolve(globalConnection2);
    });
  }
  function on(event, handler2) {
    if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = [];
    globalConnectionHandlers[event].push(handler2);
    if (globalConnection2) globalConnection2.on(event, handler2);
    return globalConnection2;
  }
  function removeListener(event, handler2) {
    if (!globalConnectionHandlers[event]) return globalConnection2;
    const index = globalConnectionHandlers[event].indexOf(handler2);
    if (index === -1) return globalConnection2;
    globalConnectionHandlers[event].splice(index, 1);
    if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = void 0;
    if (globalConnection2) globalConnection2.removeListener(event, handler2);
    return globalConnection2;
  }
  function query() {
    if (typeof arguments[0] === "string") {
      return new shared2.driver.Request().query(arguments[0], arguments[1]);
    }
    const values2 = Array.prototype.slice.call(arguments);
    const strings = values2.shift();
    return new shared2.driver.Request()._template(strings, values2, "query");
  }
  function batch() {
    if (typeof arguments[0] === "string") {
      return new shared2.driver.Request().batch(arguments[0], arguments[1]);
    }
    const values2 = Array.prototype.slice.call(arguments);
    const strings = values2.shift();
    return new shared2.driver.Request()._template(strings, values2, "batch");
  }
  module2.exports = {
    batch,
    close,
    connect,
    off: removeListener,
    on,
    query,
    removeListener
  };
  Object.defineProperty(module2.exports, "pool", {
    get: () => {
      return globalConnection2;
    },
    set: () => {
    }
  });
})(globalConnection$3);
var globalConnectionExports = globalConnection$3.exports;
const debug$b = srcExports("mssql:base");
const { EventEmitter: EventEmitter$3 } = require$$0$3;
const { IDS: IDS$5, objectHasProperty: objectHasProperty$2 } = utils;
const globalConnection$2 = globalConnectionExports;
const { TransactionError: TransactionError$2, PreparedStatementError: PreparedStatementError2 } = error;
const shared$3 = sharedExports;
const { TYPES: TYPES$3, declare: declare$1 } = datatypesExports;
class PreparedStatement extends EventEmitter$3 {
  /**
   * Creates a new Prepared Statement.
   *
   * @param {ConnectionPool|Transaction} [holder]
   */
  constructor(parent) {
    super();
    IDS$5.add(this, "PreparedStatement");
    debug$b("ps(%d): created", IDS$5.get(this));
    this.parent = parent || globalConnection$2.pool;
    this._handle = 0;
    this.prepared = false;
    this.parameters = {};
  }
  get config() {
    return this.parent.config;
  }
  get connected() {
    return this.parent.connected;
  }
  /**
   * Acquire connection from connection pool.
   *
   * @param {Request} request Request.
   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
   * @return {PreparedStatement|Promise}
   */
  acquire(request2, callback) {
    if (!this._acquiredConnection) {
      setImmediate(callback, new PreparedStatementError2("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
      return this;
    }
    if (this._activeRequest) {
      setImmediate(callback, new TransactionError$2("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
      return this;
    }
    this._activeRequest = request2;
    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
    return this;
  }
  /**
   * Release connection back to the pool.
   *
   * @param {Connection} connection Previously acquired connection.
   * @return {PreparedStatement}
   */
  release(connection2) {
    if (connection2 === this._acquiredConnection) {
      this._activeRequest = null;
    }
    return this;
  }
  /**
   * Add an input parameter to the prepared statement.
   *
   * @param {String} name Name of the input parameter without @ char.
   * @param {*} type SQL data type of input parameter.
   * @return {PreparedStatement}
   */
  input(name2, type2) {
    if (/(--| |\/\*|\*\/|')/.test(name2)) {
      throw new PreparedStatementError2(`SQL injection warning for param '${name2}'`, "EINJECT");
    }
    if (arguments.length < 2) {
      throw new PreparedStatementError2("Invalid number of arguments. 2 arguments expected.", "EARGS");
    }
    if (type2 instanceof Function) {
      type2 = type2();
    }
    if (objectHasProperty$2(this.parameters, name2)) {
      throw new PreparedStatementError2(`The parameter name ${name2} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
    }
    this.parameters[name2] = {
      name: name2,
      type: type2.type,
      io: 1,
      length: type2.length,
      scale: type2.scale,
      precision: type2.precision,
      tvpType: type2.tvpType
    };
    return this;
  }
  /**
   * Replace an input parameter on the request.
   *
   * @param {String} name Name of the input parameter without @ char.
   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
   * @return {Request}
   */
  replaceInput(name2, type2, value) {
    delete this.parameters[name2];
    return this.input(name2, type2, value);
  }
  /**
   * Add an output parameter to the prepared statement.
   *
   * @param {String} name Name of the output parameter without @ char.
   * @param {*} type SQL data type of output parameter.
   * @return {PreparedStatement}
   */
  output(name2, type2) {
    if (/(--| |\/\*|\*\/|')/.test(name2)) {
      throw new PreparedStatementError2(`SQL injection warning for param '${name2}'`, "EINJECT");
    }
    if (arguments.length < 2) {
      throw new PreparedStatementError2("Invalid number of arguments. 2 arguments expected.", "EARGS");
    }
    if (type2 instanceof Function) type2 = type2();
    if (objectHasProperty$2(this.parameters, name2)) {
      throw new PreparedStatementError2(`The parameter name ${name2} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
    }
    this.parameters[name2] = {
      name: name2,
      type: type2.type,
      io: 2,
      length: type2.length,
      scale: type2.scale,
      precision: type2.precision
    };
    return this;
  }
  /**
   * Replace an output parameter on the request.
   *
   * @param {String} name Name of the output parameter without @ char.
   * @param {*} type SQL data type of output parameter.
   * @return {PreparedStatement}
   */
  replaceOutput(name2, type2) {
    delete this.parameters[name2];
    return this.output(name2, type2);
  }
  /**
   * Prepare a statement.
   *
   * @param {String} statement SQL statement to prepare.
   * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
   * @return {PreparedStatement|Promise}
   */
  prepare(statement, callback) {
    if (typeof callback === "function") {
      this._prepare(statement, callback);
      return this;
    }
    return new shared$3.Promise((resolve, reject) => {
      this._prepare(statement, (err) => {
        if (err) return reject(err);
        resolve(this);
      });
    });
  }
  /**
   * @private
   * @param {String} statement
   * @param {basicCallback} callback
   */
  _prepare(statement, callback) {
    debug$b("ps(%d): prepare", IDS$5.get(this));
    if (typeof statement === "function") {
      callback = statement;
      statement = void 0;
    }
    if (this.prepared) {
      return setImmediate(callback, new PreparedStatementError2("Statement is already prepared.", "EALREADYPREPARED"));
    }
    this.statement = statement || this.statement;
    this.parent.acquire(this, (err, connection2, config) => {
      if (err) return callback(err);
      this._acquiredConnection = connection2;
      this._acquiredConfig = config;
      const req2 = new shared$3.driver.Request(this);
      req2.stream = false;
      req2.output("handle", TYPES$3.Int);
      req2.input("params", TYPES$3.NVarChar, (() => {
        const result = [];
        for (const name2 in this.parameters) {
          if (!objectHasProperty$2(this.parameters, name2)) {
            continue;
          }
          const param = this.parameters[name2];
          result.push(`@${name2} ${declare$1(param.type, param)}${param.io === 2 ? " output" : ""}`);
        }
        return result;
      })().join(","));
      req2.input("stmt", TYPES$3.NVarChar, this.statement);
      req2.execute("sp_prepare", (err2, result) => {
        if (err2) {
          this.parent.release(this._acquiredConnection);
          this._acquiredConnection = null;
          this._acquiredConfig = null;
          return callback(err2);
        }
        debug$b("ps(%d): prepared", IDS$5.get(this));
        this._handle = result.output.handle;
        this.prepared = true;
        callback(null);
      });
    });
  }
  /**
   * Execute a prepared statement.
   *
   * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
   * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  execute(values2, callback) {
    if (this.stream || typeof callback === "function") {
      return this._execute(values2, callback);
    }
    return new shared$3.Promise((resolve, reject) => {
      this._execute(values2, (err, recordset) => {
        if (err) return reject(err);
        resolve(recordset);
      });
    });
  }
  /**
   * @private
   * @param {Object} values
   * @param {basicCallback} callback
   */
  _execute(values2, callback) {
    const req2 = new shared$3.driver.Request(this);
    req2.stream = this.stream;
    req2.arrayRowMode = this.arrayRowMode;
    req2.input("handle", TYPES$3.Int, this._handle);
    for (const name2 in this.parameters) {
      if (!objectHasProperty$2(this.parameters, name2)) {
        continue;
      }
      const param = this.parameters[name2];
      req2.parameters[name2] = {
        name: name2,
        type: param.type,
        io: param.io,
        value: values2[name2],
        length: param.length,
        scale: param.scale,
        precision: param.precision
      };
    }
    req2.execute("sp_execute", (err, result) => {
      if (err) return callback(err);
      callback(null, result);
    });
    return req2;
  }
  /**
   * Unprepare a prepared statement.
   *
   * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
   * @return {PreparedStatement|Promise}
   */
  unprepare(callback) {
    if (typeof callback === "function") {
      this._unprepare(callback);
      return this;
    }
    return new shared$3.Promise((resolve, reject) => {
      this._unprepare((err) => {
        if (err) return reject(err);
        resolve();
      });
    });
  }
  /**
   * @private
   * @param {basicCallback} callback
   */
  _unprepare(callback) {
    debug$b("ps(%d): unprepare", IDS$5.get(this));
    if (!this.prepared) {
      return setImmediate(callback, new PreparedStatementError2("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
    }
    if (this._activeRequest) {
      return setImmediate(callback, new TransactionError$2("Can't unprepare the statement. There is a request in progress.", "EREQINPROG"));
    }
    const req2 = new shared$3.driver.Request(this);
    req2.stream = false;
    req2.input("handle", TYPES$3.Int, this._handle);
    req2.execute("sp_unprepare", (err) => {
      if (err) return callback(err);
      this.parent.release(this._acquiredConnection);
      this._acquiredConnection = null;
      this._acquiredConfig = null;
      this._handle = 0;
      this.prepared = false;
      debug$b("ps(%d): unprepared", IDS$5.get(this));
      return callback(null);
    });
  }
}
var preparedStatement = PreparedStatement;
const debug$a = srcExports("mssql:base");
const { EventEmitter: EventEmitter$2 } = require$$0$3;
const { Readable } = require$$0$4;
const { IDS: IDS$4, objectHasProperty: objectHasProperty$1 } = utils;
const globalConnection$1 = globalConnectionExports;
const { RequestError: RequestError$2, ConnectionError: ConnectionError$2 } = error;
const { TYPES: TYPES$2 } = datatypesExports;
const shared$2 = sharedExports;
let Request$1 = class Request extends EventEmitter$2 {
  /**
   * Create new Request.
   *
   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
   */
  constructor(parent) {
    super();
    IDS$4.add(this, "Request");
    debug$a("request(%d): created", IDS$4.get(this));
    this.canceled = false;
    this._paused = false;
    this.parent = parent || globalConnection$1.pool;
    this.parameters = {};
    this.stream = null;
    this.arrayRowMode = null;
  }
  get paused() {
    return this._paused;
  }
  /**
   * Generate sql string and set input parameters from tagged template string.
   *
   * @param {Template literal} template
   * @return {String}
   */
  template() {
    const values2 = Array.prototype.slice.call(arguments);
    const strings = values2.shift();
    return this._template(strings, values2);
  }
  /**
   * Fetch request from tagged template string.
   *
   * @private
   * @param {Array} strings
   * @param {Array} values
   * @param {String} [method] If provided, method is automatically called with serialized command on this object.
   * @return {Request}
   */
  _template(strings, values2, method) {
    const command = [strings[0]];
    for (let index = 0; index < values2.length; index++) {
      const value = values2[index];
      if (Array.isArray(value)) {
        for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
          this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
          command.push(`@param${index + 1}_${parameterIndex}`);
          if (parameterIndex < value.length - 1) {
            command.push(", ");
          }
        }
        command.push(strings[index + 1]);
      } else {
        this.input(`param${index + 1}`, value);
        command.push(`@param${index + 1}`, strings[index + 1]);
      }
    }
    if (method) {
      return this[method](command.join(""));
    } else {
      return command.join("");
    }
  }
  /**
   * Add an input parameter to the request.
   *
   * @param {String} name Name of the input parameter without @ char.
   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
   * @return {Request}
   */
  input(name2, type2, value) {
    if (/(--| |\/\*|\*\/|')/.test(name2)) {
      throw new RequestError$2(`SQL injection warning for param '${name2}'`, "EINJECT");
    }
    if (arguments.length < 2) {
      throw new RequestError$2("Invalid number of arguments. At least 2 arguments expected.", "EARGS");
    } else if (arguments.length === 2) {
      value = type2;
      type2 = shared$2.getTypeByValue(value);
    }
    if (value && typeof value.valueOf === "function" && !(value instanceof Date)) value = value.valueOf();
    if (value === void 0) value = null;
    if (typeof value === "number" && isNaN(value)) value = null;
    if (type2 instanceof Function) type2 = type2();
    if (objectHasProperty$1(this.parameters, name2)) {
      throw new RequestError$2(`The parameter name ${name2} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
    }
    this.parameters[name2] = {
      name: name2,
      type: type2.type,
      io: 1,
      value,
      length: type2.length,
      scale: type2.scale,
      precision: type2.precision,
      tvpType: type2.tvpType
    };
    return this;
  }
  /**
   * Replace an input parameter on the request.
   *
   * @param {String} name Name of the input parameter without @ char.
   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
   * @return {Request}
   */
  replaceInput(name2, type2, value) {
    delete this.parameters[name2];
    return this.input(name2, type2, value);
  }
  /**
   * Add an output parameter to the request.
   *
   * @param {String} name Name of the output parameter without @ char.
   * @param {*} type SQL data type of output parameter.
   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
   * @return {Request}
   */
  output(name2, type2, value) {
    if (!type2) {
      type2 = TYPES$2.NVarChar;
    }
    if (/(--| |\/\*|\*\/|')/.test(name2)) {
      throw new RequestError$2(`SQL injection warning for param '${name2}'`, "EINJECT");
    }
    if (type2 === TYPES$2.Text || type2 === TYPES$2.NText || type2 === TYPES$2.Image) {
      throw new RequestError$2("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", "EDEPRECATED");
    }
    if (value && typeof value.valueOf === "function" && !(value instanceof Date)) value = value.valueOf();
    if (value === void 0) value = null;
    if (typeof value === "number" && isNaN(value)) value = null;
    if (type2 instanceof Function) type2 = type2();
    if (objectHasProperty$1(this.parameters, name2)) {
      throw new RequestError$2(`The parameter name ${name2} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
    }
    this.parameters[name2] = {
      name: name2,
      type: type2.type,
      io: 2,
      value,
      length: type2.length,
      scale: type2.scale,
      precision: type2.precision
    };
    return this;
  }
  /**
   * Replace an output parameter on the request.
   *
   * @param {String} name Name of the output parameter without @ char.
   * @param {*} type SQL data type of output parameter.
   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
   * @return {Request}
   */
  replaceOutput(name2, type2, value) {
    delete this.parameters[name2];
    return this.output(name2, type2, value);
  }
  /**
   * Execute the SQL batch.
   *
   * @param {String} batch T-SQL batch to be executed.
   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  batch(batch, callback) {
    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
    this.rowsAffected = 0;
    if (typeof callback === "function") {
      this._batch(batch, (err, recordsets, output, rowsAffected) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected
          });
        }
        if (err) return callback(err);
        callback(null, {
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected
        });
      });
      return this;
    }
    if (typeof batch === "object") {
      const values2 = Array.prototype.slice.call(arguments);
      const strings = values2.shift();
      batch = this._template(strings, values2);
    }
    return new shared$2.Promise((resolve, reject) => {
      this._batch(batch, (err, recordsets, output, rowsAffected) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected
          });
        }
        if (err) return reject(err);
        resolve({
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected
        });
      });
    });
  }
  /**
   * @private
   * @param {String} batch
   * @param {Request~requestCallback} callback
   */
  _batch(batch, callback) {
    if (!this.parent) {
      return setImmediate(callback, new RequestError$2("No connection is specified for that request.", "ENOCONN"));
    }
    if (!this.parent.connected) {
      return setImmediate(callback, new ConnectionError$2("Connection is closed.", "ECONNCLOSED"));
    }
    this.canceled = false;
    setImmediate(callback);
  }
  /**
   * Bulk load.
   *
   * @param {Table} table SQL table.
   * @param {object} [options] Options to be passed to the underlying driver (tedious only).
   * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  bulk(table2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (typeof options === "undefined") {
      options = {};
    }
    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
    if (this.stream || typeof callback === "function") {
      this._bulk(table2, options, (err, rowsAffected) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          return this.emit("done", {
            rowsAffected
          });
        }
        if (err) return callback(err);
        callback(null, {
          rowsAffected
        });
      });
      return this;
    }
    return new shared$2.Promise((resolve, reject) => {
      this._bulk(table2, options, (err, rowsAffected) => {
        if (err) return reject(err);
        resolve({
          rowsAffected
        });
      });
    });
  }
  /**
   * @private
   * @param {Table} table
   * @param {object} options
   * @param {Request~bulkCallback} callback
   */
  _bulk(table2, options, callback) {
    if (!this.parent) {
      return setImmediate(callback, new RequestError$2("No connection is specified for that request.", "ENOCONN"));
    }
    if (!this.parent.connected) {
      return setImmediate(callback, new ConnectionError$2("Connection is closed.", "ECONNCLOSED"));
    }
    this.canceled = false;
    setImmediate(callback);
  }
  /**
   * Wrap original request in a Readable stream that supports back pressure and return.
   * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
   *
   * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
   * @return {Stream}
   */
  toReadableStream(streamOptions = {}) {
    this.stream = true;
    this.pause();
    const readableStream = new Readable({
      ...streamOptions,
      objectMode: true,
      read: () => {
        this.resume();
      }
    });
    this.on("row", (row) => {
      if (!readableStream.push(row)) {
        this.pause();
      }
    });
    this.on("error", (error2) => {
      readableStream.emit("error", error2);
    });
    this.on("done", () => {
      readableStream.push(null);
    });
    return readableStream;
  }
  /**
   * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
   * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
   *
   * @param {Stream} stream Stream to pipe data into.
   * @return {Stream}
   */
  pipe(writableStream) {
    const readableStream = this.toReadableStream();
    return readableStream.pipe(writableStream);
  }
  /**
   * Execute the SQL command.
   *
   * @param {String} command T-SQL command to be executed.
   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  query(command, callback) {
    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
    this.rowsAffected = 0;
    if (typeof callback === "function") {
      this._query(command, (err, recordsets, output, rowsAffected, columns) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected
          });
        }
        if (err) return callback(err);
        const result = {
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected
        };
        if (this.arrayRowMode) result.columns = columns;
        callback(null, result);
      });
      return this;
    }
    if (typeof command === "object") {
      const values2 = Array.prototype.slice.call(arguments);
      const strings = values2.shift();
      command = this._template(strings, values2);
    }
    return new shared$2.Promise((resolve, reject) => {
      this._query(command, (err, recordsets, output, rowsAffected, columns) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected
          });
        }
        if (err) return reject(err);
        const result = {
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected
        };
        if (this.arrayRowMode) result.columns = columns;
        resolve(result);
      });
    });
  }
  /**
   * @private
   * @param {String} command
   * @param {Request~bulkCallback} callback
   */
  _query(command, callback) {
    if (!this.parent) {
      return setImmediate(callback, new RequestError$2("No connection is specified for that request.", "ENOCONN"));
    }
    if (!this.parent.connected) {
      return setImmediate(callback, new ConnectionError$2("Connection is closed.", "ECONNCLOSED"));
    }
    this.canceled = false;
    setImmediate(callback);
  }
  /**
   * Call a stored procedure.
   *
   * @param {String} procedure Name of the stored procedure to be executed.
   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
   * @return {Request|Promise}
   */
  execute(command, callback) {
    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
    this.rowsAffected = 0;
    if (typeof callback === "function") {
      this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected,
            returnValue
          });
        }
        if (err) return callback(err);
        const result = {
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected,
          returnValue
        };
        if (this.arrayRowMode) result.columns = columns;
        callback(null, result);
      });
      return this;
    }
    return new shared$2.Promise((resolve, reject) => {
      this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
        if (this.stream) {
          if (err) this.emit("error", err);
          err = null;
          this.emit("done", {
            output,
            rowsAffected,
            returnValue
          });
        }
        if (err) return reject(err);
        const result = {
          recordsets,
          recordset: recordsets && recordsets[0],
          output,
          rowsAffected,
          returnValue
        };
        if (this.arrayRowMode) result.columns = columns;
        resolve(result);
      });
    });
  }
  /**
   * @private
   * @param {String} procedure
   * @param {Request~bulkCallback} callback
   */
  _execute(procedure, callback) {
    if (!this.parent) {
      return setImmediate(callback, new RequestError$2("No connection is specified for that request.", "ENOCONN"));
    }
    if (!this.parent.connected) {
      return setImmediate(callback, new ConnectionError$2("Connection is closed.", "ECONNCLOSED"));
    }
    this.canceled = false;
    setImmediate(callback);
  }
  /**
   * Cancel currently executed request.
   *
   * @return {Boolean}
   */
  cancel() {
    this._cancel();
    return true;
  }
  /**
   * @private
   */
  _cancel() {
    this.canceled = true;
  }
  pause() {
    if (this.stream) {
      this._pause();
      return true;
    }
    return false;
  }
  _pause() {
    this._paused = true;
  }
  resume() {
    if (this.stream) {
      this._resume();
      return true;
    }
    return false;
  }
  _resume() {
    this._paused = false;
  }
  _setCurrentRequest(request2) {
    this._currentRequest = request2;
    if (this._paused) {
      this.pause();
    }
    return this;
  }
};
var request$2 = Request$1;
var isolationlevel = {
  READ_UNCOMMITTED: 1,
  READ_COMMITTED: 2,
  REPEATABLE_READ: 3,
  SERIALIZABLE: 4,
  SNAPSHOT: 5
};
const debug$9 = srcExports("mssql:base");
const { EventEmitter: EventEmitter$1 } = require$$0$3;
const { IDS: IDS$3 } = utils;
const globalConnection = globalConnectionExports;
const { TransactionError: TransactionError$1 } = error;
const shared$1 = sharedExports;
const ISOLATION_LEVEL$1 = isolationlevel;
let Transaction$2 = class Transaction extends EventEmitter$1 {
  /**
   * Create new Transaction.
   *
   * @param {Connection} [parent] If ommited, global connection is used instead.
   */
  constructor(parent) {
    super();
    IDS$3.add(this, "Transaction");
    debug$9("transaction(%d): created", IDS$3.get(this));
    this.parent = parent || globalConnection.pool;
    this.isolationLevel = Transaction.defaultIsolationLevel;
    this.name = "";
  }
  get config() {
    return this.parent.config;
  }
  get connected() {
    return this.parent.connected;
  }
  /**
   * Acquire connection from connection pool.
   *
   * @param {Request} request Request.
   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
   * @return {Transaction|Promise}
   */
  acquire(request2, callback) {
    if (!this._acquiredConnection) {
      setImmediate(callback, new TransactionError$1("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
      return this;
    }
    if (this._activeRequest) {
      setImmediate(callback, new TransactionError$1("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
      return this;
    }
    this._activeRequest = request2;
    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
    return this;
  }
  /**
   * Release connection back to the pool.
   *
   * @param {Connection} connection Previously acquired connection.
   * @return {Transaction}
   */
  release(connection2) {
    if (connection2 === this._acquiredConnection) {
      this._activeRequest = null;
    }
    return this;
  }
  /**
   * Begin a transaction.
   *
   * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
   * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
   * @return {Transaction|Promise}
   */
  begin(isolationLevel, callback) {
    if (isolationLevel instanceof Function) {
      callback = isolationLevel;
      isolationLevel = void 0;
    }
    if (typeof callback === "function") {
      this._begin(isolationLevel, (err) => {
        if (!err) {
          this.emit("begin");
        }
        callback(err);
      });
      return this;
    }
    return new shared$1.Promise((resolve, reject) => {
      this._begin(isolationLevel, (err) => {
        if (err) return reject(err);
        this.emit("begin");
        resolve(this);
      });
    });
  }
  /**
   * @private
   * @param {Number} [isolationLevel]
   * @param {basicCallback} [callback]
   * @return {Transaction}
   */
  _begin(isolationLevel, callback) {
    if (this._acquiredConnection) {
      return setImmediate(callback, new TransactionError$1("Transaction has already begun.", "EALREADYBEGUN"));
    }
    this._aborted = false;
    this._rollbackRequested = false;
    if (isolationLevel) {
      if (Object.keys(ISOLATION_LEVEL$1).some((key2) => {
        return ISOLATION_LEVEL$1[key2] === isolationLevel;
      })) {
        this.isolationLevel = isolationLevel;
      } else {
        throw new TransactionError$1("Invalid isolation level.");
      }
    }
    setImmediate(callback);
  }
  /**
   * Commit a transaction.
   *
   * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
   * @return {Transaction|Promise}
   */
  commit(callback) {
    if (typeof callback === "function") {
      this._commit((err) => {
        if (!err) {
          this.emit("commit");
        }
        callback(err);
      });
      return this;
    }
    return new shared$1.Promise((resolve, reject) => {
      this._commit((err) => {
        if (err) return reject(err);
        this.emit("commit");
        resolve();
      });
    });
  }
  /**
   * @private
   * @param {basicCallback} [callback]
   * @return {Transaction}
   */
  _commit(callback) {
    if (this._aborted) {
      return setImmediate(callback, new TransactionError$1("Transaction has been aborted.", "EABORT"));
    }
    if (!this._acquiredConnection) {
      return setImmediate(callback, new TransactionError$1("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
    }
    if (this._activeRequest) {
      return setImmediate(callback, new TransactionError$1("Can't commit transaction. There is a request in progress.", "EREQINPROG"));
    }
    setImmediate(callback);
  }
  /**
   * Returns new request using this transaction.
   *
   * @return {Request}
   */
  request() {
    return new shared$1.driver.Request(this);
  }
  /**
   * Rollback a transaction.
   *
   * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
   * @return {Transaction|Promise}
   */
  rollback(callback) {
    if (typeof callback === "function") {
      this._rollback((err) => {
        if (!err) {
          this.emit("rollback", this._aborted);
        }
        callback(err);
      });
      return this;
    }
    return new shared$1.Promise((resolve, reject) => {
      return this._rollback((err) => {
        if (err) return reject(err);
        this.emit("rollback", this._aborted);
        resolve();
      });
    });
  }
  /**
   * @private
   * @param {basicCallback} [callback]
   * @return {Transaction}
   */
  _rollback(callback) {
    if (this._aborted) {
      return setImmediate(callback, new TransactionError$1("Transaction has been aborted.", "EABORT"));
    }
    if (!this._acquiredConnection) {
      return setImmediate(callback, new TransactionError$1("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
    }
    if (this._activeRequest) {
      return setImmediate(callback, new TransactionError$1("Can't rollback transaction. There is a request in progress.", "EREQINPROG"));
    }
    this._rollbackRequested = true;
    setImmediate(callback);
  }
};
Transaction$2.defaultIsolationLevel = ISOLATION_LEVEL$1.READ_COMMITTED;
var transaction$2 = Transaction$2;
(function(module2) {
  const ConnectionPool3 = connectionPool$1;
  const PreparedStatement2 = preparedStatement;
  const Request3 = request$2;
  const Transaction4 = transaction$2;
  const { ConnectionError: ConnectionError4, TransactionError: TransactionError3, RequestError: RequestError4, PreparedStatementError: PreparedStatementError3, MSSQLError: MSSQLError3 } = error;
  const shared2 = sharedExports;
  const Table2 = table;
  const ISOLATION_LEVEL2 = isolationlevel;
  const { TYPES: TYPES2 } = datatypesExports;
  const { connect, close, on, off, removeListener, query, batch } = globalConnectionExports;
  module2.exports = {
    ConnectionPool: ConnectionPool3,
    Transaction: Transaction4,
    Request: Request3,
    PreparedStatement: PreparedStatement2,
    ConnectionError: ConnectionError4,
    TransactionError: TransactionError3,
    RequestError: RequestError4,
    PreparedStatementError: PreparedStatementError3,
    MSSQLError: MSSQLError3,
    driver: shared2.driver,
    exports: {
      ConnectionError: ConnectionError4,
      TransactionError: TransactionError3,
      RequestError: RequestError4,
      PreparedStatementError: PreparedStatementError3,
      MSSQLError: MSSQLError3,
      Table: Table2,
      ISOLATION_LEVEL: ISOLATION_LEVEL2,
      TYPES: TYPES2,
      MAX: 65535,
      // (1 << 16) - 1
      map: shared2.map,
      getTypeByValue: shared2.getTypeByValue,
      connect,
      close,
      on,
      removeListener,
      off,
      query,
      batch
    }
  };
  Object.defineProperty(module2.exports, "Promise", {
    enumerable: true,
    get: () => {
      return shared2.Promise;
    },
    set: (value) => {
      shared2.Promise = value;
    }
  });
  Object.defineProperty(module2.exports, "valueHandler", {
    enumerable: true,
    value: shared2.valueHandler,
    writable: false,
    configurable: false
  });
  for (const key2 in TYPES2) {
    const value = TYPES2[key2];
    module2.exports.exports[key2] = value;
    module2.exports.exports[key2.toUpperCase()] = value;
  }
})(base);
var baseExports = base.exports;
var tedious = {};
var bulkLoad = { exports: {} };
var writableTrackingBuffer = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
  const SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  const UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
  const ZERO_LENGTH_BUFFER = Buffer.alloc(0);
  class WritableTrackingBuffer {
    constructor(initialSize, encoding, doubleSizeGrowth) {
      this.initialSize = void 0;
      this.encoding = void 0;
      this.doubleSizeGrowth = void 0;
      this.buffer = void 0;
      this.compositeBuffer = void 0;
      this.position = void 0;
      this.initialSize = initialSize;
      this.encoding = encoding || "ucs2";
      this.doubleSizeGrowth = doubleSizeGrowth || false;
      this.buffer = Buffer.alloc(this.initialSize, 0);
      this.compositeBuffer = ZERO_LENGTH_BUFFER;
      this.position = 0;
    }
    get data() {
      this.newBuffer(0);
      return this.compositeBuffer;
    }
    copyFrom(buffer2) {
      const length = buffer2.length;
      this.makeRoomFor(length);
      buffer2.copy(this.buffer, this.position);
      this.position += length;
    }
    makeRoomFor(requiredLength) {
      if (this.buffer.length - this.position < requiredLength) {
        if (this.doubleSizeGrowth) {
          let size = Math.max(128, this.buffer.length * 2);
          while (size < requiredLength) {
            size *= 2;
          }
          this.newBuffer(size);
        } else {
          this.newBuffer(requiredLength);
        }
      }
    }
    newBuffer(size) {
      const buffer2 = this.buffer.slice(0, this.position);
      this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer2]);
      this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
      this.position = 0;
    }
    writeUInt8(value) {
      const length = 1;
      this.makeRoomFor(length);
      this.buffer.writeUInt8(value, this.position);
      this.position += length;
    }
    writeUInt16LE(value) {
      const length = 2;
      this.makeRoomFor(length);
      this.buffer.writeUInt16LE(value, this.position);
      this.position += length;
    }
    writeUShort(value) {
      this.writeUInt16LE(value);
    }
    writeUInt16BE(value) {
      const length = 2;
      this.makeRoomFor(length);
      this.buffer.writeUInt16BE(value, this.position);
      this.position += length;
    }
    writeUInt24LE(value) {
      const length = 3;
      this.makeRoomFor(length);
      this.buffer[this.position + 2] = value >>> 16 & 255;
      this.buffer[this.position + 1] = value >>> 8 & 255;
      this.buffer[this.position] = value & 255;
      this.position += length;
    }
    writeUInt32LE(value) {
      const length = 4;
      this.makeRoomFor(length);
      this.buffer.writeUInt32LE(value, this.position);
      this.position += length;
    }
    writeBigInt64LE(value) {
      const length = 8;
      this.makeRoomFor(length);
      this.buffer.writeBigInt64LE(value, this.position);
      this.position += length;
    }
    writeInt64LE(value) {
      this.writeBigInt64LE(BigInt(value));
    }
    writeUInt64LE(value) {
      this.writeBigUInt64LE(BigInt(value));
    }
    writeBigUInt64LE(value) {
      const length = 8;
      this.makeRoomFor(length);
      this.buffer.writeBigUInt64LE(value, this.position);
      this.position += length;
    }
    writeUInt32BE(value) {
      const length = 4;
      this.makeRoomFor(length);
      this.buffer.writeUInt32BE(value, this.position);
      this.position += length;
    }
    writeUInt40LE(value) {
      this.writeInt32LE(value & -1);
      this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
    }
    writeInt8(value) {
      const length = 1;
      this.makeRoomFor(length);
      this.buffer.writeInt8(value, this.position);
      this.position += length;
    }
    writeInt16LE(value) {
      const length = 2;
      this.makeRoomFor(length);
      this.buffer.writeInt16LE(value, this.position);
      this.position += length;
    }
    writeInt16BE(value) {
      const length = 2;
      this.makeRoomFor(length);
      this.buffer.writeInt16BE(value, this.position);
      this.position += length;
    }
    writeInt32LE(value) {
      const length = 4;
      this.makeRoomFor(length);
      this.buffer.writeInt32LE(value, this.position);
      this.position += length;
    }
    writeInt32BE(value) {
      const length = 4;
      this.makeRoomFor(length);
      this.buffer.writeInt32BE(value, this.position);
      this.position += length;
    }
    writeFloatLE(value) {
      const length = 4;
      this.makeRoomFor(length);
      this.buffer.writeFloatLE(value, this.position);
      this.position += length;
    }
    writeDoubleLE(value) {
      const length = 8;
      this.makeRoomFor(length);
      this.buffer.writeDoubleLE(value, this.position);
      this.position += length;
    }
    writeString(value, encoding) {
      if (encoding == null) {
        encoding = this.encoding;
      }
      const length = Buffer.byteLength(value, encoding);
      this.makeRoomFor(length);
      this.buffer.write(value, this.position, encoding);
      this.position += length;
    }
    writeBVarchar(value, encoding) {
      this.writeUInt8(value.length);
      this.writeString(value, encoding);
    }
    writeUsVarchar(value, encoding) {
      this.writeUInt16LE(value.length);
      this.writeString(value, encoding);
    }
    // TODO: Figure out what types are passed in other than `Buffer`
    writeUsVarbyte(value, encoding) {
      if (encoding == null) {
        encoding = this.encoding;
      }
      let length;
      if (value instanceof Buffer) {
        length = value.length;
      } else {
        value = value.toString();
        length = Buffer.byteLength(value, encoding);
      }
      this.writeUInt16LE(length);
      if (value instanceof Buffer) {
        this.writeBuffer(value);
      } else {
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
    }
    writePLPBody(value, encoding) {
      if (encoding == null) {
        encoding = this.encoding;
      }
      let length;
      if (value instanceof Buffer) {
        length = value.length;
      } else {
        value = value.toString();
        length = Buffer.byteLength(value, encoding);
      }
      this.writeBuffer(UNKNOWN_PLP_LEN);
      if (length > 0) {
        this.writeUInt32LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      this.writeUInt32LE(0);
    }
    writeBuffer(value) {
      const length = value.length;
      this.makeRoomFor(length);
      value.copy(this.buffer, this.position);
      this.position += length;
    }
    writeMoney(value) {
      this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
      this.writeInt32LE(value & -1);
    }
  }
  var _default2 = WritableTrackingBuffer;
  exports$1.default = _default2;
  module2.exports = WritableTrackingBuffer;
})(writableTrackingBuffer, writableTrackingBuffer.exports);
var writableTrackingBufferExports = writableTrackingBuffer.exports;
var token = {};
Object.defineProperty(token, "__esModule", {
  value: true
});
token.Token = token.TYPE = token.SSPIToken = token.RowToken = token.RoutingEnvChangeToken = token.RollbackTransactionEnvChangeToken = token.ReturnValueToken = token.ReturnStatusToken = token.ResetConnectionEnvChangeToken = token.PacketSizeEnvChangeToken = token.OrderToken = token.NBCRowToken = token.LoginAckToken = token.LanguageEnvChangeToken = token.InfoMessageToken = token.FedAuthInfoToken = token.FeatureExtAckToken = token.ErrorMessageToken = token.DoneToken = token.DoneProcToken = token.DoneInProcToken = token.DatabaseMirroringPartnerEnvChangeToken = token.DatabaseEnvChangeToken = token.CommitTransactionEnvChangeToken = token.CollationChangeToken = token.ColMetadataToken = token.CharsetEnvChangeToken = token.BeginTransactionEnvChangeToken = void 0;
const TYPE$3 = {
  ALTMETADATA: 136,
  ALTROW: 211,
  COLMETADATA: 129,
  COLINFO: 165,
  DONE: 253,
  DONEPROC: 254,
  DONEINPROC: 255,
  ENVCHANGE: 227,
  ERROR: 170,
  FEATUREEXTACK: 174,
  FEDAUTHINFO: 238,
  INFO: 171,
  LOGINACK: 173,
  NBCROW: 210,
  OFFSET: 120,
  ORDER: 169,
  RETURNSTATUS: 121,
  RETURNVALUE: 172,
  ROW: 209,
  SSPI: 237,
  TABNAME: 164
};
token.TYPE = TYPE$3;
class Token {
  constructor(name2, handlerName) {
    this.name = void 0;
    this.handlerName = void 0;
    this.name = name2;
    this.handlerName = handlerName;
  }
}
token.Token = Token;
class ColMetadataToken extends Token {
  constructor(columns) {
    super("COLMETADATA", "onColMetadata");
    this.columns = void 0;
    this.columns = columns;
  }
}
token.ColMetadataToken = ColMetadataToken;
class DoneToken extends Token {
  constructor({
    more,
    sqlError,
    attention,
    serverError,
    rowCount,
    curCmd
  }) {
    super("DONE", "onDone");
    this.more = void 0;
    this.sqlError = void 0;
    this.attention = void 0;
    this.serverError = void 0;
    this.rowCount = void 0;
    this.curCmd = void 0;
    this.more = more;
    this.sqlError = sqlError;
    this.attention = attention;
    this.serverError = serverError;
    this.rowCount = rowCount;
    this.curCmd = curCmd;
  }
}
token.DoneToken = DoneToken;
class DoneInProcToken extends Token {
  constructor({
    more,
    sqlError,
    attention,
    serverError,
    rowCount,
    curCmd
  }) {
    super("DONEINPROC", "onDoneInProc");
    this.more = void 0;
    this.sqlError = void 0;
    this.attention = void 0;
    this.serverError = void 0;
    this.rowCount = void 0;
    this.curCmd = void 0;
    this.more = more;
    this.sqlError = sqlError;
    this.attention = attention;
    this.serverError = serverError;
    this.rowCount = rowCount;
    this.curCmd = curCmd;
  }
}
token.DoneInProcToken = DoneInProcToken;
class DoneProcToken extends Token {
  constructor({
    more,
    sqlError,
    attention,
    serverError,
    rowCount,
    curCmd
  }) {
    super("DONEPROC", "onDoneProc");
    this.more = void 0;
    this.sqlError = void 0;
    this.attention = void 0;
    this.serverError = void 0;
    this.rowCount = void 0;
    this.curCmd = void 0;
    this.more = more;
    this.sqlError = sqlError;
    this.attention = attention;
    this.serverError = serverError;
    this.rowCount = rowCount;
    this.curCmd = curCmd;
  }
}
token.DoneProcToken = DoneProcToken;
class DatabaseEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onDatabaseChange");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "DATABASE";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
class LanguageEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onLanguageChange");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "LANGUAGE";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.LanguageEnvChangeToken = LanguageEnvChangeToken;
class CharsetEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onCharsetChange");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "CHARSET";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.CharsetEnvChangeToken = CharsetEnvChangeToken;
class PacketSizeEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onPacketSizeChange");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "PACKET_SIZE";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
class BeginTransactionEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onBeginTransaction");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "BEGIN_TXN";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
class CommitTransactionEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onCommitTransaction");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "COMMIT_TXN";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
class RollbackTransactionEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onRollbackTransaction");
    this.type = void 0;
    this.oldValue = void 0;
    this.newValue = void 0;
    this.type = "ROLLBACK_TXN";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
class DatabaseMirroringPartnerEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onDatabaseMirroringPartner");
    this.type = void 0;
    this.oldValue = void 0;
    this.newValue = void 0;
    this.type = "DATABASE_MIRRORING_PARTNER";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
class ResetConnectionEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onResetConnection");
    this.type = void 0;
    this.oldValue = void 0;
    this.newValue = void 0;
    this.type = "RESET_CONNECTION";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
class CollationChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onSqlCollationChange");
    this.type = void 0;
    this.oldValue = void 0;
    this.newValue = void 0;
    this.type = "SQL_COLLATION";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.CollationChangeToken = CollationChangeToken;
class RoutingEnvChangeToken extends Token {
  constructor(newValue, oldValue) {
    super("ENVCHANGE", "onRoutingChange");
    this.type = void 0;
    this.newValue = void 0;
    this.oldValue = void 0;
    this.type = "ROUTING_CHANGE";
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
}
token.RoutingEnvChangeToken = RoutingEnvChangeToken;
class FeatureExtAckToken extends Token {
  /** Value of UTF8_SUPPORT acknowledgement.
   *
   * undefined when UTF8_SUPPORT not included in token. */
  constructor(fedAuth, utf8Support) {
    super("FEATUREEXTACK", "onFeatureExtAck");
    this.fedAuth = void 0;
    this.utf8Support = void 0;
    this.fedAuth = fedAuth;
    this.utf8Support = utf8Support;
  }
}
token.FeatureExtAckToken = FeatureExtAckToken;
class FedAuthInfoToken extends Token {
  constructor(spn, stsurl) {
    super("FEDAUTHINFO", "onFedAuthInfo");
    this.spn = void 0;
    this.stsurl = void 0;
    this.spn = spn;
    this.stsurl = stsurl;
  }
}
token.FedAuthInfoToken = FedAuthInfoToken;
class InfoMessageToken extends Token {
  constructor({
    number,
    state: state2,
    class: clazz,
    message: message2,
    serverName,
    procName,
    lineNumber
  }) {
    super("INFO", "onInfoMessage");
    this.number = void 0;
    this.state = void 0;
    this.class = void 0;
    this.message = void 0;
    this.serverName = void 0;
    this.procName = void 0;
    this.lineNumber = void 0;
    this.number = number;
    this.state = state2;
    this.class = clazz;
    this.message = message2;
    this.serverName = serverName;
    this.procName = procName;
    this.lineNumber = lineNumber;
  }
}
token.InfoMessageToken = InfoMessageToken;
class ErrorMessageToken extends Token {
  constructor({
    number,
    state: state2,
    class: clazz,
    message: message2,
    serverName,
    procName,
    lineNumber
  }) {
    super("ERROR", "onErrorMessage");
    this.number = void 0;
    this.state = void 0;
    this.class = void 0;
    this.message = void 0;
    this.serverName = void 0;
    this.procName = void 0;
    this.lineNumber = void 0;
    this.number = number;
    this.state = state2;
    this.class = clazz;
    this.message = message2;
    this.serverName = serverName;
    this.procName = procName;
    this.lineNumber = lineNumber;
  }
}
token.ErrorMessageToken = ErrorMessageToken;
class LoginAckToken extends Token {
  constructor({
    interface: interfaze,
    tdsVersion,
    progName,
    progVersion
  }) {
    super("LOGINACK", "onLoginAck");
    this.interface = void 0;
    this.tdsVersion = void 0;
    this.progName = void 0;
    this.progVersion = void 0;
    this.interface = interfaze;
    this.tdsVersion = tdsVersion;
    this.progName = progName;
    this.progVersion = progVersion;
  }
}
token.LoginAckToken = LoginAckToken;
class NBCRowToken extends Token {
  constructor(columns) {
    super("NBCROW", "onRow");
    this.columns = void 0;
    this.columns = columns;
  }
}
token.NBCRowToken = NBCRowToken;
class OrderToken extends Token {
  constructor(orderColumns) {
    super("ORDER", "onOrder");
    this.orderColumns = void 0;
    this.orderColumns = orderColumns;
  }
}
token.OrderToken = OrderToken;
class ReturnStatusToken extends Token {
  constructor(value) {
    super("RETURNSTATUS", "onReturnStatus");
    this.value = void 0;
    this.value = value;
  }
}
token.ReturnStatusToken = ReturnStatusToken;
class ReturnValueToken extends Token {
  constructor({
    paramOrdinal,
    paramName,
    metadata,
    value
  }) {
    super("RETURNVALUE", "onReturnValue");
    this.paramOrdinal = void 0;
    this.paramName = void 0;
    this.metadata = void 0;
    this.value = void 0;
    this.paramOrdinal = paramOrdinal;
    this.paramName = paramName;
    this.metadata = metadata;
    this.value = value;
  }
}
token.ReturnValueToken = ReturnValueToken;
class RowToken extends Token {
  constructor(columns) {
    super("ROW", "onRow");
    this.columns = void 0;
    this.columns = columns;
  }
}
token.RowToken = RowToken;
class SSPIToken extends Token {
  constructor(ntlmpacket, ntlmpacketBuffer) {
    super("SSPICHALLENGE", "onSSPI");
    this.ntlmpacket = void 0;
    this.ntlmpacketBuffer = void 0;
    this.ntlmpacket = ntlmpacket;
    this.ntlmpacketBuffer = ntlmpacketBuffer;
  }
}
token.SSPIToken = SSPIToken;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _events2 = require$$0$3;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  var _stream2 = require$$0$4;
  var _token2 = token;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const FLAGS = {
    nullable: 1 << 0,
    updateableReadWrite: 1 << 2,
    // introduced in TDS 7.2
    nullableUnknown: 1 << 15
    // introduced in TDS 7.2
  };
  const DONE_STATUS = {
    FINAL: 0
  };
  const rowTokenBuffer = Buffer.from([_token2.TYPE.ROW]);
  const textPointerAndTimestampBuffer = Buffer.from([
    // TextPointer length
    16,
    // TextPointer
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // Timestamp
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  const textPointerNullBuffer = Buffer.from([0]);
  class RowTransform extends _stream2.Transform {
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    constructor(bulkLoad2) {
      super({
        writableObjectMode: true
      });
      this.columnMetadataWritten = void 0;
      this.bulkLoad = void 0;
      this.mainOptions = void 0;
      this.columns = void 0;
      this.bulkLoad = bulkLoad2;
      this.mainOptions = bulkLoad2.options;
      this.columns = bulkLoad2.columns;
      this.columnMetadataWritten = false;
    }
    /**
     * @private
     */
    _transform(row, _encoding, callback) {
      if (!this.columnMetadataWritten) {
        this.push(this.bulkLoad.getColMetaData());
        this.columnMetadataWritten = true;
      }
      this.push(rowTokenBuffer);
      for (let i = 0; i < this.columns.length; i++) {
        const c = this.columns[i];
        let value = Array.isArray(row) ? row[i] : row[c.objName];
        if (!this.bulkLoad.firstRowWritten) {
          try {
            value = c.type.validate(value, c.collation);
          } catch (error2) {
            return callback(error2);
          }
        }
        const parameter = {
          length: c.length,
          scale: c.scale,
          precision: c.precision,
          value
        };
        if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
          if (value == null) {
            this.push(textPointerNullBuffer);
            continue;
          }
          this.push(textPointerAndTimestampBuffer);
        }
        this.push(c.type.generateParameterLength(parameter, this.mainOptions));
        for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
          this.push(chunk);
        }
      }
      process.nextTick(callback);
    }
    /**
     * @private
     */
    _flush(callback) {
      this.push(this.bulkLoad.createDoneToken());
      process.nextTick(callback);
    }
  }
  class BulkLoad extends _events2.EventEmitter {
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    constructor(table2, collation2, connectionOptions, {
      checkConstraints = false,
      fireTriggers = false,
      keepNulls = false,
      lockTable = false,
      order = {}
    }, callback) {
      if (typeof checkConstraints !== "boolean") {
        throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
      }
      if (typeof fireTriggers !== "boolean") {
        throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
      }
      if (typeof keepNulls !== "boolean") {
        throw new TypeError('The "options.keepNulls" property must be of type boolean.');
      }
      if (typeof lockTable !== "boolean") {
        throw new TypeError('The "options.lockTable" property must be of type boolean.');
      }
      if (typeof order !== "object" || order === null) {
        throw new TypeError('The "options.order" property must be of type object.');
      }
      for (const [column, direction] of Object.entries(order)) {
        if (direction !== "ASC" && direction !== "DESC") {
          throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
        }
      }
      super();
      this.error = void 0;
      this.canceled = void 0;
      this.executionStarted = void 0;
      this.streamingMode = void 0;
      this.table = void 0;
      this.timeout = void 0;
      this.options = void 0;
      this.callback = void 0;
      this.columns = void 0;
      this.columnsByName = void 0;
      this.firstRowWritten = void 0;
      this.rowToPacketTransform = void 0;
      this.bulkOptions = void 0;
      this.connection = void 0;
      this.rows = void 0;
      this.rst = void 0;
      this.rowCount = void 0;
      this.collation = void 0;
      this.error = void 0;
      this.canceled = false;
      this.executionStarted = false;
      this.collation = collation2;
      this.table = table2;
      this.options = connectionOptions;
      this.callback = callback;
      this.columns = [];
      this.columnsByName = {};
      this.firstRowWritten = false;
      this.streamingMode = false;
      this.rowToPacketTransform = new RowTransform(this);
      this.bulkOptions = {
        checkConstraints,
        fireTriggers,
        keepNulls,
        lockTable,
        order
      };
    }
    /**
     * Adds a column to the bulk load.
     *
     * The column definitions should match the table you are trying to insert into.
     * Attempting to call addColumn after the first row has been added will throw an exception.
     *
     * ```js
     * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
     * ```
     *
     * @param name The name of the column.
     * @param type One of the supported `data types`.
     * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
     * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
     * @param nullable Indicates whether the column accepts NULL values.
     * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
     * @param precision For Numeric, Decimal.
     * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
    */
    addColumn(name2, type2, {
      output = false,
      length,
      precision,
      scale,
      objName = name2,
      nullable = true
    }) {
      if (this.firstRowWritten) {
        throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
      }
      if (this.executionStarted) {
        throw new Error("Columns cannot be added to bulk insert after execution has started.");
      }
      const column = {
        type: type2,
        name: name2,
        value: null,
        output,
        length,
        precision,
        scale,
        objName,
        nullable,
        collation: this.collation
      };
      if ((type2.id & 48) === 32) {
        if (column.length == null && type2.resolveLength) {
          column.length = type2.resolveLength(column);
        }
      }
      if (type2.resolvePrecision && column.precision == null) {
        column.precision = type2.resolvePrecision(column);
      }
      if (type2.resolveScale && column.scale == null) {
        column.scale = type2.resolveScale(column);
      }
      this.columns.push(column);
      this.columnsByName[name2] = column;
    }
    /**
     * @private
     */
    getOptionsSql() {
      const addOptions = [];
      if (this.bulkOptions.checkConstraints) {
        addOptions.push("CHECK_CONSTRAINTS");
      }
      if (this.bulkOptions.fireTriggers) {
        addOptions.push("FIRE_TRIGGERS");
      }
      if (this.bulkOptions.keepNulls) {
        addOptions.push("KEEP_NULLS");
      }
      if (this.bulkOptions.lockTable) {
        addOptions.push("TABLOCK");
      }
      if (this.bulkOptions.order) {
        const orderColumns = [];
        for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
          orderColumns.push(`${column} ${direction}`);
        }
        if (orderColumns.length) {
          addOptions.push(`ORDER (${orderColumns.join(", ")})`);
        }
      }
      if (addOptions.length > 0) {
        return ` WITH (${addOptions.join(",")})`;
      } else {
        return "";
      }
    }
    /**
     * @private
     */
    getBulkInsertSql() {
      let sql2 = "insert bulk " + this.table + "(";
      for (let i = 0, len = this.columns.length; i < len; i++) {
        const c = this.columns[i];
        if (i !== 0) {
          sql2 += ", ";
        }
        sql2 += "[" + c.name + "] " + c.type.declaration(c);
      }
      sql2 += ")";
      sql2 += this.getOptionsSql();
      return sql2;
    }
    /**
     * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
     * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
     *
     * ```js
     * var sql = bulkLoad.getTableCreationSql();
     * ```
     *
     * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
     * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
     */
    getTableCreationSql() {
      let sql2 = "CREATE TABLE " + this.table + "(\n";
      for (let i = 0, len = this.columns.length; i < len; i++) {
        const c = this.columns[i];
        if (i !== 0) {
          sql2 += ",\n";
        }
        sql2 += "[" + c.name + "] " + c.type.declaration(c);
        if (c.nullable !== void 0) {
          sql2 += " " + (c.nullable ? "NULL" : "NOT NULL");
        }
      }
      sql2 += "\n)";
      return sql2;
    }
    /**
     * @private
     */
    getColMetaData() {
      const tBuf = new _writableTrackingBuffer2.default(100, null, true);
      tBuf.writeUInt8(_token2.TYPE.COLMETADATA);
      tBuf.writeUInt16LE(this.columns.length);
      for (let j = 0, len = this.columns.length; j < len; j++) {
        const c = this.columns[j];
        if (this.options.tdsVersion < "7_2") {
          tBuf.writeUInt16LE(0);
        } else {
          tBuf.writeUInt32LE(0);
        }
        let flags = FLAGS.updateableReadWrite;
        if (c.nullable) {
          flags |= FLAGS.nullable;
        } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
          flags |= FLAGS.nullableUnknown;
        }
        tBuf.writeUInt16LE(flags);
        tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
        if (c.type.hasTableName) {
          tBuf.writeUsVarchar(this.table, "ucs2");
        }
        tBuf.writeBVarchar(c.name, "ucs2");
      }
      return tBuf.data;
    }
    /**
     * Sets a timeout for this bulk load.
     *
     * ```js
     * bulkLoad.setTimeout(timeout);
     * ```
     *
     * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
     *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
     */
    setTimeout(timeout2) {
      this.timeout = timeout2;
    }
    /**
     * @private
     */
    createDoneToken() {
      const tBuf = new _writableTrackingBuffer2.default(this.options.tdsVersion < "7_2" ? 9 : 13);
      tBuf.writeUInt8(_token2.TYPE.DONE);
      const status = DONE_STATUS.FINAL;
      tBuf.writeUInt16LE(status);
      tBuf.writeUInt16LE(0);
      tBuf.writeUInt32LE(0);
      if (this.options.tdsVersion >= "7_2") {
        tBuf.writeUInt32LE(0);
      }
      return tBuf.data;
    }
    /**
     * @private
     */
    cancel() {
      if (this.canceled) {
        return;
      }
      this.canceled = true;
      this.emit("cancel");
    }
  }
  var _default2 = BulkLoad;
  exports$1.default = _default2;
  module2.exports = BulkLoad;
})(bulkLoad, bulkLoad.exports);
var bulkLoadExports = bulkLoad.exports;
var connection = { exports: {} };
/*! @azure/msal-common v13.3.1 2023-10-27 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      if (y = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
var Constants$1 = {
  LIBRARY_NAME: "MSAL.JS",
  SKU: "msal.js.common",
  // Prefix for all library cache entries
  CACHE_PREFIX: "msal",
  // default authority
  DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
  DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
  DEFAULT_COMMON_TENANT: "common",
  // ADFS String
  ADFS: "adfs",
  DSTS: "dstsv2",
  // Default AAD Instance Discovery Endpoint
  AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
  // CIAM URL
  CIAM_AUTH_URL: ".ciamlogin.com",
  AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
  // Resource delimiter - used for certain cache entries
  RESOURCE_DELIM: "|",
  // Placeholder for non-existent account ids/objects
  NO_ACCOUNT: "NO_ACCOUNT",
  // Claims
  CLAIMS: "claims",
  // Consumer UTID
  CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
  // Default scopes
  OPENID_SCOPE: "openid",
  PROFILE_SCOPE: "profile",
  OFFLINE_ACCESS_SCOPE: "offline_access",
  EMAIL_SCOPE: "email",
  // Default response type for authorization code flow
  CODE_RESPONSE_TYPE: "code",
  CODE_GRANT_TYPE: "authorization_code",
  RT_GRANT_TYPE: "refresh_token",
  FRAGMENT_RESPONSE_MODE: "fragment",
  S256_CODE_CHALLENGE_METHOD: "S256",
  URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
  AUTHORIZATION_PENDING: "authorization_pending",
  NOT_DEFINED: "not_defined",
  EMPTY_STRING: "",
  NOT_APPLICABLE: "N/A",
  FORWARD_SLASH: "/",
  IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
  IMDS_VERSION: "2020-06-01",
  IMDS_TIMEOUT: 2e3,
  AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
  REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
  REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
  KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
  TOKEN_RESPONSE_TYPE: "token",
  ID_TOKEN_RESPONSE_TYPE: "id_token",
  SHR_NONCE_VALIDITY: 240,
  INVALID_INSTANCE: "invalid_instance"
};
var OIDC_DEFAULT_SCOPES = [
  Constants$1.OPENID_SCOPE,
  Constants$1.PROFILE_SCOPE,
  Constants$1.OFFLINE_ACCESS_SCOPE
];
var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
  Constants$1.EMAIL_SCOPE
]);
var HeaderNames;
(function(HeaderNames2) {
  HeaderNames2["CONTENT_TYPE"] = "Content-Type";
  HeaderNames2["RETRY_AFTER"] = "Retry-After";
  HeaderNames2["CCS_HEADER"] = "X-AnchorMailbox";
  HeaderNames2["WWWAuthenticate"] = "WWW-Authenticate";
  HeaderNames2["AuthenticationInfo"] = "Authentication-Info";
  HeaderNames2["X_MS_REQUEST_ID"] = "x-ms-request-id";
  HeaderNames2["X_MS_HTTP_VERSION"] = "x-ms-httpver";
})(HeaderNames || (HeaderNames = {}));
var PersistentCacheKeys;
(function(PersistentCacheKeys2) {
  PersistentCacheKeys2["ID_TOKEN"] = "idtoken";
  PersistentCacheKeys2["CLIENT_INFO"] = "client.info";
  PersistentCacheKeys2["ADAL_ID_TOKEN"] = "adal.idtoken";
  PersistentCacheKeys2["ERROR"] = "error";
  PersistentCacheKeys2["ERROR_DESC"] = "error.description";
  PersistentCacheKeys2["ACTIVE_ACCOUNT"] = "active-account";
  PersistentCacheKeys2["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters";
})(PersistentCacheKeys || (PersistentCacheKeys = {}));
var AADAuthorityConstants;
(function(AADAuthorityConstants2) {
  AADAuthorityConstants2["COMMON"] = "common";
  AADAuthorityConstants2["ORGANIZATIONS"] = "organizations";
  AADAuthorityConstants2["CONSUMERS"] = "consumers";
})(AADAuthorityConstants || (AADAuthorityConstants = {}));
var AADServerParamKeys;
(function(AADServerParamKeys2) {
  AADServerParamKeys2["CLIENT_ID"] = "client_id";
  AADServerParamKeys2["REDIRECT_URI"] = "redirect_uri";
  AADServerParamKeys2["RESPONSE_TYPE"] = "response_type";
  AADServerParamKeys2["RESPONSE_MODE"] = "response_mode";
  AADServerParamKeys2["GRANT_TYPE"] = "grant_type";
  AADServerParamKeys2["CLAIMS"] = "claims";
  AADServerParamKeys2["SCOPE"] = "scope";
  AADServerParamKeys2["ERROR"] = "error";
  AADServerParamKeys2["ERROR_DESCRIPTION"] = "error_description";
  AADServerParamKeys2["ACCESS_TOKEN"] = "access_token";
  AADServerParamKeys2["ID_TOKEN"] = "id_token";
  AADServerParamKeys2["REFRESH_TOKEN"] = "refresh_token";
  AADServerParamKeys2["EXPIRES_IN"] = "expires_in";
  AADServerParamKeys2["STATE"] = "state";
  AADServerParamKeys2["NONCE"] = "nonce";
  AADServerParamKeys2["PROMPT"] = "prompt";
  AADServerParamKeys2["SESSION_STATE"] = "session_state";
  AADServerParamKeys2["CLIENT_INFO"] = "client_info";
  AADServerParamKeys2["CODE"] = "code";
  AADServerParamKeys2["CODE_CHALLENGE"] = "code_challenge";
  AADServerParamKeys2["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
  AADServerParamKeys2["CODE_VERIFIER"] = "code_verifier";
  AADServerParamKeys2["CLIENT_REQUEST_ID"] = "client-request-id";
  AADServerParamKeys2["X_CLIENT_SKU"] = "x-client-SKU";
  AADServerParamKeys2["X_CLIENT_VER"] = "x-client-VER";
  AADServerParamKeys2["X_CLIENT_OS"] = "x-client-OS";
  AADServerParamKeys2["X_CLIENT_CPU"] = "x-client-CPU";
  AADServerParamKeys2["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
  AADServerParamKeys2["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
  AADServerParamKeys2["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
  AADServerParamKeys2["X_APP_NAME"] = "x-app-name";
  AADServerParamKeys2["X_APP_VER"] = "x-app-ver";
  AADServerParamKeys2["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
  AADServerParamKeys2["ID_TOKEN_HINT"] = "id_token_hint";
  AADServerParamKeys2["DEVICE_CODE"] = "device_code";
  AADServerParamKeys2["CLIENT_SECRET"] = "client_secret";
  AADServerParamKeys2["CLIENT_ASSERTION"] = "client_assertion";
  AADServerParamKeys2["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
  AADServerParamKeys2["TOKEN_TYPE"] = "token_type";
  AADServerParamKeys2["REQ_CNF"] = "req_cnf";
  AADServerParamKeys2["OBO_ASSERTION"] = "assertion";
  AADServerParamKeys2["REQUESTED_TOKEN_USE"] = "requested_token_use";
  AADServerParamKeys2["ON_BEHALF_OF"] = "on_behalf_of";
  AADServerParamKeys2["FOCI"] = "foci";
  AADServerParamKeys2["CCS_HEADER"] = "X-AnchorMailbox";
  AADServerParamKeys2["RETURN_SPA_CODE"] = "return_spa_code";
  AADServerParamKeys2["NATIVE_BROKER"] = "nativebroker";
  AADServerParamKeys2["LOGOUT_HINT"] = "logout_hint";
})(AADServerParamKeys || (AADServerParamKeys = {}));
var ClaimsRequestKeys;
(function(ClaimsRequestKeys2) {
  ClaimsRequestKeys2["ACCESS_TOKEN"] = "access_token";
  ClaimsRequestKeys2["XMS_CC"] = "xms_cc";
})(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
var PromptValue = {
  LOGIN: "login",
  SELECT_ACCOUNT: "select_account",
  CONSENT: "consent",
  NONE: "none",
  CREATE: "create",
  NO_SESSION: "no_session"
};
var SSOTypes;
(function(SSOTypes2) {
  SSOTypes2["ACCOUNT"] = "account";
  SSOTypes2["SID"] = "sid";
  SSOTypes2["LOGIN_HINT"] = "login_hint";
  SSOTypes2["ID_TOKEN"] = "id_token";
  SSOTypes2["DOMAIN_HINT"] = "domain_hint";
  SSOTypes2["ORGANIZATIONS"] = "organizations";
  SSOTypes2["CONSUMERS"] = "consumers";
  SSOTypes2["ACCOUNT_ID"] = "accountIdentifier";
  SSOTypes2["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
})(SSOTypes || (SSOTypes = {}));
var CodeChallengeMethodValues = {
  PLAIN: "plain",
  S256: "S256"
};
var ResponseMode;
(function(ResponseMode2) {
  ResponseMode2["QUERY"] = "query";
  ResponseMode2["FRAGMENT"] = "fragment";
  ResponseMode2["FORM_POST"] = "form_post";
})(ResponseMode || (ResponseMode = {}));
var GrantType;
(function(GrantType2) {
  GrantType2["IMPLICIT_GRANT"] = "implicit";
  GrantType2["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
  GrantType2["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
  GrantType2["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
  GrantType2["REFRESH_TOKEN_GRANT"] = "refresh_token";
  GrantType2["DEVICE_CODE_GRANT"] = "device_code";
  GrantType2["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
})(GrantType || (GrantType = {}));
var CacheAccountType;
(function(CacheAccountType2) {
  CacheAccountType2["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
  CacheAccountType2["ADFS_ACCOUNT_TYPE"] = "ADFS";
  CacheAccountType2["MSAV1_ACCOUNT_TYPE"] = "MSA";
  CacheAccountType2["GENERIC_ACCOUNT_TYPE"] = "Generic";
})(CacheAccountType || (CacheAccountType = {}));
var Separators;
(function(Separators2) {
  Separators2["CACHE_KEY_SEPARATOR"] = "-";
  Separators2["CLIENT_INFO_SEPARATOR"] = ".";
})(Separators || (Separators = {}));
var CredentialType;
(function(CredentialType2) {
  CredentialType2["ID_TOKEN"] = "IdToken";
  CredentialType2["ACCESS_TOKEN"] = "AccessToken";
  CredentialType2["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
  CredentialType2["REFRESH_TOKEN"] = "RefreshToken";
})(CredentialType || (CredentialType = {}));
var CacheType;
(function(CacheType2) {
  CacheType2[CacheType2["ADFS"] = 1001] = "ADFS";
  CacheType2[CacheType2["MSA"] = 1002] = "MSA";
  CacheType2[CacheType2["MSSTS"] = 1003] = "MSSTS";
  CacheType2[CacheType2["GENERIC"] = 1004] = "GENERIC";
  CacheType2[CacheType2["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
  CacheType2[CacheType2["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
  CacheType2[CacheType2["ID_TOKEN"] = 2003] = "ID_TOKEN";
  CacheType2[CacheType2["APP_METADATA"] = 3001] = "APP_METADATA";
  CacheType2[CacheType2["UNDEFINED"] = 9999] = "UNDEFINED";
})(CacheType || (CacheType = {}));
var APP_METADATA = "appmetadata";
var CLIENT_INFO = "client_info";
var THE_FAMILY_ID = "1";
var AUTHORITY_METADATA_CONSTANTS = {
  CACHE_KEY: "authority-metadata",
  REFRESH_TIME_SECONDS: 3600 * 24
  // 24 Hours
};
var AuthorityMetadataSource;
(function(AuthorityMetadataSource2) {
  AuthorityMetadataSource2["CONFIG"] = "config";
  AuthorityMetadataSource2["CACHE"] = "cache";
  AuthorityMetadataSource2["NETWORK"] = "network";
  AuthorityMetadataSource2["HARDCODED_VALUES"] = "hardcoded_values";
})(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
var SERVER_TELEM_CONSTANTS = {
  SCHEMA_VERSION: 5,
  MAX_LAST_HEADER_BYTES: 330,
  MAX_CACHED_ERRORS: 50,
  CACHE_KEY: "server-telemetry",
  CATEGORY_SEPARATOR: "|",
  VALUE_SEPARATOR: ",",
  OVERFLOW_TRUE: "1",
  OVERFLOW_FALSE: "0",
  UNKNOWN_ERROR: "unknown_error"
};
var AuthenticationScheme;
(function(AuthenticationScheme2) {
  AuthenticationScheme2["BEARER"] = "Bearer";
  AuthenticationScheme2["POP"] = "pop";
  AuthenticationScheme2["SSH"] = "ssh-cert";
})(AuthenticationScheme || (AuthenticationScheme = {}));
var ThrottlingConstants = {
  // Default time to throttle RequestThumbprint in seconds
  DEFAULT_THROTTLE_TIME_SECONDS: 60,
  // Default maximum time to throttle in seconds, overrides what the server sends back
  DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
  // Prefix for storing throttling entries
  THROTTLING_PREFIX: "throttling",
  // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
  X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
};
var Errors = {
  INVALID_GRANT_ERROR: "invalid_grant",
  CLIENT_MISMATCH_ERROR: "client_mismatch"
};
var PasswordGrantConstants;
(function(PasswordGrantConstants2) {
  PasswordGrantConstants2["username"] = "username";
  PasswordGrantConstants2["password"] = "password";
})(PasswordGrantConstants || (PasswordGrantConstants = {}));
var ResponseCodes;
(function(ResponseCodes2) {
  ResponseCodes2[ResponseCodes2["httpSuccess"] = 200] = "httpSuccess";
  ResponseCodes2[ResponseCodes2["httpBadRequest"] = 400] = "httpBadRequest";
})(ResponseCodes || (ResponseCodes = {}));
var RegionDiscoverySources;
(function(RegionDiscoverySources2) {
  RegionDiscoverySources2["FAILED_AUTO_DETECTION"] = "1";
  RegionDiscoverySources2["INTERNAL_CACHE"] = "2";
  RegionDiscoverySources2["ENVIRONMENT_VARIABLE"] = "3";
  RegionDiscoverySources2["IMDS"] = "4";
})(RegionDiscoverySources || (RegionDiscoverySources = {}));
var RegionDiscoveryOutcomes;
(function(RegionDiscoveryOutcomes2) {
  RegionDiscoveryOutcomes2["CONFIGURED_MATCHES_DETECTED"] = "1";
  RegionDiscoveryOutcomes2["CONFIGURED_NO_AUTO_DETECTION"] = "2";
  RegionDiscoveryOutcomes2["CONFIGURED_NOT_DETECTED"] = "3";
  RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
  RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
})(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
var CacheOutcome;
(function(CacheOutcome2) {
  CacheOutcome2["NO_CACHE_HIT"] = "0";
  CacheOutcome2["FORCE_REFRESH"] = "1";
  CacheOutcome2["NO_CACHED_ACCESS_TOKEN"] = "2";
  CacheOutcome2["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
  CacheOutcome2["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
  CacheOutcome2["CLAIMS_REQUESTED_CACHE_SKIPPED"] = "5";
})(CacheOutcome || (CacheOutcome = {}));
var JsonTypes;
(function(JsonTypes2) {
  JsonTypes2["Jwt"] = "JWT";
  JsonTypes2["Jwk"] = "JWK";
  JsonTypes2["Pop"] = "pop";
})(JsonTypes || (JsonTypes = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthErrorMessage = {
  unexpectedError: {
    code: "unexpected_error",
    desc: "Unexpected error in authentication."
  },
  postRequestFailed: {
    code: "post_request_failed",
    desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
  }
};
var AuthError = (
  /** @class */
  function(_super) {
    __extends(AuthError2, _super);
    function AuthError2(errorCode, errorMessage, suberror) {
      var _this = this;
      var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
      _this = _super.call(this, errorString) || this;
      Object.setPrototypeOf(_this, AuthError2.prototype);
      _this.errorCode = errorCode || Constants$1.EMPTY_STRING;
      _this.errorMessage = errorMessage || Constants$1.EMPTY_STRING;
      _this.subError = suberror || Constants$1.EMPTY_STRING;
      _this.name = "AuthError";
      return _this;
    }
    AuthError2.prototype.setCorrelationId = function(correlationId) {
      this.correlationId = correlationId;
    };
    AuthError2.createUnexpectedError = function(errDesc) {
      return new AuthError2(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
    };
    AuthError2.createPostRequestFailed = function(errDesc) {
      return new AuthError2(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
    };
    return AuthError2;
  }(Error)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var DEFAULT_CRYPTO_IMPLEMENTATION = {
  createNewGuid: function() {
    var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  base64Decode: function() {
    var notImplErr = "Crypto interface - base64Decode() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  base64Encode: function() {
    var notImplErr = "Crypto interface - base64Encode() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  generatePkceCodes: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  getPublicKeyThumbprint: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  removeTokenBindingKey: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  clearKeystore: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - clearKeystore() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  signJwt: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - signJwt() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  hashString: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Crypto interface - hashString() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  }
};
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ClientAuthErrorMessage = {
  clientInfoDecodingError: {
    code: "client_info_decoding_error",
    desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
  },
  clientInfoEmptyError: {
    code: "client_info_empty_error",
    desc: "The client info was empty. Please review the trace to determine the root cause."
  },
  tokenParsingError: {
    code: "token_parsing_error",
    desc: "Token cannot be parsed. Please review stack trace to determine root cause."
  },
  nullOrEmptyToken: {
    code: "null_or_empty_token",
    desc: "The token is null or empty. Please review the trace to determine the root cause."
  },
  endpointResolutionError: {
    code: "endpoints_resolution_error",
    desc: "Error: could not resolve endpoints. Please check network and try again."
  },
  networkError: {
    code: "network_error",
    desc: "Network request failed. Please check network trace to determine root cause."
  },
  unableToGetOpenidConfigError: {
    code: "openid_config_error",
    desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
  },
  hashNotDeserialized: {
    code: "hash_not_deserialized",
    desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
  },
  invalidStateError: {
    code: "invalid_state",
    desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
  },
  stateMismatchError: {
    code: "state_mismatch",
    desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
  },
  stateNotFoundError: {
    code: "state_not_found",
    desc: "State not found"
  },
  nonceMismatchError: {
    code: "nonce_mismatch",
    desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
  },
  nonceNotFoundError: {
    code: "nonce_not_found",
    desc: "nonce not found"
  },
  authTimeNotFoundError: {
    code: "auth_time_not_found",
    desc: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information."
  },
  maxAgeTranspiredError: {
    code: "max_age_transpired",
    desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
  },
  multipleMatchingTokens: {
    code: "multiple_matching_tokens",
    desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
  },
  multipleMatchingAccounts: {
    code: "multiple_matching_accounts",
    desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
  },
  multipleMatchingAppMetadata: {
    code: "multiple_matching_appMetadata",
    desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
  },
  tokenRequestCannotBeMade: {
    code: "request_cannot_be_made",
    desc: "Token request cannot be made without authorization code or refresh token."
  },
  appendEmptyScopeError: {
    code: "cannot_append_empty_scope",
    desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
  },
  removeEmptyScopeError: {
    code: "cannot_remove_empty_scope",
    desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
  },
  appendScopeSetError: {
    code: "cannot_append_scopeset",
    desc: "Cannot append ScopeSet due to error."
  },
  emptyInputScopeSetError: {
    code: "empty_input_scopeset",
    desc: "Empty input ScopeSet cannot be processed."
  },
  DeviceCodePollingCancelled: {
    code: "device_code_polling_cancelled",
    desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
  },
  DeviceCodeExpired: {
    code: "device_code_expired",
    desc: "Device code is expired."
  },
  DeviceCodeUnknownError: {
    code: "device_code_unknown_error",
    desc: "Device code stopped polling for unknown reasons."
  },
  NoAccountInSilentRequest: {
    code: "no_account_in_silent_request",
    desc: "Please pass an account object, silent flow is not supported without account information"
  },
  invalidCacheRecord: {
    code: "invalid_cache_record",
    desc: "Cache record object was null or undefined."
  },
  invalidCacheEnvironment: {
    code: "invalid_cache_environment",
    desc: "Invalid environment when attempting to create cache entry"
  },
  noAccountFound: {
    code: "no_account_found",
    desc: "No account found in cache for given key."
  },
  CachePluginError: {
    code: "no cache plugin set on CacheManager",
    desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
  },
  noCryptoObj: {
    code: "no_crypto_object",
    desc: "No crypto object detected. This is required for the following operation: "
  },
  invalidCacheType: {
    code: "invalid_cache_type",
    desc: "Invalid cache type"
  },
  unexpectedAccountType: {
    code: "unexpected_account_type",
    desc: "Unexpected account type."
  },
  unexpectedCredentialType: {
    code: "unexpected_credential_type",
    desc: "Unexpected credential type."
  },
  invalidAssertion: {
    code: "invalid_assertion",
    desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
  },
  invalidClientCredential: {
    code: "invalid_client_credential",
    desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
  },
  tokenRefreshRequired: {
    code: "token_refresh_required",
    desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
  },
  userTimeoutReached: {
    code: "user_timeout_reached",
    desc: "User defined timeout for device code polling reached"
  },
  tokenClaimsRequired: {
    code: "token_claims_cnf_required_for_signedjwt",
    desc: "Cannot generate a POP jwt if the token_claims are not populated"
  },
  noAuthorizationCodeFromServer: {
    code: "authorization_code_missing_from_server_response",
    desc: "Server response does not contain an authorization code to proceed"
  },
  bindingKeyNotRemovedError: {
    code: "binding_key_not_removed",
    desc: "Could not remove the credential's binding key from storage."
  },
  logoutNotSupported: {
    code: "end_session_endpoint_not_supported",
    desc: "Provided authority does not support logout."
  },
  keyIdMissing: {
    code: "key_id_missing",
    desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
  },
  noNetworkConnectivity: {
    code: "no_network_connectivity",
    desc: "No network connectivity. Check your internet connection."
  },
  userCanceledError: {
    code: "user_canceled",
    desc: "User canceled the flow."
  }
};
var ClientAuthError = (
  /** @class */
  function(_super) {
    __extends(ClientAuthError2, _super);
    function ClientAuthError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "ClientAuthError";
      Object.setPrototypeOf(_this, ClientAuthError2.prototype);
      return _this;
    }
    ClientAuthError2.createClientInfoDecodingError = function(caughtError) {
      return new ClientAuthError2(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
    };
    ClientAuthError2.createClientInfoEmptyError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
    };
    ClientAuthError2.createTokenParsingError = function(caughtExtractionError) {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
    };
    ClientAuthError2.createTokenNullOrEmptyError = function(invalidRawTokenString) {
      return new ClientAuthError2(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
    };
    ClientAuthError2.createEndpointDiscoveryIncompleteError = function(errDetail) {
      return new ClientAuthError2(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
    };
    ClientAuthError2.createNetworkError = function(endpoint, errDetail) {
      return new ClientAuthError2(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
    };
    ClientAuthError2.createUnableToGetOpenidConfigError = function(errDetail) {
      return new ClientAuthError2(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
    };
    ClientAuthError2.createHashNotDeserializedError = function(hashParamObj) {
      return new ClientAuthError2(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
    };
    ClientAuthError2.createInvalidStateError = function(invalidState, errorString) {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
    };
    ClientAuthError2.createStateMismatchError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
    };
    ClientAuthError2.createStateNotFoundError = function(missingState) {
      return new ClientAuthError2(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
    };
    ClientAuthError2.createNonceMismatchError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
    };
    ClientAuthError2.createAuthTimeNotFoundError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);
    };
    ClientAuthError2.createMaxAgeTranspiredError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);
    };
    ClientAuthError2.createNonceNotFoundError = function(missingNonce) {
      return new ClientAuthError2(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
    };
    ClientAuthError2.createMultipleMatchingTokensInCacheError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
    };
    ClientAuthError2.createMultipleMatchingAccountsInCacheError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
    };
    ClientAuthError2.createMultipleMatchingAppMetadataInCacheError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
    };
    ClientAuthError2.createTokenRequestCannotBeMadeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
    };
    ClientAuthError2.createAppendEmptyScopeToSetError = function(givenScope) {
      return new ClientAuthError2(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    ClientAuthError2.createRemoveEmptyScopeFromSetError = function(givenScope) {
      return new ClientAuthError2(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    ClientAuthError2.createAppendScopeSetError = function(appendError) {
      return new ClientAuthError2(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
    };
    ClientAuthError2.createEmptyInputScopeSetError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
    };
    ClientAuthError2.createDeviceCodeCancelledError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
    };
    ClientAuthError2.createDeviceCodeExpiredError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
    };
    ClientAuthError2.createDeviceCodeUnknownError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
    };
    ClientAuthError2.createNoAccountInSilentRequestError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
    };
    ClientAuthError2.createNullOrUndefinedCacheRecord = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
    };
    ClientAuthError2.createInvalidCacheEnvironmentError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
    };
    ClientAuthError2.createNoAccountFoundError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
    };
    ClientAuthError2.createCachePluginError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
    };
    ClientAuthError2.createNoCryptoObjectError = function(operationName) {
      return new ClientAuthError2(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
    };
    ClientAuthError2.createInvalidCacheTypeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
    };
    ClientAuthError2.createUnexpectedAccountTypeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
    };
    ClientAuthError2.createUnexpectedCredentialTypeError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
    };
    ClientAuthError2.createInvalidAssertionError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
    };
    ClientAuthError2.createInvalidCredentialError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
    };
    ClientAuthError2.createRefreshRequiredError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
    };
    ClientAuthError2.createUserTimeoutReachedError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
    };
    ClientAuthError2.createTokenClaimsRequiredError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
    };
    ClientAuthError2.createNoAuthCodeInServerResponseError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
    };
    ClientAuthError2.createBindingKeyNotRemovedError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
    };
    ClientAuthError2.createLogoutNotSupportedError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
    };
    ClientAuthError2.createKeyIdMissingError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
    };
    ClientAuthError2.createNoNetworkConnectivityError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.noNetworkConnectivity.code, ClientAuthErrorMessage.noNetworkConnectivity.desc);
    };
    ClientAuthError2.createUserCanceledError = function() {
      return new ClientAuthError2(ClientAuthErrorMessage.userCanceledError.code, ClientAuthErrorMessage.userCanceledError.desc);
    };
    return ClientAuthError2;
  }(AuthError)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var StringUtils = (
  /** @class */
  function() {
    function StringUtils2() {
    }
    StringUtils2.decodeAuthToken = function(authToken) {
      if (StringUtils2.isEmpty(authToken)) {
        throw ClientAuthError.createTokenNullOrEmptyError(authToken);
      }
      var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
      var matches = tokenPartsRegex.exec(authToken);
      if (!matches || matches.length < 4) {
        throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
      }
      var crackedToken = {
        header: matches[1],
        JWSPayload: matches[2],
        JWSSig: matches[3]
      };
      return crackedToken;
    };
    StringUtils2.isEmpty = function(str) {
      return typeof str === "undefined" || !str || 0 === str.length;
    };
    StringUtils2.isEmptyObj = function(strObj) {
      if (strObj && !StringUtils2.isEmpty(strObj)) {
        try {
          var obj2 = JSON.parse(strObj);
          return Object.keys(obj2).length === 0;
        } catch (e) {
        }
      }
      return true;
    };
    StringUtils2.startsWith = function(str, search) {
      return str.indexOf(search) === 0;
    };
    StringUtils2.endsWith = function(str, search) {
      return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
    };
    StringUtils2.queryStringToObject = function(query) {
      var obj2 = {};
      var params = query.split("&");
      var decode2 = function(s) {
        return decodeURIComponent(s.replace(/\+/g, " "));
      };
      params.forEach(function(pair) {
        if (pair.trim()) {
          var _a2 = pair.split(/=(.+)/g, 2), key2 = _a2[0], value = _a2[1];
          if (key2 && value) {
            obj2[decode2(key2)] = decode2(value);
          }
        }
      });
      return obj2;
    };
    StringUtils2.trimArrayEntries = function(arr) {
      return arr.map(function(entry) {
        return entry.trim();
      });
    };
    StringUtils2.removeEmptyStringsFromArray = function(arr) {
      return arr.filter(function(entry) {
        return !StringUtils2.isEmpty(entry);
      });
    };
    StringUtils2.jsonParseHelper = function(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return null;
      }
    };
    StringUtils2.matchPattern = function(pattern, input) {
      var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
      return regex.test(input);
    };
    return StringUtils2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var LogLevel$1;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
  LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
})(LogLevel$1 || (LogLevel$1 = {}));
var Logger = (
  /** @class */
  function() {
    function Logger2(loggerOptions, packageName, packageVersion) {
      this.level = LogLevel$1.Info;
      var defaultLoggerCallback2 = function() {
        return;
      };
      var setLoggerOptions = loggerOptions || Logger2.createDefaultLoggerOptions();
      this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback2;
      this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
      this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel$1.Info;
      this.correlationId = setLoggerOptions.correlationId || Constants$1.EMPTY_STRING;
      this.packageName = packageName || Constants$1.EMPTY_STRING;
      this.packageVersion = packageVersion || Constants$1.EMPTY_STRING;
    }
    Logger2.createDefaultLoggerOptions = function() {
      return {
        loggerCallback: function() {
        },
        piiLoggingEnabled: false,
        logLevel: LogLevel$1.Info
      };
    };
    Logger2.prototype.clone = function(packageName, packageVersion, correlationId) {
      return new Logger2({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
    };
    Logger2.prototype.logMessage = function(logMessage, options) {
      if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
        return;
      }
      var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
      var logHeader;
      if (!StringUtils.isEmpty(options.correlationId)) {
        logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
      } else if (!StringUtils.isEmpty(this.correlationId)) {
        logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
      } else {
        logHeader = "[" + timestamp + "]";
      }
      var log2 = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + LogLevel$1[options.logLevel] + " - " + logMessage;
      this.executeCallback(options.logLevel, log2, options.containsPii || false);
    };
    Logger2.prototype.executeCallback = function(level, message2, containsPii) {
      if (this.localCallback) {
        this.localCallback(level, message2, containsPii);
      }
    };
    Logger2.prototype.error = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Error,
        containsPii: false,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.errorPii = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Error,
        containsPii: true,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.warning = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Warning,
        containsPii: false,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.warningPii = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Warning,
        containsPii: true,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.info = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Info,
        containsPii: false,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.infoPii = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Info,
        containsPii: true,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.verbose = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Verbose,
        containsPii: false,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.verbosePii = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Verbose,
        containsPii: true,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.trace = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Trace,
        containsPii: false,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.tracePii = function(message2, correlationId) {
      this.logMessage(message2, {
        logLevel: LogLevel$1.Trace,
        containsPii: true,
        correlationId: correlationId || Constants$1.EMPTY_STRING
      });
    };
    Logger2.prototype.isPiiLoggingEnabled = function() {
      return this.piiLoggingEnabled || false;
    };
    return Logger2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var name$2 = "@azure/msal-common";
var version$2 = "13.3.1";
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AzureCloudInstance;
(function(AzureCloudInstance2) {
  AzureCloudInstance2[AzureCloudInstance2["None"] = 0] = "None";
  AzureCloudInstance2["AzurePublic"] = "https://login.microsoftonline.com";
  AzureCloudInstance2["AzurePpe"] = "https://login.windows-ppe.net";
  AzureCloudInstance2["AzureChina"] = "https://login.chinacloudapi.cn";
  AzureCloudInstance2["AzureGermany"] = "https://login.microsoftonline.de";
  AzureCloudInstance2["AzureUsGovernment"] = "https://login.microsoftonline.us";
})(AzureCloudInstance || (AzureCloudInstance = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ClientConfigurationErrorMessage = {
  redirectUriNotSet: {
    code: "redirect_uri_empty",
    desc: "A redirect URI is required for all calls, and none has been set."
  },
  postLogoutUriNotSet: {
    code: "post_logout_uri_empty",
    desc: "A post logout redirect has not been set."
  },
  claimsRequestParsingError: {
    code: "claims_request_parsing_error",
    desc: "Could not parse the given claims request object."
  },
  authorityUriInsecure: {
    code: "authority_uri_insecure",
    desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
  },
  urlParseError: {
    code: "url_parse_error",
    desc: "URL could not be parsed into appropriate segments."
  },
  urlEmptyError: {
    code: "empty_url_error",
    desc: "URL was empty or null."
  },
  emptyScopesError: {
    code: "empty_input_scopes_error",
    desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
  },
  clientIdSingleScopeError: {
    code: "clientid_input_scopes_error",
    desc: "Client ID can only be provided as a single scope."
  },
  invalidPrompt: {
    code: "invalid_prompt_value",
    desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
  },
  invalidClaimsRequest: {
    code: "invalid_claims",
    desc: "Given claims parameter must be a stringified JSON object."
  },
  tokenRequestEmptyError: {
    code: "token_request_empty",
    desc: "Token request was empty and not found in cache."
  },
  logoutRequestEmptyError: {
    code: "logout_request_empty",
    desc: "The logout request was null or undefined."
  },
  invalidCodeChallengeMethod: {
    code: "invalid_code_challenge_method",
    desc: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".'
  },
  invalidCodeChallengeParams: {
    code: "pkce_params_missing",
    desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
  },
  invalidCloudDiscoveryMetadata: {
    code: "invalid_cloud_discovery_metadata",
    desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
  },
  invalidAuthorityMetadata: {
    code: "invalid_authority_metadata",
    desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
  },
  untrustedAuthority: {
    code: "untrusted_authority",
    desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
  },
  invalidAzureCloudInstance: {
    code: "invalid_azure_cloud_instance",
    desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
  },
  missingSshJwk: {
    code: "missing_ssh_jwk",
    desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
  },
  missingSshKid: {
    code: "missing_ssh_kid",
    desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
  },
  missingNonceAuthenticationHeader: {
    code: "missing_nonce_authentication_header",
    desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
  },
  invalidAuthenticationHeader: {
    code: "invalid_authentication_header",
    desc: "Invalid authentication header provided"
  },
  authorityMismatch: {
    code: "authority_mismatch",
    desc: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
  }
};
var ClientConfigurationError = (
  /** @class */
  function(_super) {
    __extends(ClientConfigurationError2, _super);
    function ClientConfigurationError2(errorCode, errorMessage) {
      var _this = _super.call(this, errorCode, errorMessage) || this;
      _this.name = "ClientConfigurationError";
      Object.setPrototypeOf(_this, ClientConfigurationError2.prototype);
      return _this;
    }
    ClientConfigurationError2.createRedirectUriEmptyError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
    };
    ClientConfigurationError2.createPostLogoutRedirectUriEmptyError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
    };
    ClientConfigurationError2.createClaimsRequestParsingError = function(claimsRequestParseError) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
    };
    ClientConfigurationError2.createInsecureAuthorityUriError = function(urlString) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
    };
    ClientConfigurationError2.createUrlParseError = function(urlParseError) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
    };
    ClientConfigurationError2.createUrlEmptyError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
    };
    ClientConfigurationError2.createEmptyScopesArrayError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
    };
    ClientConfigurationError2.createClientIdSingleScopeError = function(inputScopes) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
    };
    ClientConfigurationError2.createInvalidPromptError = function(promptValue) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
    };
    ClientConfigurationError2.createInvalidClaimsRequestError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
    };
    ClientConfigurationError2.createEmptyLogoutRequestError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
    };
    ClientConfigurationError2.createEmptyTokenRequestError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
    };
    ClientConfigurationError2.createInvalidCodeChallengeMethodError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
    };
    ClientConfigurationError2.createInvalidCodeChallengeParamsError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
    };
    ClientConfigurationError2.createInvalidCloudDiscoveryMetadataError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
    };
    ClientConfigurationError2.createInvalidAuthorityMetadataError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
    };
    ClientConfigurationError2.createUntrustedAuthorityError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
    };
    ClientConfigurationError2.createInvalidAzureCloudInstanceError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
    };
    ClientConfigurationError2.createMissingSshJwkError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
    };
    ClientConfigurationError2.createMissingSshKidError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
    };
    ClientConfigurationError2.createMissingNonceAuthenticationHeadersError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
    };
    ClientConfigurationError2.createInvalidAuthenticationHeaderError = function(invalidHeaderName, details) {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
    };
    ClientConfigurationError2.createAuthorityMismatchError = function() {
      return new ClientConfigurationError2(ClientConfigurationErrorMessage.authorityMismatch.code, ClientConfigurationErrorMessage.authorityMismatch.desc);
    };
    return ClientConfigurationError2;
  }(ClientAuthError)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ScopeSet = (
  /** @class */
  function() {
    function ScopeSet2(inputScopes) {
      var _this = this;
      var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
      var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
      this.validateInputScopes(filteredInput);
      this.scopes = /* @__PURE__ */ new Set();
      filteredInput.forEach(function(scope) {
        return _this.scopes.add(scope);
      });
    }
    ScopeSet2.fromString = function(inputScopeString) {
      var scopeString = inputScopeString || Constants$1.EMPTY_STRING;
      var inputScopes = scopeString.split(" ");
      return new ScopeSet2(inputScopes);
    };
    ScopeSet2.createSearchScopes = function(inputScopeString) {
      var scopeSet = new ScopeSet2(inputScopeString);
      if (!scopeSet.containsOnlyOIDCScopes()) {
        scopeSet.removeOIDCScopes();
      } else {
        scopeSet.removeScope(Constants$1.OFFLINE_ACCESS_SCOPE);
      }
      return scopeSet;
    };
    ScopeSet2.prototype.validateInputScopes = function(inputScopes) {
      if (!inputScopes || inputScopes.length < 1) {
        throw ClientConfigurationError.createEmptyScopesArrayError();
      }
    };
    ScopeSet2.prototype.containsScope = function(scope) {
      var lowerCaseScopes = this.printScopesLowerCase().split(" ");
      var lowerCaseScopesSet = new ScopeSet2(lowerCaseScopes);
      return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
    };
    ScopeSet2.prototype.containsScopeSet = function(scopeSet) {
      var _this = this;
      if (!scopeSet || scopeSet.scopes.size <= 0) {
        return false;
      }
      return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function(scope) {
        return _this.containsScope(scope);
      });
    };
    ScopeSet2.prototype.containsOnlyOIDCScopes = function() {
      var _this = this;
      var defaultScopeCount = 0;
      OIDC_SCOPES.forEach(function(defaultScope) {
        if (_this.containsScope(defaultScope)) {
          defaultScopeCount += 1;
        }
      });
      return this.scopes.size === defaultScopeCount;
    };
    ScopeSet2.prototype.appendScope = function(newScope) {
      if (!StringUtils.isEmpty(newScope)) {
        this.scopes.add(newScope.trim());
      }
    };
    ScopeSet2.prototype.appendScopes = function(newScopes) {
      var _this = this;
      try {
        newScopes.forEach(function(newScope) {
          return _this.appendScope(newScope);
        });
      } catch (e) {
        throw ClientAuthError.createAppendScopeSetError(e);
      }
    };
    ScopeSet2.prototype.removeScope = function(scope) {
      if (StringUtils.isEmpty(scope)) {
        throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
      }
      this.scopes.delete(scope.trim());
    };
    ScopeSet2.prototype.removeOIDCScopes = function() {
      var _this = this;
      OIDC_SCOPES.forEach(function(defaultScope) {
        _this.scopes.delete(defaultScope);
      });
    };
    ScopeSet2.prototype.unionScopeSets = function(otherScopes) {
      if (!otherScopes) {
        throw ClientAuthError.createEmptyInputScopeSetError();
      }
      var unionScopes = /* @__PURE__ */ new Set();
      otherScopes.scopes.forEach(function(scope) {
        return unionScopes.add(scope.toLowerCase());
      });
      this.scopes.forEach(function(scope) {
        return unionScopes.add(scope.toLowerCase());
      });
      return unionScopes;
    };
    ScopeSet2.prototype.intersectingScopeSets = function(otherScopes) {
      if (!otherScopes) {
        throw ClientAuthError.createEmptyInputScopeSetError();
      }
      if (!otherScopes.containsOnlyOIDCScopes()) {
        otherScopes.removeOIDCScopes();
      }
      var unionScopes = this.unionScopeSets(otherScopes);
      var sizeOtherScopes = otherScopes.getScopeCount();
      var sizeThisScopes = this.getScopeCount();
      var sizeUnionScopes = unionScopes.size;
      return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
    };
    ScopeSet2.prototype.getScopeCount = function() {
      return this.scopes.size;
    };
    ScopeSet2.prototype.asArray = function() {
      var array = [];
      this.scopes.forEach(function(val) {
        return array.push(val);
      });
      return array;
    };
    ScopeSet2.prototype.printScopes = function() {
      if (this.scopes) {
        var scopeArr = this.asArray();
        return scopeArr.join(" ");
      }
      return Constants$1.EMPTY_STRING;
    };
    ScopeSet2.prototype.printScopesLowerCase = function() {
      return this.printScopes().toLowerCase();
    };
    return ScopeSet2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
function buildClientInfo(rawClientInfo, crypto2) {
  if (StringUtils.isEmpty(rawClientInfo)) {
    throw ClientAuthError.createClientInfoEmptyError();
  }
  try {
    var decodedClientInfo = crypto2.base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw ClientAuthError.createClientInfoDecodingError(e.message);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (StringUtils.isEmpty(homeAccountId)) {
    throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
  }
  var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants$1.EMPTY_STRING : clientInfoParts[1]
  };
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["Default"] = 0] = "Default";
  AuthorityType2[AuthorityType2["Adfs"] = 1] = "Adfs";
  AuthorityType2[AuthorityType2["Dsts"] = 2] = "Dsts";
  AuthorityType2[AuthorityType2["Ciam"] = 3] = "Ciam";
})(AuthorityType || (AuthorityType = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AccountEntity = (
  /** @class */
  function() {
    function AccountEntity2() {
    }
    AccountEntity2.prototype.generateAccountId = function() {
      var accountId = [this.homeAccountId, this.environment];
      return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    AccountEntity2.prototype.generateAccountKey = function() {
      return AccountEntity2.generateAccountCacheKey({
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId
      });
    };
    AccountEntity2.prototype.generateType = function() {
      switch (this.authorityType) {
        case CacheAccountType.ADFS_ACCOUNT_TYPE:
          return CacheType.ADFS;
        case CacheAccountType.MSAV1_ACCOUNT_TYPE:
          return CacheType.MSA;
        case CacheAccountType.MSSTS_ACCOUNT_TYPE:
          return CacheType.MSSTS;
        case CacheAccountType.GENERIC_ACCOUNT_TYPE:
          return CacheType.GENERIC;
        default: {
          throw ClientAuthError.createUnexpectedAccountTypeError();
        }
      }
    };
    AccountEntity2.prototype.getAccountInfo = function() {
      return {
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId,
        name: this.name,
        idTokenClaims: this.idTokenClaims,
        nativeAccountId: this.nativeAccountId
      };
    };
    AccountEntity2.generateAccountCacheKey = function(accountInterface) {
      var accountKey = [
        accountInterface.homeAccountId,
        accountInterface.environment || Constants$1.EMPTY_STRING,
        accountInterface.tenantId || Constants$1.EMPTY_STRING
      ];
      return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    AccountEntity2.createAccount = function(clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
      var _a2, _b2, _c, _d, _e, _f;
      var account = new AccountEntity2();
      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
      account.clientInfo = clientInfo;
      account.homeAccountId = homeAccountId;
      account.nativeAccountId = nativeAccountId;
      var env = environment || authority && authority.getPreferredCache();
      if (!env) {
        throw ClientAuthError.createInvalidCacheEnvironmentError();
      }
      account.environment = env;
      account.realm = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.tid) || Constants$1.EMPTY_STRING;
      if (idToken) {
        account.idTokenClaims = idToken.claims;
        account.localAccountId = ((_b2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b2 === void 0 ? void 0 : _b2.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants$1.EMPTY_STRING;
        var preferredUsername = (_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username;
        var email = ((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : null;
        account.username = preferredUsername || email || Constants$1.EMPTY_STRING;
        account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
      }
      account.cloudGraphHostName = cloudGraphHostName;
      account.msGraphHost = msGraphHost;
      return account;
    };
    AccountEntity2.createGenericAccount = function(homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
      var _a2, _b2, _c, _d;
      var account = new AccountEntity2();
      account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;
      account.homeAccountId = homeAccountId;
      account.realm = Constants$1.EMPTY_STRING;
      var env = environment || authority && authority.getPreferredCache();
      if (!env) {
        throw ClientAuthError.createInvalidCacheEnvironmentError();
      }
      if (idToken) {
        account.localAccountId = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.oid) || ((_b2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b2 === void 0 ? void 0 : _b2.sub) || Constants$1.EMPTY_STRING;
        account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants$1.EMPTY_STRING;
        account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants$1.EMPTY_STRING;
        account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
      }
      account.environment = env;
      account.cloudGraphHostName = cloudGraphHostName;
      account.msGraphHost = msGraphHost;
      return account;
    };
    AccountEntity2.generateHomeAccountId = function(serverClientInfo, authType, logger2, cryptoObj, idToken) {
      var _a2;
      var accountId = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.sub) ? idToken.claims.sub : Constants$1.EMPTY_STRING;
      if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {
        return accountId;
      }
      if (serverClientInfo) {
        try {
          var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
          if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
            return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
          }
        } catch (e) {
        }
      }
      logger2.verbose("No client info in response");
      return accountId;
    };
    AccountEntity2.isAccountEntity = function(entity) {
      if (!entity) {
        return false;
      }
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
    };
    AccountEntity2.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
      if (!accountA || !accountB) {
        return false;
      }
      var claimsMatch = true;
      if (compareClaims) {
        var accountAClaims = accountA.idTokenClaims || {};
        var accountBClaims = accountB.idTokenClaims || {};
        claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
      }
      return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
    };
    return AccountEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthToken = (
  /** @class */
  function() {
    function AuthToken2(rawToken, crypto2) {
      if (StringUtils.isEmpty(rawToken)) {
        throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
      }
      this.rawToken = rawToken;
      this.claims = AuthToken2.extractTokenClaims(rawToken, crypto2);
    }
    AuthToken2.extractTokenClaims = function(encodedToken, crypto2) {
      var decodedToken = StringUtils.decodeAuthToken(encodedToken);
      try {
        var base64TokenPayload = decodedToken.JWSPayload;
        var base64Decoded = crypto2.base64Decode(base64TokenPayload);
        return JSON.parse(base64Decoded);
      } catch (err) {
        throw ClientAuthError.createTokenParsingError(err);
      }
    };
    AuthToken2.checkMaxAge = function(authTime, maxAge) {
      var fiveMinuteSkew = 3e5;
      if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
        throw ClientAuthError.createMaxAgeTranspiredError();
      }
    };
    return AuthToken2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var CacheManager = (
  /** @class */
  function() {
    function CacheManager2(clientId, cryptoImpl, logger2) {
      this.clientId = clientId;
      this.cryptoImpl = cryptoImpl;
      this.commonLogger = logger2.clone(name$2, version$2);
    }
    CacheManager2.prototype.getAllAccounts = function() {
      var _this = this;
      var allAccountKeys = this.getAccountKeys();
      if (allAccountKeys.length < 1) {
        return [];
      }
      var accountEntities = allAccountKeys.reduce(function(accounts, key2) {
        var entity = _this.getAccount(key2);
        if (!entity) {
          return accounts;
        }
        accounts.push(entity);
        return accounts;
      }, []);
      if (accountEntities.length < 1) {
        return [];
      } else {
        var allAccounts = accountEntities.map(function(accountEntity) {
          return _this.getAccountInfoFromEntity(accountEntity);
        });
        return allAccounts;
      }
    };
    CacheManager2.prototype.getAccountInfoFilteredBy = function(accountFilter) {
      var allAccounts = this.getAccountsFilteredBy(accountFilter);
      if (allAccounts.length > 0) {
        return this.getAccountInfoFromEntity(allAccounts[0]);
      } else {
        return null;
      }
    };
    CacheManager2.prototype.getAccountInfoFromEntity = function(accountEntity) {
      var accountInfo = accountEntity.getAccountInfo();
      var idToken = this.getIdToken(accountInfo);
      if (idToken) {
        accountInfo.idToken = idToken.secret;
        accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;
      }
      return accountInfo;
    };
    CacheManager2.prototype.saveCacheRecord = function(cacheRecord) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!cacheRecord) {
                throw ClientAuthError.createNullOrUndefinedCacheRecord();
              }
              if (!!cacheRecord.account) {
                this.setAccount(cacheRecord.account);
              }
              if (!!cacheRecord.idToken) {
                this.setIdTokenCredential(cacheRecord.idToken);
              }
              if (!!!cacheRecord.accessToken) return [3, 2];
              return [4, this.saveAccessToken(cacheRecord.accessToken)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              if (!!cacheRecord.refreshToken) {
                this.setRefreshTokenCredential(cacheRecord.refreshToken);
              }
              if (!!cacheRecord.appMetadata) {
                this.setAppMetadata(cacheRecord.appMetadata);
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CacheManager2.prototype.saveAccessToken = function(credential) {
      return __awaiter(this, void 0, void 0, function() {
        var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              accessTokenFilter = {
                clientId: credential.clientId,
                credentialType: credential.credentialType,
                environment: credential.environment,
                homeAccountId: credential.homeAccountId,
                realm: credential.realm,
                tokenType: credential.tokenType,
                requestedClaimsHash: credential.requestedClaimsHash
              };
              tokenKeys = this.getTokenKeys();
              currentScopes = ScopeSet.fromString(credential.target);
              removedAccessTokens = [];
              tokenKeys.accessToken.forEach(function(key2) {
                if (!_this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, false)) {
                  return;
                }
                var tokenEntity = _this.getAccessTokenCredential(key2);
                if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
                  var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
                  if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                    removedAccessTokens.push(_this.removeAccessToken(key2));
                  }
                }
              });
              return [4, Promise.all(removedAccessTokens)];
            case 1:
              _a2.sent();
              this.setAccessTokenCredential(credential);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CacheManager2.prototype.getAccountsFilteredBy = function(accountFilter) {
      var _this = this;
      var allAccountKeys = this.getAccountKeys();
      var matchingAccounts = [];
      allAccountKeys.forEach(function(cacheKey) {
        if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {
          return;
        }
        var entity = _this.getAccount(cacheKey);
        if (!entity) {
          return;
        }
        if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
          return;
        }
        if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {
          return;
        }
        if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {
          return;
        }
        if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {
          return;
        }
        if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {
          return;
        }
        if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
          return;
        }
        matchingAccounts.push(entity);
      });
      return matchingAccounts;
    };
    CacheManager2.prototype.isAccountKey = function(key2, homeAccountId, tenantId) {
      if (key2.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
        return false;
      }
      if (homeAccountId && !key2.toLowerCase().includes(homeAccountId.toLowerCase())) {
        return false;
      }
      if (tenantId && !key2.toLowerCase().includes(tenantId.toLowerCase())) {
        return false;
      }
      return true;
    };
    CacheManager2.prototype.isCredentialKey = function(key2) {
      if (key2.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
        return false;
      }
      var lowerCaseKey = key2.toLowerCase();
      if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
        return false;
      }
      if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
        var clientIdValidation = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;
        var familyIdValidation = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;
        if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
          return false;
        }
      } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    };
    CacheManager2.prototype.credentialMatchesFilter = function(entity, filter) {
      if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
        return false;
      }
      if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
        return false;
      }
      if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
        return false;
      }
      if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
        return false;
      }
      if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
        return false;
      }
      if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
        return false;
      }
      if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
        return false;
      }
      if (!!filter.target && !this.matchTarget(entity, filter.target)) {
        return false;
      }
      if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
        if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
          return false;
        }
      }
      if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
        if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
          return false;
        }
        if (filter.tokenType === AuthenticationScheme.SSH) {
          if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
            return false;
          }
        }
      }
      return true;
    };
    CacheManager2.prototype.getAppMetadataFilteredBy = function(filter) {
      return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
    };
    CacheManager2.prototype.getAppMetadataFilteredByInternal = function(environment, clientId) {
      var _this = this;
      var allCacheKeys = this.getKeys();
      var matchingAppMetadata = {};
      allCacheKeys.forEach(function(cacheKey) {
        if (!_this.isAppMetadata(cacheKey)) {
          return;
        }
        var entity = _this.getAppMetadata(cacheKey);
        if (!entity) {
          return;
        }
        if (!!environment && !_this.matchEnvironment(entity, environment)) {
          return;
        }
        if (!!clientId && !_this.matchClientId(entity, clientId)) {
          return;
        }
        matchingAppMetadata[cacheKey] = entity;
      });
      return matchingAppMetadata;
    };
    CacheManager2.prototype.getAuthorityMetadataByAlias = function(host) {
      var _this = this;
      var allCacheKeys = this.getAuthorityMetadataKeys();
      var matchedEntity = null;
      allCacheKeys.forEach(function(cacheKey) {
        if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
          return;
        }
        var entity = _this.getAuthorityMetadata(cacheKey);
        if (!entity) {
          return;
        }
        if (entity.aliases.indexOf(host) === -1) {
          return;
        }
        matchedEntity = entity;
      });
      return matchedEntity;
    };
    CacheManager2.prototype.removeAllAccounts = function() {
      return __awaiter(this, void 0, void 0, function() {
        var allAccountKeys, removedAccounts;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              allAccountKeys = this.getAccountKeys();
              removedAccounts = [];
              allAccountKeys.forEach(function(cacheKey) {
                removedAccounts.push(_this.removeAccount(cacheKey));
              });
              return [4, Promise.all(removedAccounts)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CacheManager2.prototype.removeAccount = function(accountKey) {
      return __awaiter(this, void 0, void 0, function() {
        var account;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              account = this.getAccount(accountKey);
              if (!account) {
                throw ClientAuthError.createNoAccountFoundError();
              }
              return [4, this.removeAccountContext(account)];
            case 1:
              _a2.sent();
              this.removeItem(accountKey);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CacheManager2.prototype.removeAccountContext = function(account) {
      return __awaiter(this, void 0, void 0, function() {
        var allTokenKeys, accountId, removedCredentials;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              allTokenKeys = this.getTokenKeys();
              accountId = account.generateAccountId();
              removedCredentials = [];
              allTokenKeys.idToken.forEach(function(key2) {
                if (key2.indexOf(accountId) === 0) {
                  _this.removeIdToken(key2);
                }
              });
              allTokenKeys.accessToken.forEach(function(key2) {
                if (key2.indexOf(accountId) === 0) {
                  removedCredentials.push(_this.removeAccessToken(key2));
                }
              });
              allTokenKeys.refreshToken.forEach(function(key2) {
                if (key2.indexOf(accountId) === 0) {
                  _this.removeRefreshToken(key2);
                }
              });
              return [4, Promise.all(removedCredentials)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CacheManager2.prototype.removeAccessToken = function(key2) {
      return __awaiter(this, void 0, void 0, function() {
        var credential, accessTokenWithAuthSchemeEntity, kid;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              credential = this.getAccessTokenCredential(key2);
              if (!credential) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3, 4];
              if (!(credential.tokenType === AuthenticationScheme.POP)) return [3, 4];
              accessTokenWithAuthSchemeEntity = credential;
              kid = accessTokenWithAuthSchemeEntity.keyId;
              if (!kid) return [3, 4];
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, this.cryptoImpl.removeTokenBindingKey(kid)];
            case 2:
              _a2.sent();
              return [3, 4];
            case 3:
              _a2.sent();
              throw ClientAuthError.createBindingKeyNotRemovedError();
            case 4:
              return [2, this.removeItem(key2)];
          }
        });
      });
    };
    CacheManager2.prototype.removeAppMetadata = function() {
      var _this = this;
      var allCacheKeys = this.getKeys();
      allCacheKeys.forEach(function(cacheKey) {
        if (_this.isAppMetadata(cacheKey)) {
          _this.removeItem(cacheKey);
        }
      });
      return true;
    };
    CacheManager2.prototype.readCacheRecord = function(account, request2, environment) {
      var tokenKeys = this.getTokenKeys();
      var cachedAccount = this.readAccountFromCache(account);
      var cachedIdToken = this.getIdToken(account, tokenKeys);
      var cachedAccessToken = this.getAccessToken(account, request2, tokenKeys);
      var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);
      var cachedAppMetadata = this.readAppMetadataFromCache(environment);
      if (cachedAccount && cachedIdToken) {
        cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
      }
      return {
        account: cachedAccount,
        idToken: cachedIdToken,
        accessToken: cachedAccessToken,
        refreshToken: cachedRefreshToken,
        appMetadata: cachedAppMetadata
      };
    };
    CacheManager2.prototype.readAccountFromCache = function(account) {
      var accountKey = AccountEntity.generateAccountCacheKey(account);
      return this.getAccount(accountKey);
    };
    CacheManager2.prototype.getIdToken = function(account, tokenKeys) {
      var _this = this;
      this.commonLogger.trace("CacheManager - getIdToken called");
      var idTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType: CredentialType.ID_TOKEN,
        clientId: this.clientId,
        realm: account.tenantId
      };
      var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);
      var numIdTokens = idTokens.length;
      if (numIdTokens < 1) {
        this.commonLogger.info("CacheManager:getIdToken - No token found");
        return null;
      } else if (numIdTokens > 1) {
        this.commonLogger.info("CacheManager:getIdToken - Multiple id tokens found, clearing them");
        idTokens.forEach(function(idToken) {
          _this.removeIdToken(idToken.generateCredentialKey());
        });
        return null;
      }
      this.commonLogger.info("CacheManager:getIdToken - Returning id token");
      return idTokens[0];
    };
    CacheManager2.prototype.getIdTokensByFilter = function(filter, tokenKeys) {
      var _this = this;
      var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
      var idTokens = [];
      idTokenKeys.forEach(function(key2) {
        if (!_this.idTokenKeyMatchesFilter(key2, __assign({ clientId: _this.clientId }, filter))) {
          return;
        }
        var idToken = _this.getIdTokenCredential(key2);
        if (idToken && _this.credentialMatchesFilter(idToken, filter)) {
          idTokens.push(idToken);
        }
      });
      return idTokens;
    };
    CacheManager2.prototype.idTokenKeyMatchesFilter = function(inputKey, filter) {
      var key2 = inputKey.toLowerCase();
      if (filter.clientId && key2.indexOf(filter.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter.homeAccountId && key2.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    };
    CacheManager2.prototype.removeIdToken = function(key2) {
      this.removeItem(key2);
    };
    CacheManager2.prototype.removeRefreshToken = function(key2) {
      this.removeItem(key2);
    };
    CacheManager2.prototype.getAccessToken = function(account, request2, tokenKeys) {
      var _this = this;
      this.commonLogger.trace("CacheManager - getAccessToken called");
      var scopes = ScopeSet.createSearchScopes(request2.scopes);
      var authScheme = request2.authenticationScheme || AuthenticationScheme.BEARER;
      var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
      var accessTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType,
        clientId: this.clientId,
        realm: account.tenantId,
        target: scopes,
        tokenType: authScheme,
        keyId: request2.sshKid,
        requestedClaimsHash: request2.requestedClaimsHash
      };
      var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
      var accessTokens = [];
      accessTokenKeys.forEach(function(key2) {
        if (_this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, true)) {
          var accessToken = _this.getAccessTokenCredential(key2);
          if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
            accessTokens.push(accessToken);
          }
        }
      });
      var numAccessTokens = accessTokens.length;
      if (numAccessTokens < 1) {
        this.commonLogger.info("CacheManager:getAccessToken - No token found");
        return null;
      } else if (numAccessTokens > 1) {
        this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");
        accessTokens.forEach(function(accessToken) {
          _this.removeAccessToken(accessToken.generateCredentialKey());
        });
        return null;
      }
      this.commonLogger.info("CacheManager:getAccessToken - Returning access token");
      return accessTokens[0];
    };
    CacheManager2.prototype.accessTokenKeyMatchesFilter = function(inputKey, filter, keyMustContainAllScopes) {
      var key2 = inputKey.toLowerCase();
      if (filter.clientId && key2.indexOf(filter.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter.homeAccountId && key2.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      if (filter.realm && key2.indexOf(filter.realm.toLowerCase()) === -1) {
        return false;
      }
      if (filter.requestedClaimsHash && key2.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
        return false;
      }
      if (filter.target) {
        var scopes = filter.target.asArray();
        for (var i = 0; i < scopes.length; i++) {
          if (keyMustContainAllScopes && !key2.includes(scopes[i].toLowerCase())) {
            return false;
          } else if (!keyMustContainAllScopes && key2.includes(scopes[i].toLowerCase())) {
            return true;
          }
        }
      }
      return true;
    };
    CacheManager2.prototype.getAccessTokensByFilter = function(filter) {
      var _this = this;
      var tokenKeys = this.getTokenKeys();
      var accessTokens = [];
      tokenKeys.accessToken.forEach(function(key2) {
        if (!_this.accessTokenKeyMatchesFilter(key2, filter, true)) {
          return;
        }
        var accessToken = _this.getAccessTokenCredential(key2);
        if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {
          accessTokens.push(accessToken);
        }
      });
      return accessTokens;
    };
    CacheManager2.prototype.getRefreshToken = function(account, familyRT, tokenKeys) {
      var _this = this;
      this.commonLogger.trace("CacheManager - getRefreshToken called");
      var id = familyRT ? THE_FAMILY_ID : void 0;
      var refreshTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType: CredentialType.REFRESH_TOKEN,
        clientId: this.clientId,
        familyId: id
      };
      var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
      var refreshTokens = [];
      refreshTokenKeys.forEach(function(key2) {
        if (_this.refreshTokenKeyMatchesFilter(key2, refreshTokenFilter)) {
          var refreshToken = _this.getRefreshTokenCredential(key2);
          if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
            refreshTokens.push(refreshToken);
          }
        }
      });
      var numRefreshTokens = refreshTokens.length;
      if (numRefreshTokens < 1) {
        this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
        return null;
      }
      this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
      return refreshTokens[0];
    };
    CacheManager2.prototype.refreshTokenKeyMatchesFilter = function(inputKey, filter) {
      var key2 = inputKey.toLowerCase();
      if (filter.familyId && key2.indexOf(filter.familyId.toLowerCase()) === -1) {
        return false;
      }
      if (!filter.familyId && filter.clientId && key2.indexOf(filter.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter.homeAccountId && key2.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    };
    CacheManager2.prototype.readAppMetadataFromCache = function(environment) {
      var appMetadataFilter = {
        environment,
        clientId: this.clientId
      };
      var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
      var appMetadataEntries = Object.keys(appMetadata).map(function(key2) {
        return appMetadata[key2];
      });
      var numAppMetadata = appMetadataEntries.length;
      if (numAppMetadata < 1) {
        return null;
      } else if (numAppMetadata > 1) {
        throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
      }
      return appMetadataEntries[0];
    };
    CacheManager2.prototype.isAppMetadataFOCI = function(environment) {
      var appMetadata = this.readAppMetadataFromCache(environment);
      return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
    };
    CacheManager2.prototype.matchHomeAccountId = function(entity, homeAccountId) {
      return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
    };
    CacheManager2.prototype.matchLocalAccountId = function(entity, localAccountId) {
      return !!(typeof entity.localAccountId === "string" && localAccountId === entity.localAccountId);
    };
    CacheManager2.prototype.matchUsername = function(entity, username) {
      return !!(typeof entity.username === "string" && username.toLowerCase() === entity.username.toLowerCase());
    };
    CacheManager2.prototype.matchUserAssertionHash = function(entity, userAssertionHash) {
      return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
    };
    CacheManager2.prototype.matchEnvironment = function(entity, environment) {
      var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
      if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
        return true;
      }
      return false;
    };
    CacheManager2.prototype.matchCredentialType = function(entity, credentialType) {
      return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
    };
    CacheManager2.prototype.matchClientId = function(entity, clientId) {
      return !!(entity.clientId && clientId === entity.clientId);
    };
    CacheManager2.prototype.matchFamilyId = function(entity, familyId) {
      return !!(entity.familyId && familyId === entity.familyId);
    };
    CacheManager2.prototype.matchRealm = function(entity, realm) {
      return !!(entity.realm && realm === entity.realm);
    };
    CacheManager2.prototype.matchNativeAccountId = function(entity, nativeAccountId) {
      return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
    };
    CacheManager2.prototype.matchTarget = function(entity, target) {
      var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
      if (isNotAccessTokenCredential || !entity.target) {
        return false;
      }
      var entityScopeSet = ScopeSet.fromString(entity.target);
      return entityScopeSet.containsScopeSet(target);
    };
    CacheManager2.prototype.matchTokenType = function(entity, tokenType) {
      return !!(entity.tokenType && entity.tokenType === tokenType);
    };
    CacheManager2.prototype.matchKeyId = function(entity, keyId) {
      return !!(entity.keyId && entity.keyId === keyId);
    };
    CacheManager2.prototype.isAppMetadata = function(key2) {
      return key2.indexOf(APP_METADATA) !== -1;
    };
    CacheManager2.prototype.isAuthorityMetadata = function(key2) {
      return key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
    };
    CacheManager2.prototype.generateAuthorityMetadataCacheKey = function(authority) {
      return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
    };
    CacheManager2.toObject = function(obj2, json2) {
      for (var propertyName in json2) {
        obj2[propertyName] = json2[propertyName];
      }
      return obj2;
    };
    return CacheManager2;
  }()
);
var DefaultStorageClass = (
  /** @class */
  function(_super) {
    __extends(DefaultStorageClass2, _super);
    function DefaultStorageClass2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultStorageClass2.prototype.setAccount = function() {
      var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAccount = function() {
      var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setIdTokenCredential = function() {
      var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getIdTokenCredential = function() {
      var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setAccessTokenCredential = function() {
      var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAccessTokenCredential = function() {
      var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setRefreshTokenCredential = function() {
      var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getRefreshTokenCredential = function() {
      var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setAppMetadata = function() {
      var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAppMetadata = function() {
      var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setServerTelemetry = function() {
      var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getServerTelemetry = function() {
      var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setAuthorityMetadata = function() {
      var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAuthorityMetadata = function() {
      var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAuthorityMetadataKeys = function() {
      var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.setThrottlingCache = function() {
      var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getThrottlingCache = function() {
      var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.removeItem = function() {
      var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.containsKey = function() {
      var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getKeys = function() {
      var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getAccountKeys = function() {
      var notImplErr = "Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.getTokenKeys = function() {
      var notImplErr = "Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    DefaultStorageClass2.prototype.clear = function() {
      return __awaiter(this, void 0, void 0, function() {
        var notImplErr;
        return __generator(this, function(_a2) {
          notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
          throw AuthError.createUnexpectedError(notImplErr);
        });
      });
    };
    DefaultStorageClass2.prototype.updateCredentialCacheKey = function() {
      var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
      throw AuthError.createUnexpectedError(notImplErr);
    };
    return DefaultStorageClass2;
  }(CacheManager)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
var DEFAULT_SYSTEM_OPTIONS$1 = {
  tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
  preventCorsPreflight: false
};
var DEFAULT_LOGGER_IMPLEMENTATION = {
  loggerCallback: function() {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel$1.Info,
  correlationId: Constants$1.EMPTY_STRING
};
var DEFAULT_CACHE_OPTIONS$1 = {
  claimsBasedCachingEnabled: true
};
var DEFAULT_NETWORK_IMPLEMENTATION = {
  sendGetRequestAsync: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  sendPostRequestAsync: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a2) {
        notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  }
};
var DEFAULT_LIBRARY_INFO = {
  sku: Constants$1.SKU,
  version: version$2,
  cpu: Constants$1.EMPTY_STRING,
  os: Constants$1.EMPTY_STRING
};
var DEFAULT_CLIENT_CREDENTIALS = {
  clientSecret: Constants$1.EMPTY_STRING,
  clientAssertion: void 0
};
var DEFAULT_AZURE_CLOUD_OPTIONS = {
  azureCloudInstance: AzureCloudInstance.None,
  tenant: "" + Constants$1.DEFAULT_COMMON_TENANT
};
var DEFAULT_TELEMETRY_OPTIONS$1 = {
  application: {
    appName: "",
    appVersion: ""
  }
};
function buildClientConfiguration(_a2) {
  var userAuthOptions = _a2.authOptions, userSystemOptions = _a2.systemOptions, userLoggerOption = _a2.loggerOptions, userCacheOptions = _a2.cacheOptions, storageImplementation = _a2.storageInterface, networkImplementation = _a2.networkInterface, cryptoImplementation = _a2.cryptoInterface, clientCredentials = _a2.clientCredentials, libraryInfo = _a2.libraryInfo, telemetry = _a2.telemetry, serverTelemetryManager = _a2.serverTelemetryManager, persistencePlugin = _a2.persistencePlugin, serializableCache = _a2.serializableCache;
  var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS$1), userSystemOptions),
    loggerOptions,
    cacheOptions: __assign(__assign({}, DEFAULT_CACHE_OPTIONS$1), userCacheOptions),
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions)),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo),
    telemetry: __assign(__assign({}, DEFAULT_TELEMETRY_OPTIONS$1), telemetry),
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return __assign({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ServerError = (
  /** @class */
  function(_super) {
    __extends(ServerError2, _super);
    function ServerError2(errorCode, errorMessage, subError) {
      var _this = _super.call(this, errorCode, errorMessage, subError) || this;
      _this.name = "ServerError";
      Object.setPrototypeOf(_this, ServerError2.prototype);
      return _this;
    }
    return ServerError2;
  }(AuthError)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ThrottlingUtils = (
  /** @class */
  function() {
    function ThrottlingUtils2() {
    }
    ThrottlingUtils2.generateThrottlingStorageKey = function(thumbprint) {
      return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
    };
    ThrottlingUtils2.preProcess = function(cacheManager, thumbprint) {
      var _a2;
      var key2 = ThrottlingUtils2.generateThrottlingStorageKey(thumbprint);
      var value = cacheManager.getThrottlingCache(key2);
      if (value) {
        if (value.throttleTime < Date.now()) {
          cacheManager.removeItem(key2);
          return;
        }
        throw new ServerError(((_a2 = value.errorCodes) === null || _a2 === void 0 ? void 0 : _a2.join(" ")) || Constants$1.EMPTY_STRING, value.errorMessage, value.subError);
      }
    };
    ThrottlingUtils2.postProcess = function(cacheManager, thumbprint, response) {
      if (ThrottlingUtils2.checkResponseStatus(response) || ThrottlingUtils2.checkResponseForRetryAfter(response)) {
        var thumbprintValue = {
          throttleTime: ThrottlingUtils2.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
          error: response.body.error,
          errorCodes: response.body.error_codes,
          errorMessage: response.body.error_description,
          subError: response.body.suberror
        };
        cacheManager.setThrottlingCache(ThrottlingUtils2.generateThrottlingStorageKey(thumbprint), thumbprintValue);
      }
    };
    ThrottlingUtils2.checkResponseStatus = function(response) {
      return response.status === 429 || response.status >= 500 && response.status < 600;
    };
    ThrottlingUtils2.checkResponseForRetryAfter = function(response) {
      if (response.headers) {
        return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
      }
      return false;
    };
    ThrottlingUtils2.calculateThrottleTime = function(throttleTime) {
      var time2 = throttleTime <= 0 ? 0 : throttleTime;
      var currentSeconds = Date.now() / 1e3;
      return Math.floor(Math.min(currentSeconds + (time2 || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
    };
    ThrottlingUtils2.removeThrottle = function(cacheManager, clientId, request2, homeAccountIdentifier) {
      var thumbprint = {
        clientId,
        authority: request2.authority,
        scopes: request2.scopes,
        homeAccountIdentifier,
        claims: request2.claims,
        authenticationScheme: request2.authenticationScheme,
        resourceRequestMethod: request2.resourceRequestMethod,
        resourceRequestUri: request2.resourceRequestUri,
        shrClaims: request2.shrClaims,
        sshKid: request2.sshKid
      };
      var key2 = this.generateThrottlingStorageKey(thumbprint);
      cacheManager.removeItem(key2);
    };
    return ThrottlingUtils2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var NetworkManager = (
  /** @class */
  function() {
    function NetworkManager2(networkClient, cacheManager) {
      this.networkClient = networkClient;
      this.cacheManager = cacheManager;
    }
    NetworkManager2.prototype.sendPostRequest = function(thumbprint, tokenEndpoint, options) {
      return __awaiter(this, void 0, void 0, function() {
        var response, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
            case 2:
              response = _a2.sent();
              return [3, 4];
            case 3:
              e_1 = _a2.sent();
              if (e_1 instanceof AuthError) {
                throw e_1;
              } else {
                throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
              }
            case 4:
              ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
              return [2, response];
          }
        });
      });
    };
    return NetworkManager2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var CcsCredentialType;
(function(CcsCredentialType2) {
  CcsCredentialType2["HOME_ACCOUNT_ID"] = "home_account_id";
  CcsCredentialType2["UPN"] = "UPN";
})(CcsCredentialType || (CcsCredentialType = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var RequestValidator = (
  /** @class */
  function() {
    function RequestValidator2() {
    }
    RequestValidator2.validateRedirectUri = function(redirectUri) {
      if (StringUtils.isEmpty(redirectUri)) {
        throw ClientConfigurationError.createRedirectUriEmptyError();
      }
    };
    RequestValidator2.validatePrompt = function(prompt) {
      var promptValues = [];
      for (var value in PromptValue) {
        promptValues.push(PromptValue[value]);
      }
      if (promptValues.indexOf(prompt) < 0) {
        throw ClientConfigurationError.createInvalidPromptError(prompt);
      }
    };
    RequestValidator2.validateClaims = function(claims) {
      try {
        JSON.parse(claims);
      } catch (e) {
        throw ClientConfigurationError.createInvalidClaimsRequestError();
      }
    };
    RequestValidator2.validateCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
      if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
        throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
      } else {
        this.validateCodeChallengeMethod(codeChallengeMethod);
      }
    };
    RequestValidator2.validateCodeChallengeMethod = function(codeChallengeMethod) {
      if ([
        CodeChallengeMethodValues.PLAIN,
        CodeChallengeMethodValues.S256
      ].indexOf(codeChallengeMethod) < 0) {
        throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
      }
    };
    RequestValidator2.sanitizeEQParams = function(eQParams, queryParams) {
      if (!eQParams) {
        return {};
      }
      queryParams.forEach(function(value, key2) {
        if (eQParams[key2]) {
          delete eQParams[key2];
        }
      });
      return Object.fromEntries(Object.entries(eQParams).filter(function(_a2) {
        var value = _a2[1];
        return value !== "";
      }));
    };
    return RequestValidator2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var RequestParameterBuilder = (
  /** @class */
  function() {
    function RequestParameterBuilder2() {
      this.parameters = /* @__PURE__ */ new Map();
    }
    RequestParameterBuilder2.prototype.addResponseTypeCode = function() {
      this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants$1.CODE_RESPONSE_TYPE));
    };
    RequestParameterBuilder2.prototype.addResponseTypeForTokenAndIdToken = function() {
      this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants$1.TOKEN_RESPONSE_TYPE + " " + Constants$1.ID_TOKEN_RESPONSE_TYPE));
    };
    RequestParameterBuilder2.prototype.addResponseMode = function(responseMode) {
      this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent(responseMode ? responseMode : ResponseMode.QUERY));
    };
    RequestParameterBuilder2.prototype.addNativeBroker = function() {
      this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
    };
    RequestParameterBuilder2.prototype.addScopes = function(scopes, addOidcScopes) {
      if (addOidcScopes === void 0) {
        addOidcScopes = true;
      }
      var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
      var scopeSet = new ScopeSet(requestScopes);
      this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
    };
    RequestParameterBuilder2.prototype.addClientId = function(clientId) {
      this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
    };
    RequestParameterBuilder2.prototype.addRedirectUri = function(redirectUri) {
      RequestValidator.validateRedirectUri(redirectUri);
      this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
    };
    RequestParameterBuilder2.prototype.addPostLogoutRedirectUri = function(redirectUri) {
      RequestValidator.validateRedirectUri(redirectUri);
      this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
    };
    RequestParameterBuilder2.prototype.addIdTokenHint = function(idTokenHint) {
      this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
    };
    RequestParameterBuilder2.prototype.addDomainHint = function(domainHint) {
      this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
    };
    RequestParameterBuilder2.prototype.addLoginHint = function(loginHint) {
      this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
    };
    RequestParameterBuilder2.prototype.addCcsUpn = function(loginHint) {
      this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
    };
    RequestParameterBuilder2.prototype.addCcsOid = function(clientInfo) {
      this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
    };
    RequestParameterBuilder2.prototype.addSid = function(sid) {
      this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
    };
    RequestParameterBuilder2.prototype.addClaims = function(claims, clientCapabilities) {
      var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
      RequestValidator.validateClaims(mergedClaims);
      this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
    };
    RequestParameterBuilder2.prototype.addCorrelationId = function(correlationId) {
      this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
    };
    RequestParameterBuilder2.prototype.addLibraryInfo = function(libraryInfo) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
      this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
      if (libraryInfo.os) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
      }
      if (libraryInfo.cpu) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
      }
    };
    RequestParameterBuilder2.prototype.addApplicationTelemetry = function(appTelemetry) {
      if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
        this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
      }
      if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
        this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
      }
    };
    RequestParameterBuilder2.prototype.addPrompt = function(prompt) {
      RequestValidator.validatePrompt(prompt);
      this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
    };
    RequestParameterBuilder2.prototype.addState = function(state2) {
      if (!StringUtils.isEmpty(state2)) {
        this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state2));
      }
    };
    RequestParameterBuilder2.prototype.addNonce = function(nonce) {
      this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
    };
    RequestParameterBuilder2.prototype.addCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
      RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
      if (codeChallenge && codeChallengeMethod) {
        this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
        this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
      } else {
        throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
      }
    };
    RequestParameterBuilder2.prototype.addAuthorizationCode = function(code) {
      this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));
    };
    RequestParameterBuilder2.prototype.addDeviceCode = function(code) {
      this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));
    };
    RequestParameterBuilder2.prototype.addRefreshToken = function(refreshToken) {
      this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
    };
    RequestParameterBuilder2.prototype.addCodeVerifier = function(codeVerifier) {
      this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
    };
    RequestParameterBuilder2.prototype.addClientSecret = function(clientSecret) {
      this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
    };
    RequestParameterBuilder2.prototype.addClientAssertion = function(clientAssertion) {
      if (!StringUtils.isEmpty(clientAssertion)) {
        this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
      }
    };
    RequestParameterBuilder2.prototype.addClientAssertionType = function(clientAssertionType) {
      if (!StringUtils.isEmpty(clientAssertionType)) {
        this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
      }
    };
    RequestParameterBuilder2.prototype.addOboAssertion = function(oboAssertion) {
      this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
    };
    RequestParameterBuilder2.prototype.addRequestTokenUse = function(tokenUse) {
      this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
    };
    RequestParameterBuilder2.prototype.addGrantType = function(grantType) {
      this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
    };
    RequestParameterBuilder2.prototype.addClientInfo = function() {
      this.parameters.set(CLIENT_INFO, "1");
    };
    RequestParameterBuilder2.prototype.addExtraQueryParameters = function(eQParams) {
      var _this = this;
      var sanitizedEQParams = RequestValidator.sanitizeEQParams(eQParams, this.parameters);
      Object.keys(sanitizedEQParams).forEach(function(key2) {
        _this.parameters.set(key2, eQParams[key2]);
      });
    };
    RequestParameterBuilder2.prototype.addClientCapabilitiesToClaims = function(claims, clientCapabilities) {
      var mergedClaims;
      if (!claims) {
        mergedClaims = {};
      } else {
        try {
          mergedClaims = JSON.parse(claims);
        } catch (e) {
          throw ClientConfigurationError.createInvalidClaimsRequestError();
        }
      }
      if (clientCapabilities && clientCapabilities.length > 0) {
        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
        }
        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
          values: clientCapabilities
        };
      }
      return JSON.stringify(mergedClaims);
    };
    RequestParameterBuilder2.prototype.addUsername = function(username) {
      this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
    };
    RequestParameterBuilder2.prototype.addPassword = function(password) {
      this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
    };
    RequestParameterBuilder2.prototype.addPopToken = function(cnfString) {
      if (!StringUtils.isEmpty(cnfString)) {
        this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.POP);
        this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
      }
    };
    RequestParameterBuilder2.prototype.addSshJwk = function(sshJwkString) {
      if (!StringUtils.isEmpty(sshJwkString)) {
        this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.SSH);
        this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
      }
    };
    RequestParameterBuilder2.prototype.addServerTelemetry = function(serverTelemetryManager) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
      this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
    };
    RequestParameterBuilder2.prototype.addThrottling = function() {
      this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
    };
    RequestParameterBuilder2.prototype.addLogoutHint = function(logoutHint) {
      this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
    };
    RequestParameterBuilder2.prototype.createQueryString = function() {
      var queryParameterArray = new Array();
      this.parameters.forEach(function(value, key2) {
        queryParameterArray.push(key2 + "=" + value);
      });
      return queryParameterArray.join("&");
    };
    return RequestParameterBuilder2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var BaseClient = (
  /** @class */
  function() {
    function BaseClient2(configuration, performanceClient) {
      this.config = buildClientConfiguration(configuration);
      this.logger = new Logger(this.config.loggerOptions, name$2, version$2);
      this.cryptoUtils = this.config.cryptoInterface;
      this.cacheManager = this.config.storageInterface;
      this.networkClient = this.config.networkInterface;
      this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
      this.serverTelemetryManager = this.config.serverTelemetryManager;
      this.authority = this.config.authOptions.authority;
      this.performanceClient = performanceClient;
    }
    BaseClient2.prototype.createTokenRequestHeaders = function(ccsCred) {
      var headers = {};
      headers[HeaderNames.CONTENT_TYPE] = Constants$1.URL_FORM_CONTENT_TYPE;
      if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
        switch (ccsCred.type) {
          case CcsCredentialType.HOME_ACCOUNT_ID:
            try {
              var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
              headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
            } catch (e) {
              this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
            }
            break;
          case CcsCredentialType.UPN:
            headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
            break;
        }
      }
      return headers;
    };
    BaseClient2.prototype.executePostToTokenEndpoint = function(tokenEndpoint, queryString, headers, thumbprint) {
      return __awaiter(this, void 0, void 0, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers })];
            case 1:
              response = _a2.sent();
              if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
                this.config.serverTelemetryManager.clearTelemetryCache();
              }
              return [2, response];
          }
        });
      });
    };
    BaseClient2.prototype.updateAuthority = function(updatedAuthority) {
      if (!updatedAuthority.discoveryComplete()) {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
      }
      this.authority = updatedAuthority;
    };
    BaseClient2.prototype.createTokenQueryParameters = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      if (request2.tokenQueryParameters) {
        parameterBuilder.addExtraQueryParameters(request2.tokenQueryParameters);
      }
      return parameterBuilder.createQueryString();
    };
    return BaseClient2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var CredentialEntity = (
  /** @class */
  function() {
    function CredentialEntity2() {
    }
    CredentialEntity2.prototype.generateAccountId = function() {
      return CredentialEntity2.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
    };
    CredentialEntity2.prototype.generateCredentialId = function() {
      return CredentialEntity2.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
    };
    CredentialEntity2.prototype.generateTarget = function() {
      return CredentialEntity2.generateTargetForCacheKey(this.target);
    };
    CredentialEntity2.prototype.generateCredentialKey = function() {
      return CredentialEntity2.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
    };
    CredentialEntity2.prototype.generateType = function() {
      switch (this.credentialType) {
        case CredentialType.ID_TOKEN:
          return CacheType.ID_TOKEN;
        case CredentialType.ACCESS_TOKEN:
        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
          return CacheType.ACCESS_TOKEN;
        case CredentialType.REFRESH_TOKEN:
          return CacheType.REFRESH_TOKEN;
        default: {
          throw ClientAuthError.createUnexpectedCredentialTypeError();
        }
      }
    };
    CredentialEntity2.generateCredentialCacheKey = function(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
      var credentialKey = [
        this.generateAccountIdForCacheKey(homeAccountId, environment),
        this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
        this.generateTargetForCacheKey(target),
        this.generateClaimsHashForCacheKey(requestedClaimsHash),
        this.generateSchemeForCacheKey(tokenType)
      ];
      return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    CredentialEntity2.generateAccountIdForCacheKey = function(homeAccountId, environment) {
      var accountId = [homeAccountId, environment];
      return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    CredentialEntity2.generateCredentialIdForCacheKey = function(credentialType, clientId, realm, familyId) {
      var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;
      var credentialId = [
        credentialType,
        clientOrFamilyId,
        realm || Constants$1.EMPTY_STRING
      ];
      return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    CredentialEntity2.generateTargetForCacheKey = function(scopes) {
      return (scopes || Constants$1.EMPTY_STRING).toLowerCase();
    };
    CredentialEntity2.generateClaimsHashForCacheKey = function(requestedClaimsHash) {
      return (requestedClaimsHash || Constants$1.EMPTY_STRING).toLowerCase();
    };
    CredentialEntity2.generateSchemeForCacheKey = function(tokenType) {
      return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants$1.EMPTY_STRING;
    };
    return CredentialEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var IdTokenEntity = (
  /** @class */
  function(_super) {
    __extends(IdTokenEntity2, _super);
    function IdTokenEntity2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IdTokenEntity2.createIdTokenEntity = function(homeAccountId, environment, idToken, clientId, tenantId) {
      var idTokenEntity = new IdTokenEntity2();
      idTokenEntity.credentialType = CredentialType.ID_TOKEN;
      idTokenEntity.homeAccountId = homeAccountId;
      idTokenEntity.environment = environment;
      idTokenEntity.clientId = clientId;
      idTokenEntity.secret = idToken;
      idTokenEntity.realm = tenantId;
      return idTokenEntity;
    };
    IdTokenEntity2.isIdTokenEntity = function(entity) {
      if (!entity) {
        return false;
      }
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.ID_TOKEN;
    };
    return IdTokenEntity2;
  }(CredentialEntity)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var TimeUtils = (
  /** @class */
  function() {
    function TimeUtils2() {
    }
    TimeUtils2.nowSeconds = function() {
      return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    };
    TimeUtils2.isTokenExpired = function(expiresOn, offset) {
      var expirationSec = Number(expiresOn) || 0;
      var offsetCurrentTimeSec = TimeUtils2.nowSeconds() + offset;
      return offsetCurrentTimeSec > expirationSec;
    };
    TimeUtils2.wasClockTurnedBack = function(cachedAt) {
      var cachedAtSec = Number(cachedAt);
      return cachedAtSec > TimeUtils2.nowSeconds();
    };
    TimeUtils2.delay = function(t2, value) {
      return new Promise(function(resolve) {
        return setTimeout(function() {
          return resolve(value);
        }, t2);
      });
    };
    return TimeUtils2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AccessTokenEntity = (
  /** @class */
  function(_super) {
    __extends(AccessTokenEntity2, _super);
    function AccessTokenEntity2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AccessTokenEntity2.createAccessTokenEntity = function(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
      var _a2, _b2;
      var atEntity = new AccessTokenEntity2();
      atEntity.homeAccountId = homeAccountId;
      atEntity.credentialType = CredentialType.ACCESS_TOKEN;
      atEntity.secret = accessToken;
      var currentTime = TimeUtils.nowSeconds();
      atEntity.cachedAt = currentTime.toString();
      atEntity.expiresOn = expiresOn.toString();
      atEntity.extendedExpiresOn = extExpiresOn.toString();
      if (refreshOn) {
        atEntity.refreshOn = refreshOn.toString();
      }
      atEntity.environment = environment;
      atEntity.clientId = clientId;
      atEntity.realm = tenantId;
      atEntity.target = scopes;
      atEntity.userAssertionHash = userAssertionHash;
      atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;
      if (requestedClaims) {
        atEntity.requestedClaims = requestedClaims;
        atEntity.requestedClaimsHash = requestedClaimsHash;
      }
      if (((_a2 = atEntity.tokenType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        switch (atEntity.tokenType) {
          case AuthenticationScheme.POP:
            var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
            if (!((_b2 = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b2 === void 0 ? void 0 : _b2.kid)) {
              throw ClientAuthError.createTokenClaimsRequiredError();
            }
            atEntity.keyId = tokenClaims.cnf.kid;
            break;
          case AuthenticationScheme.SSH:
            atEntity.keyId = keyId;
        }
      }
      return atEntity;
    };
    AccessTokenEntity2.isAccessTokenEntity = function(entity) {
      if (!entity) {
        return false;
      }
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
    };
    return AccessTokenEntity2;
  }(CredentialEntity)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var RefreshTokenEntity = (
  /** @class */
  function(_super) {
    __extends(RefreshTokenEntity2, _super);
    function RefreshTokenEntity2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RefreshTokenEntity2.createRefreshTokenEntity = function(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
      var rtEntity = new RefreshTokenEntity2();
      rtEntity.clientId = clientId;
      rtEntity.credentialType = CredentialType.REFRESH_TOKEN;
      rtEntity.environment = environment;
      rtEntity.homeAccountId = homeAccountId;
      rtEntity.secret = refreshToken;
      rtEntity.userAssertionHash = userAssertionHash;
      if (familyId)
        rtEntity.familyId = familyId;
      return rtEntity;
    };
    RefreshTokenEntity2.isRefreshTokenEntity = function(entity) {
      if (!entity) {
        return false;
      }
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
    };
    return RefreshTokenEntity2;
  }(CredentialEntity)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var InteractionRequiredServerErrorMessage = [
  "interaction_required",
  "consent_required",
  "login_required"
];
var InteractionRequiredAuthSubErrorMessage = [
  "message_only",
  "additional_action",
  "basic_action",
  "user_password_expired",
  "consent_required"
];
var InteractionRequiredAuthErrorMessage = {
  noTokensFoundError: {
    code: "no_tokens_found",
    desc: "No refresh token found in the cache. Please sign-in."
  },
  native_account_unavailable: {
    code: "native_account_unavailable",
    desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
  }
};
var InteractionRequiredAuthError = (
  /** @class */
  function(_super) {
    __extends(InteractionRequiredAuthError2, _super);
    function InteractionRequiredAuthError2(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims) {
      var _this = _super.call(this, errorCode, errorMessage, subError) || this;
      Object.setPrototypeOf(_this, InteractionRequiredAuthError2.prototype);
      _this.timestamp = timestamp || Constants$1.EMPTY_STRING;
      _this.traceId = traceId || Constants$1.EMPTY_STRING;
      _this.correlationId = correlationId || Constants$1.EMPTY_STRING;
      _this.claims = claims || Constants$1.EMPTY_STRING;
      _this.name = "InteractionRequiredAuthError";
      return _this;
    }
    InteractionRequiredAuthError2.isInteractionRequiredError = function(errorCode, errorString, subError) {
      var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
      var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
      var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function(irErrorCode) {
        return errorString.indexOf(irErrorCode) > -1;
      });
      return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
    };
    InteractionRequiredAuthError2.createNoTokensFoundError = function() {
      return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
    };
    InteractionRequiredAuthError2.createNativeAccountUnavailableError = function() {
      return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
    };
    return InteractionRequiredAuthError2;
  }(AuthError)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var CacheRecord = (
  /** @class */
  /* @__PURE__ */ function() {
    function CacheRecord2(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
      this.account = accountEntity || null;
      this.idToken = idTokenEntity || null;
      this.accessToken = accessTokenEntity || null;
      this.refreshToken = refreshTokenEntity || null;
      this.appMetadata = appMetadataEntity || null;
    }
    return CacheRecord2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ProtocolUtils = (
  /** @class */
  function() {
    function ProtocolUtils2() {
    }
    ProtocolUtils2.setRequestState = function(cryptoObj, userState, meta) {
      var libraryState = ProtocolUtils2.generateLibraryState(cryptoObj, meta);
      return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants$1.RESOURCE_DELIM + userState : libraryState;
    };
    ProtocolUtils2.generateLibraryState = function(cryptoObj, meta) {
      if (!cryptoObj) {
        throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
      }
      var stateObj = {
        id: cryptoObj.createNewGuid()
      };
      if (meta) {
        stateObj.meta = meta;
      }
      var stateString = JSON.stringify(stateObj);
      return cryptoObj.base64Encode(stateString);
    };
    ProtocolUtils2.parseRequestState = function(cryptoObj, state2) {
      if (!cryptoObj) {
        throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
      }
      if (StringUtils.isEmpty(state2)) {
        throw ClientAuthError.createInvalidStateError(state2, "Null, undefined or empty state");
      }
      try {
        var splitState = state2.split(Constants$1.RESOURCE_DELIM);
        var libraryState = splitState[0];
        var userState = splitState.length > 1 ? splitState.slice(1).join(Constants$1.RESOURCE_DELIM) : Constants$1.EMPTY_STRING;
        var libraryStateString = cryptoObj.base64Decode(libraryState);
        var libraryStateObj = JSON.parse(libraryStateString);
        return {
          userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants$1.EMPTY_STRING,
          libraryState: libraryStateObj
        };
      } catch (e) {
        throw ClientAuthError.createInvalidStateError(state2, e);
      }
    };
    return ProtocolUtils2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var UrlString = (
  /** @class */
  function() {
    function UrlString2(url) {
      this._urlString = url;
      if (StringUtils.isEmpty(this._urlString)) {
        throw ClientConfigurationError.createUrlEmptyError();
      }
      if (StringUtils.isEmpty(this.getHash())) {
        this._urlString = UrlString2.canonicalizeUri(url);
      }
    }
    Object.defineProperty(UrlString2.prototype, "urlString", {
      get: function() {
        return this._urlString;
      },
      enumerable: false,
      configurable: true
    });
    UrlString2.canonicalizeUri = function(url) {
      if (url) {
        var lowerCaseUrl = url.toLowerCase();
        if (StringUtils.endsWith(lowerCaseUrl, "?")) {
          lowerCaseUrl = lowerCaseUrl.slice(0, -1);
        } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
          lowerCaseUrl = lowerCaseUrl.slice(0, -2);
        }
        if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
          lowerCaseUrl += "/";
        }
        return lowerCaseUrl;
      }
      return url;
    };
    UrlString2.prototype.validateAsUri = function() {
      var components;
      try {
        components = this.getUrlComponents();
      } catch (e) {
        throw ClientConfigurationError.createUrlParseError(e);
      }
      if (!components.HostNameAndPort || !components.PathSegments) {
        throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
      }
      if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
        throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
      }
    };
    UrlString2.appendQueryString = function(url, queryString) {
      if (StringUtils.isEmpty(queryString)) {
        return url;
      }
      return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
    };
    UrlString2.removeHashFromUrl = function(url) {
      return UrlString2.canonicalizeUri(url.split("#")[0]);
    };
    UrlString2.prototype.replaceTenantPath = function(tenantId) {
      var urlObject = this.getUrlComponents();
      var pathArray = urlObject.PathSegments;
      if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
        pathArray[0] = tenantId;
      }
      return UrlString2.constructAuthorityUriFromObject(urlObject);
    };
    UrlString2.prototype.getHash = function() {
      return UrlString2.parseHash(this.urlString);
    };
    UrlString2.prototype.getUrlComponents = function() {
      var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
      var match = this.urlString.match(regEx);
      if (!match) {
        throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
      }
      var urlComponents = {
        Protocol: match[1],
        HostNameAndPort: match[4],
        AbsolutePath: match[5],
        QueryString: match[7]
      };
      var pathSegments = urlComponents.AbsolutePath.split("/");
      pathSegments = pathSegments.filter(function(val) {
        return val && val.length > 0;
      });
      urlComponents.PathSegments = pathSegments;
      if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
        urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
      }
      return urlComponents;
    };
    UrlString2.getDomainFromUrl = function(url) {
      var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
      var match = url.match(regEx);
      if (!match) {
        throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
      }
      return match[2];
    };
    UrlString2.getAbsoluteUrl = function(relativeUrl, baseUrl) {
      if (relativeUrl[0] === Constants$1.FORWARD_SLASH) {
        var url = new UrlString2(baseUrl);
        var baseComponents = url.getUrlComponents();
        return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
      }
      return relativeUrl;
    };
    UrlString2.parseHash = function(hashString) {
      var hashIndex1 = hashString.indexOf("#");
      var hashIndex2 = hashString.indexOf("#/");
      if (hashIndex2 > -1) {
        return hashString.substring(hashIndex2 + 2);
      } else if (hashIndex1 > -1) {
        return hashString.substring(hashIndex1 + 1);
      }
      return Constants$1.EMPTY_STRING;
    };
    UrlString2.parseQueryString = function(queryString) {
      var queryIndex1 = queryString.indexOf("?");
      var queryIndex2 = queryString.indexOf("/?");
      if (queryIndex2 > -1) {
        return queryString.substring(queryIndex2 + 2);
      } else if (queryIndex1 > -1) {
        return queryString.substring(queryIndex1 + 1);
      }
      return Constants$1.EMPTY_STRING;
    };
    UrlString2.constructAuthorityUriFromObject = function(urlObject) {
      return new UrlString2(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
    };
    UrlString2.getDeserializedHash = function(hash) {
      if (StringUtils.isEmpty(hash)) {
        return {};
      }
      var parsedHash = UrlString2.parseHash(hash);
      var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
      if (!deserializedHash) {
        throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
      }
      return deserializedHash;
    };
    UrlString2.getDeserializedQueryString = function(query) {
      if (StringUtils.isEmpty(query)) {
        return {};
      }
      var parsedQueryString = UrlString2.parseQueryString(query);
      var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
      if (!deserializedQueryString) {
        throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
      }
      return deserializedQueryString;
    };
    UrlString2.hashContainsKnownProperties = function(hash) {
      if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
        return false;
      }
      var parameters = UrlString2.getDeserializedHash(hash);
      return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);
    };
    return UrlString2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var PerformanceEvents;
(function(PerformanceEvents2) {
  PerformanceEvents2["AcquireTokenByCode"] = "acquireTokenByCode";
  PerformanceEvents2["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
  PerformanceEvents2["AcquireTokenSilent"] = "acquireTokenSilent";
  PerformanceEvents2["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
  PerformanceEvents2["AcquireTokenPopup"] = "acquireTokenPopup";
  PerformanceEvents2["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
  PerformanceEvents2["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
  PerformanceEvents2["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
  PerformanceEvents2["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
  PerformanceEvents2["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
  PerformanceEvents2["SsoSilent"] = "ssoSilent";
  PerformanceEvents2["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
  PerformanceEvents2["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
  PerformanceEvents2["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
  PerformanceEvents2["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
  PerformanceEvents2["BrokerHandhshake"] = "brokerHandshake";
  PerformanceEvents2["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
  PerformanceEvents2["AcquireTokenByBroker"] = "acquireTokenByBroker";
  PerformanceEvents2["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
  PerformanceEvents2["RefreshTokenClientAcquireToken"] = "refreshTokenClientAcquireToken";
  PerformanceEvents2["RefreshTokenClientAcquireTokenWithCachedRefreshToken"] = "refreshTokenClientAcquireTokenWithCachedRefreshToken";
  PerformanceEvents2["RefreshTokenClientAcquireTokenByRefreshToken"] = "refreshTokenClientAcquireTokenByRefreshToken";
  PerformanceEvents2["RefreshTokenClientCreateTokenRequestBody"] = "refreshTokenClientCreateTokenRequestBody";
  PerformanceEvents2["AcquireTokenFromCache"] = "acquireTokenFromCache";
  PerformanceEvents2["AcquireTokenBySilentIframe"] = "acquireTokenBySilentIframe";
  PerformanceEvents2["InitializeBaseRequest"] = "initializeBaseRequest";
  PerformanceEvents2["InitializeSilentRequest"] = "initializeSilentRequest";
  PerformanceEvents2["InitializeClientApplication"] = "initializeClientApplication";
  PerformanceEvents2["SilentIframeClientTokenHelper"] = "silentIframeClientTokenHelper";
  PerformanceEvents2["SilentHandlerInitiateAuthRequest"] = "silentHandlerInitiateAuthRequest";
  PerformanceEvents2["SilentHandlerMonitorIframeForHash"] = "silentHandlerMonitorIframeForHash";
  PerformanceEvents2["SilentHandlerLoadFrame"] = "silentHandlerLoadFrame";
  PerformanceEvents2["StandardInteractionClientCreateAuthCodeClient"] = "standardInteractionClientCreateAuthCodeClient";
  PerformanceEvents2["StandardInteractionClientGetClientConfiguration"] = "standardInteractionClientGetClientConfiguration";
  PerformanceEvents2["StandardInteractionClientInitializeAuthorizationRequest"] = "standardInteractionClientInitializeAuthorizationRequest";
  PerformanceEvents2["StandardInteractionClientInitializeAuthorizationCodeRequest"] = "standardInteractionClientInitializeAuthorizationCodeRequest";
  PerformanceEvents2["GetAuthCodeUrl"] = "getAuthCodeUrl";
  PerformanceEvents2["HandleCodeResponseFromServer"] = "handleCodeResponseFromServer";
  PerformanceEvents2["HandleCodeResponseFromHash"] = "handleCodeResponseFromHash";
  PerformanceEvents2["UpdateTokenEndpointAuthority"] = "updateTokenEndpointAuthority";
  PerformanceEvents2["AuthClientAcquireToken"] = "authClientAcquireToken";
  PerformanceEvents2["AuthClientExecuteTokenRequest"] = "authClientExecuteTokenRequest";
  PerformanceEvents2["AuthClientCreateTokenRequestBody"] = "authClientCreateTokenRequestBody";
  PerformanceEvents2["AuthClientCreateQueryString"] = "authClientCreateQueryString";
  PerformanceEvents2["PopTokenGenerateCnf"] = "popTokenGenerateCnf";
  PerformanceEvents2["PopTokenGenerateKid"] = "popTokenGenerateKid";
  PerformanceEvents2["HandleServerTokenResponse"] = "handleServerTokenResponse";
  PerformanceEvents2["AuthorityFactoryCreateDiscoveredInstance"] = "authorityFactoryCreateDiscoveredInstance";
  PerformanceEvents2["AuthorityResolveEndpointsAsync"] = "authorityResolveEndpointsAsync";
  PerformanceEvents2["AuthorityGetCloudDiscoveryMetadataFromNetwork"] = "authorityGetCloudDiscoveryMetadataFromNetwork";
  PerformanceEvents2["AuthorityUpdateCloudDiscoveryMetadata"] = "authorityUpdateCloudDiscoveryMetadata";
  PerformanceEvents2["AuthorityGetEndpointMetadataFromNetwork"] = "authorityGetEndpointMetadataFromNetwork";
  PerformanceEvents2["AuthorityUpdateEndpointMetadata"] = "authorityUpdateEndpointMetadata";
  PerformanceEvents2["AuthorityUpdateMetadataWithRegionalInformation"] = "authorityUpdateMetadataWithRegionalInformation";
  PerformanceEvents2["RegionDiscoveryDetectRegion"] = "regionDiscoveryDetectRegion";
  PerformanceEvents2["RegionDiscoveryGetRegionFromIMDS"] = "regionDiscoveryGetRegionFromIMDS";
  PerformanceEvents2["RegionDiscoveryGetCurrentVersion"] = "regionDiscoveryGetCurrentVersion";
  PerformanceEvents2["AcquireTokenByCodeAsync"] = "acquireTokenByCodeAsync";
  PerformanceEvents2["GetEndpointMetadataFromNetwork"] = "getEndpointMetadataFromNetwork";
  PerformanceEvents2["GetCloudDiscoveryMetadataFromNetworkMeasurement"] = "getCloudDiscoveryMetadataFromNetworkMeasurement";
  PerformanceEvents2["HandleRedirectPromiseMeasurement"] = "handleRedirectPromiseMeasurement";
  PerformanceEvents2["UpdateCloudDiscoveryMetadataMeasurement"] = "updateCloudDiscoveryMetadataMeasurement";
  PerformanceEvents2["UsernamePasswordClientAcquireToken"] = "usernamePasswordClientAcquireToken";
  PerformanceEvents2["NativeMessageHandlerHandshake"] = "nativeMessageHandlerHandshake";
  PerformanceEvents2["ClearTokensAndKeysWithClaims"] = "clearTokensAndKeysWithClaims";
})(PerformanceEvents || (PerformanceEvents = {}));
var PerformanceEventStatus;
(function(PerformanceEventStatus2) {
  PerformanceEventStatus2[PerformanceEventStatus2["NotStarted"] = 0] = "NotStarted";
  PerformanceEventStatus2[PerformanceEventStatus2["InProgress"] = 1] = "InProgress";
  PerformanceEventStatus2[PerformanceEventStatus2["Completed"] = 2] = "Completed";
})(PerformanceEventStatus || (PerformanceEventStatus = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var KeyLocation;
(function(KeyLocation2) {
  KeyLocation2["SW"] = "sw";
  KeyLocation2["UHW"] = "uhw";
})(KeyLocation || (KeyLocation = {}));
var PopTokenGenerator = (
  /** @class */
  function() {
    function PopTokenGenerator2(cryptoUtils, performanceClient) {
      this.cryptoUtils = cryptoUtils;
      this.performanceClient = performanceClient;
    }
    PopTokenGenerator2.prototype.generateCnf = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var reqCnf, reqCnfString, _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request2.correlationId);
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.PopTokenGenerateKid, request2.correlationId);
              return [4, this.generateKid(request2)];
            case 1:
              reqCnf = _d.sent();
              reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
              _c = {
                kid: reqCnf.kid,
                reqCnfString
              };
              return [4, this.cryptoUtils.hashString(reqCnfString)];
            case 2:
              return [2, (_c.reqCnfHash = _d.sent(), _c)];
          }
        });
      });
    };
    PopTokenGenerator2.prototype.generateKid = function(request2) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var kidThumbprint;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request2.correlationId);
              return [4, this.cryptoUtils.getPublicKeyThumbprint(request2)];
            case 1:
              kidThumbprint = _b2.sent();
              return [2, {
                kid: kidThumbprint,
                xms_ksl: KeyLocation.SW
              }];
          }
        });
      });
    };
    PopTokenGenerator2.prototype.signPopToken = function(accessToken, keyId, request2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, this.signPayload(accessToken, keyId, request2)];
        });
      });
    };
    PopTokenGenerator2.prototype.signPayload = function(payload, keyId, request2, claims) {
      return __awaiter(this, void 0, void 0, function() {
        var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              resourceRequestMethod = request2.resourceRequestMethod, resourceRequestUri = request2.resourceRequestUri, shrClaims = request2.shrClaims, shrNonce = request2.shrNonce;
              resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
              resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
              return [4, this.cryptoUtils.signJwt(__assign({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0, client_claims: shrClaims || void 0 }, claims), keyId, request2.correlationId)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return PopTokenGenerator2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AppMetadataEntity = (
  /** @class */
  function() {
    function AppMetadataEntity2() {
    }
    AppMetadataEntity2.prototype.generateAppMetadataKey = function() {
      return AppMetadataEntity2.generateAppMetadataCacheKey(this.environment, this.clientId);
    };
    AppMetadataEntity2.generateAppMetadataCacheKey = function(environment, clientId) {
      var appMetaDataKeyArray = [
        APP_METADATA,
        environment,
        clientId
      ];
      return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    };
    AppMetadataEntity2.createAppMetadataEntity = function(clientId, environment, familyId) {
      var appMetadata = new AppMetadataEntity2();
      appMetadata.clientId = clientId;
      appMetadata.environment = environment;
      if (familyId) {
        appMetadata.familyId = familyId;
      }
      return appMetadata;
    };
    AppMetadataEntity2.isAppMetadataEntity = function(key2, entity) {
      if (!entity) {
        return false;
      }
      return key2.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
    };
    return AppMetadataEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var TokenCacheContext = (
  /** @class */
  function() {
    function TokenCacheContext2(tokenCache, hasChanged) {
      this.cache = tokenCache;
      this.hasChanged = hasChanged;
    }
    Object.defineProperty(TokenCacheContext2.prototype, "cacheHasChanged", {
      /**
       * boolean which indicates the changes in cache
       */
      get: function() {
        return this.hasChanged;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TokenCacheContext2.prototype, "tokenCache", {
      /**
       * function to retrieve the token cache
       */
      get: function() {
        return this.cache;
      },
      enumerable: false,
      configurable: true
    });
    return TokenCacheContext2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ResponseHandler = (
  /** @class */
  function() {
    function ResponseHandler2(clientId, cacheStorage, cryptoObj, logger2, serializableCache, persistencePlugin, performanceClient) {
      this.clientId = clientId;
      this.cacheStorage = cacheStorage;
      this.cryptoObj = cryptoObj;
      this.logger = logger2;
      this.serializableCache = serializableCache;
      this.persistencePlugin = persistencePlugin;
      this.performanceClient = performanceClient;
    }
    ResponseHandler2.prototype.validateServerAuthorizationCodeResponse = function(serverResponseHash, cachedState, cryptoObj) {
      if (!serverResponseHash.state || !cachedState) {
        throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
      }
      if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
        throw ClientAuthError.createStateMismatchError();
      }
      if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
        if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
          throw new InteractionRequiredAuthError(serverResponseHash.error || Constants$1.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants$1.EMPTY_STRING, serverResponseHash.trace_id || Constants$1.EMPTY_STRING, serverResponseHash.correlation_id || Constants$1.EMPTY_STRING, serverResponseHash.claims || Constants$1.EMPTY_STRING);
        }
        throw new ServerError(serverResponseHash.error || Constants$1.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
      }
      if (serverResponseHash.client_info) {
        buildClientInfo(serverResponseHash.client_info, cryptoObj);
      }
    };
    ResponseHandler2.prototype.validateTokenResponse = function(serverResponse) {
      if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
        if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
          throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants$1.EMPTY_STRING, serverResponse.trace_id || Constants$1.EMPTY_STRING, serverResponse.correlation_id || Constants$1.EMPTY_STRING, serverResponse.claims || Constants$1.EMPTY_STRING);
        }
        var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
        throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
      }
    };
    ResponseHandler2.prototype.handleServerTokenResponse = function(serverTokenResponse, authority, reqTimestamp, request2, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key2, account;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
              if (serverTokenResponse.id_token) {
                idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.cryptoObj);
                if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                  if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                    throw ClientAuthError.createNonceMismatchError();
                  }
                }
                if (request2.maxAge || request2.maxAge === 0) {
                  authTime = idTokenObj.claims.auth_time;
                  if (!authTime) {
                    throw ClientAuthError.createAuthTimeNotFoundError();
                  }
                  AuthToken.checkMaxAge(authTime, request2.maxAge);
                }
              }
              this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants$1.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
              if (!!authCodePayload && !!authCodePayload.state) {
                requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
              }
              serverTokenResponse.key_id = serverTokenResponse.key_id || request2.sshKid || void 0;
              cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request2, idTokenObj, userAssertionHash, authCodePayload);
              _b2.label = 1;
            case 1:
              _b2.trys.push([1, , 5, 8]);
              if (!(this.persistencePlugin && this.serializableCache)) return [3, 3];
              this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
              cacheContext = new TokenCacheContext(this.serializableCache, true);
              return [4, this.persistencePlugin.beforeCacheAccess(cacheContext)];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
                key2 = cacheRecord.account.generateAccountKey();
                account = this.cacheStorage.getAccount(key2);
                if (!account) {
                  this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                  return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request2, idTokenObj, requestStateObj, void 0, serverRequestId)];
                }
              }
              return [4, this.cacheStorage.saveCacheRecord(cacheRecord)];
            case 4:
              _b2.sent();
              return [3, 8];
            case 5:
              if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3, 7];
              this.logger.verbose("Persistence enabled, calling afterCacheAccess");
              return [4, this.persistencePlugin.afterCacheAccess(cacheContext)];
            case 6:
              _b2.sent();
              _b2.label = 7;
            case 7:
              return [
                7
                /*endfinally*/
              ];
            case 8:
              return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request2, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];
          }
        });
      });
    };
    ResponseHandler2.prototype.generateCacheRecord = function(serverTokenResponse, authority, reqTimestamp, request2, idTokenObj, userAssertionHash, authCodePayload) {
      var env = authority.getPreferredCache();
      if (StringUtils.isEmpty(env)) {
        throw ClientAuthError.createInvalidCacheEnvironmentError();
      }
      var cachedIdToken;
      var cachedAccount;
      if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
        cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants$1.EMPTY_STRING);
        cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
      }
      var cachedAccessToken = null;
      if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
        var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request2.scopes || []);
        var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
        var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
        var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
        var tokenExpirationSeconds = reqTimestamp + expiresIn;
        var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
        var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
        cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants$1.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants$1.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request2.claims, request2.requestedClaimsHash);
      }
      var cachedRefreshToken = null;
      if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
        cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants$1.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
      }
      var cachedAppMetadata = null;
      if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
        cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
      }
      return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
    };
    ResponseHandler2.prototype.generateAccountEntity = function(serverTokenResponse, idToken, authority, authCodePayload) {
      var authorityType = authority.authorityType;
      var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants$1.EMPTY_STRING;
      var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants$1.EMPTY_STRING;
      if (authorityType === AuthorityType.Adfs) {
        this.logger.verbose("Authority type is ADFS, creating ADFS account");
        return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
      }
      if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
        throw ClientAuthError.createClientInfoEmptyError();
      }
      return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
    };
    ResponseHandler2.generateAuthenticationResult = function(cryptoObj, authority, cacheRecord, fromTokenCache, request2, idTokenObj, requestState, serverTokenResponse, requestId) {
      var _a2, _b2, _c;
      return __awaiter(this, void 0, void 0, function() {
        var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              accessToken = Constants$1.EMPTY_STRING;
              responseScopes = [];
              expiresOn = null;
              familyId = Constants$1.EMPTY_STRING;
              if (!cacheRecord.accessToken) return [3, 4];
              if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3, 2];
              popTokenGenerator = new PopTokenGenerator(cryptoObj);
              _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
              if (!keyId) {
                throw ClientAuthError.createKeyIdMissingError();
              }
              return [4, popTokenGenerator.signPopToken(secret, keyId, request2)];
            case 1:
              accessToken = _e.sent();
              return [3, 3];
            case 2:
              accessToken = cacheRecord.accessToken.secret;
              _e.label = 3;
            case 3:
              responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
              expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1e3);
              extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1e3);
              _e.label = 4;
            case 4:
              if (cacheRecord.appMetadata) {
                familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants$1.EMPTY_STRING;
              }
              uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants$1.EMPTY_STRING;
              tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants$1.EMPTY_STRING;
              if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {
                cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;
              }
              return [2, {
                authority: authority.canonicalAuthority,
                uniqueId: uid,
                tenantId: tid,
                scopes: responseScopes,
                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
                idToken: idTokenObj ? idTokenObj.rawToken : Constants$1.EMPTY_STRING,
                idTokenClaims: idTokenObj ? idTokenObj.claims : {},
                accessToken,
                fromCache: fromTokenCache,
                expiresOn,
                correlationId: request2.correlationId,
                requestId: requestId || Constants$1.EMPTY_STRING,
                extExpiresOn,
                familyId,
                tokenType: ((_a2 = cacheRecord.accessToken) === null || _a2 === void 0 ? void 0 : _a2.tokenType) || Constants$1.EMPTY_STRING,
                state: requestState ? requestState.userRequestState : Constants$1.EMPTY_STRING,
                cloudGraphHostName: ((_b2 = cacheRecord.account) === null || _b2 === void 0 ? void 0 : _b2.cloudGraphHostName) || Constants$1.EMPTY_STRING,
                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants$1.EMPTY_STRING,
                code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,
                fromNativeBroker: false
              }];
          }
        });
      });
    };
    return ResponseHandler2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthorizationCodeClient = (
  /** @class */
  function(_super) {
    __extends(AuthorizationCodeClient2, _super);
    function AuthorizationCodeClient2(configuration, performanceClient) {
      var _this = _super.call(this, configuration, performanceClient) || this;
      _this.includeRedirectUri = true;
      return _this;
    }
    AuthorizationCodeClient2.prototype.getAuthCodeUrl = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var queryString;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request2.correlationId);
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request2.correlationId);
              return [4, this.createAuthCodeUrlQueryString(request2)];
            case 1:
              queryString = _c.sent();
              return [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
          }
        });
      });
    };
    AuthorizationCodeClient2.prototype.acquireToken = function(request2, authCodePayload) {
      var _a2, _b2, _c, _d, _e, _f;
      return __awaiter(this, void 0, void 0, function() {
        var atsMeasurement, reqTimestamp, response, requestId, httpVerAuthority, responseHandler;
        var _this = this;
        return __generator(this, function(_g) {
          switch (_g.label) {
            case 0:
              if (!request2 || !request2.code) {
                throw ClientAuthError.createTokenRequestCannotBeMadeError();
              }
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request2.correlationId);
              atsMeasurement = (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.startMeasurement("AuthCodeClientAcquireToken", request2.correlationId);
              this.logger.info("in acquireToken call in auth-code client");
              reqTimestamp = TimeUtils.nowSeconds();
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request2.correlationId);
              return [4, this.executeTokenRequest(this.authority, request2)];
            case 1:
              response = _g.sent();
              requestId = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_REQUEST_ID];
              httpVerAuthority = (_e = response.headers) === null || _e === void 0 ? void 0 : _e[HeaderNames.X_MS_HTTP_VERSION];
              if (httpVerAuthority) {
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
                  httpVerAuthority
                });
              }
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
              responseHandler.validateTokenResponse(response.body);
              (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request2.correlationId);
              return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request2, authCodePayload, void 0, void 0, void 0, requestId).then(function(result) {
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                  success: true
                });
                return result;
              }).catch(function(error2) {
                _this.logger.verbose("Error in fetching token in ACC", request2.correlationId);
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                  errorCode: error2.errorCode,
                  subErrorCode: error2.subError,
                  success: false
                });
                throw error2;
              })];
          }
        });
      });
    };
    AuthorizationCodeClient2.prototype.handleFragmentResponse = function(hashFragment, cachedState) {
      var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
      var hashUrlString = new UrlString(hashFragment);
      var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
      responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
      if (!serverParams.code) {
        throw ClientAuthError.createNoAuthCodeInServerResponseError();
      }
      return __assign(__assign({}, serverParams), {
        // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod
        code: serverParams.code
      });
    };
    AuthorizationCodeClient2.prototype.getLogoutUri = function(logoutRequest) {
      if (!logoutRequest) {
        throw ClientConfigurationError.createEmptyLogoutRequestError();
      }
      var queryString = this.createLogoutUrlQueryString(logoutRequest);
      return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
    };
    AuthorizationCodeClient2.prototype.executeTokenRequest = function(authority, request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var queryParametersString, endpoint, requestBody, ccsCredential, clientInfo, headers, thumbprint;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request2.correlationId);
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request2.correlationId);
              queryParametersString = this.createTokenQueryParameters(request2);
              endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
              return [4, this.createTokenRequestBody(request2)];
            case 1:
              requestBody = _c.sent();
              ccsCredential = void 0;
              if (request2.clientInfo) {
                try {
                  clientInfo = buildClientInfo(request2.clientInfo, this.cryptoUtils);
                  ccsCredential = {
                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                    type: CcsCredentialType.HOME_ACCOUNT_ID
                  };
                } catch (e) {
                  this.logger.verbose("Could not parse client info for CCS Header: " + e);
                }
              }
              headers = this.createTokenRequestHeaders(ccsCredential || request2.ccsCredential);
              thumbprint = {
                clientId: this.config.authOptions.clientId,
                authority: authority.canonicalAuthority,
                scopes: request2.scopes,
                claims: request2.claims,
                authenticationScheme: request2.authenticationScheme,
                resourceRequestMethod: request2.resourceRequestMethod,
                resourceRequestUri: request2.resourceRequestUri,
                shrClaims: request2.shrClaims,
                sshKid: request2.sshKid
              };
              return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
          }
        });
      });
    };
    AuthorizationCodeClient2.prototype.createTokenRequestBody = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
        var _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request2.correlationId);
              parameterBuilder = new RequestParameterBuilder();
              parameterBuilder.addClientId(this.config.authOptions.clientId);
              if (!this.includeRedirectUri) {
                RequestValidator.validateRedirectUri(request2.redirectUri);
              } else {
                parameterBuilder.addRedirectUri(request2.redirectUri);
              }
              parameterBuilder.addScopes(request2.scopes);
              parameterBuilder.addAuthorizationCode(request2.code);
              parameterBuilder.addLibraryInfo(this.config.libraryInfo);
              parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
              parameterBuilder.addThrottling();
              if (this.serverTelemetryManager) {
                parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
              }
              if (request2.codeVerifier) {
                parameterBuilder.addCodeVerifier(request2.codeVerifier);
              }
              if (this.config.clientCredentials.clientSecret) {
                parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
              }
              if (this.config.clientCredentials.clientAssertion) {
                clientAssertion = this.config.clientCredentials.clientAssertion;
                parameterBuilder.addClientAssertion(clientAssertion.assertion);
                parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
              }
              parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
              parameterBuilder.addClientInfo();
              if (!(request2.authenticationScheme === AuthenticationScheme.POP)) return [3, 2];
              popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request2.correlationId);
              return [4, popTokenGenerator.generateCnf(request2)];
            case 1:
              reqCnfData = _d.sent();
              parameterBuilder.addPopToken(reqCnfData.reqCnfString);
              return [3, 3];
            case 2:
              if (request2.authenticationScheme === AuthenticationScheme.SSH) {
                if (request2.sshJwk) {
                  parameterBuilder.addSshJwk(request2.sshJwk);
                } else {
                  throw ClientConfigurationError.createMissingSshJwkError();
                }
              }
              _d.label = 3;
            case 3:
              correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
              parameterBuilder.addCorrelationId(correlationId);
              if (!StringUtils.isEmptyObj(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
              }
              ccsCred = void 0;
              if (request2.clientInfo) {
                try {
                  clientInfo = buildClientInfo(request2.clientInfo, this.cryptoUtils);
                  ccsCred = {
                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                    type: CcsCredentialType.HOME_ACCOUNT_ID
                  };
                } catch (e) {
                  this.logger.verbose("Could not parse client info for CCS Header: " + e);
                }
              } else {
                ccsCred = request2.ccsCredential;
              }
              if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
                switch (ccsCred.type) {
                  case CcsCredentialType.HOME_ACCOUNT_ID:
                    try {
                      clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                      parameterBuilder.addCcsOid(clientInfo);
                    } catch (e) {
                      this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                    }
                    break;
                  case CcsCredentialType.UPN:
                    parameterBuilder.addCcsUpn(ccsCred.credential);
                    break;
                }
              }
              if (request2.tokenBodyParameters) {
                parameterBuilder.addExtraQueryParameters(request2.tokenBodyParameters);
              }
              if (request2.enableSpaAuthorizationCode && (!request2.tokenBodyParameters || !request2.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
                parameterBuilder.addExtraQueryParameters((_c = {}, _c[AADServerParamKeys.RETURN_SPA_CODE] = "1", _c));
              }
              return [2, parameterBuilder.createQueryString()];
          }
        });
      });
    };
    AuthorizationCodeClient2.prototype.createAuthCodeUrlQueryString = function(request2) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request2.correlationId);
              parameterBuilder = new RequestParameterBuilder();
              parameterBuilder.addClientId(this.config.authOptions.clientId);
              requestScopes = __spreadArrays(request2.scopes || [], request2.extraScopesToConsent || []);
              parameterBuilder.addScopes(requestScopes);
              parameterBuilder.addRedirectUri(request2.redirectUri);
              correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
              parameterBuilder.addCorrelationId(correlationId);
              parameterBuilder.addResponseMode(request2.responseMode);
              parameterBuilder.addResponseTypeCode();
              parameterBuilder.addLibraryInfo(this.config.libraryInfo);
              parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
              parameterBuilder.addClientInfo();
              if (request2.codeChallenge && request2.codeChallengeMethod) {
                parameterBuilder.addCodeChallengeParams(request2.codeChallenge, request2.codeChallengeMethod);
              }
              if (request2.prompt) {
                parameterBuilder.addPrompt(request2.prompt);
              }
              if (request2.domainHint) {
                parameterBuilder.addDomainHint(request2.domainHint);
              }
              if (request2.prompt !== PromptValue.SELECT_ACCOUNT) {
                if (request2.sid && request2.prompt === PromptValue.NONE) {
                  this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
                  parameterBuilder.addSid(request2.sid);
                } else if (request2.account) {
                  accountSid = this.extractAccountSid(request2.account);
                  accountLoginHintClaim = this.extractLoginHint(request2.account);
                  if (accountLoginHintClaim) {
                    this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
                    parameterBuilder.addLoginHint(accountLoginHintClaim);
                    try {
                      clientInfo = buildClientInfoFromHomeAccountId(request2.account.homeAccountId);
                      parameterBuilder.addCcsOid(clientInfo);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  } else if (accountSid && request2.prompt === PromptValue.NONE) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
                    parameterBuilder.addSid(accountSid);
                    try {
                      clientInfo = buildClientInfoFromHomeAccountId(request2.account.homeAccountId);
                      parameterBuilder.addCcsOid(clientInfo);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  } else if (request2.loginHint) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
                    parameterBuilder.addLoginHint(request2.loginHint);
                    parameterBuilder.addCcsUpn(request2.loginHint);
                  } else if (request2.account.username) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
                    parameterBuilder.addLoginHint(request2.account.username);
                    try {
                      clientInfo = buildClientInfoFromHomeAccountId(request2.account.homeAccountId);
                      parameterBuilder.addCcsOid(clientInfo);
                    } catch (e) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                    }
                  }
                } else if (request2.loginHint) {
                  this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
                  parameterBuilder.addLoginHint(request2.loginHint);
                  parameterBuilder.addCcsUpn(request2.loginHint);
                }
              } else {
                this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
              }
              if (request2.nonce) {
                parameterBuilder.addNonce(request2.nonce);
              }
              if (request2.state) {
                parameterBuilder.addState(request2.state);
              }
              if (!StringUtils.isEmpty(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
              }
              if (request2.extraQueryParameters) {
                parameterBuilder.addExtraQueryParameters(request2.extraQueryParameters);
              }
              if (!request2.nativeBroker) return [3, 2];
              parameterBuilder.addNativeBroker();
              if (!(request2.authenticationScheme === AuthenticationScheme.POP)) return [3, 2];
              popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
              return [4, popTokenGenerator.generateCnf(request2)];
            case 1:
              reqCnfData = _b2.sent();
              parameterBuilder.addPopToken(reqCnfData.reqCnfString);
              _b2.label = 2;
            case 2:
              return [2, parameterBuilder.createQueryString()];
          }
        });
      });
    };
    AuthorizationCodeClient2.prototype.createLogoutUrlQueryString = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      if (request2.postLogoutRedirectUri) {
        parameterBuilder.addPostLogoutRedirectUri(request2.postLogoutRedirectUri);
      }
      if (request2.correlationId) {
        parameterBuilder.addCorrelationId(request2.correlationId);
      }
      if (request2.idTokenHint) {
        parameterBuilder.addIdTokenHint(request2.idTokenHint);
      }
      if (request2.state) {
        parameterBuilder.addState(request2.state);
      }
      if (request2.logoutHint) {
        parameterBuilder.addLogoutHint(request2.logoutHint);
      }
      if (request2.extraQueryParameters) {
        parameterBuilder.addExtraQueryParameters(request2.extraQueryParameters);
      }
      return parameterBuilder.createQueryString();
    };
    AuthorizationCodeClient2.prototype.extractAccountSid = function(account) {
      var _a2;
      return ((_a2 = account.idTokenClaims) === null || _a2 === void 0 ? void 0 : _a2.sid) || null;
    };
    AuthorizationCodeClient2.prototype.extractLoginHint = function(account) {
      var _a2;
      return ((_a2 = account.idTokenClaims) === null || _a2 === void 0 ? void 0 : _a2.login_hint) || null;
    };
    return AuthorizationCodeClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var DeviceCodeClient = (
  /** @class */
  function(_super) {
    __extends(DeviceCodeClient2, _super);
    function DeviceCodeClient2(configuration) {
      return _super.call(this, configuration) || this;
    }
    DeviceCodeClient2.prototype.acquireToken = function(request2) {
      return __awaiter(this, void 0, void 0, function() {
        var deviceCodeResponse, reqTimestamp, response, responseHandler;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.getDeviceCode(request2)];
            case 1:
              deviceCodeResponse = _a2.sent();
              request2.deviceCodeCallback(deviceCodeResponse);
              reqTimestamp = TimeUtils.nowSeconds();
              return [4, this.acquireTokenWithDeviceCode(request2, deviceCodeResponse)];
            case 2:
              response = _a2.sent();
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
              responseHandler.validateTokenResponse(response);
              return [4, responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request2)];
            case 3:
              return [2, _a2.sent()];
          }
        });
      });
    };
    DeviceCodeClient2.prototype.getDeviceCode = function(request2) {
      return __awaiter(this, void 0, void 0, function() {
        var queryParametersString, endpoint, queryString, headers, thumbprint;
        return __generator(this, function(_a2) {
          queryParametersString = this.createExtraQueryParameters(request2);
          endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);
          queryString = this.createQueryString(request2);
          headers = this.createTokenRequestHeaders();
          thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request2.authority,
            scopes: request2.scopes,
            claims: request2.claims,
            authenticationScheme: request2.authenticationScheme,
            resourceRequestMethod: request2.resourceRequestMethod,
            resourceRequestUri: request2.resourceRequestUri,
            shrClaims: request2.shrClaims,
            sshKid: request2.sshKid
          };
          return [2, this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint)];
        });
      });
    };
    DeviceCodeClient2.prototype.createExtraQueryParameters = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      if (request2.extraQueryParameters) {
        parameterBuilder.addExtraQueryParameters(request2.extraQueryParameters);
      }
      return parameterBuilder.createQueryString();
    };
    DeviceCodeClient2.prototype.executePostRequestToDeviceCodeEndpoint = function(deviceCodeEndpoint, queryString, headers, thumbprint) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, userCode, deviceCode, verificationUri, expiresIn, interval, message2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              return [4, this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
                body: queryString,
                headers
              })];
            case 1:
              _a2 = _b2.sent().body, userCode = _a2.user_code, deviceCode = _a2.device_code, verificationUri = _a2.verification_uri, expiresIn = _a2.expires_in, interval = _a2.interval, message2 = _a2.message;
              return [2, {
                userCode,
                deviceCode,
                verificationUri,
                expiresIn,
                interval,
                message: message2
              }];
          }
        });
      });
    };
    DeviceCodeClient2.prototype.createQueryString = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      parameterBuilder.addScopes(request2.scopes);
      parameterBuilder.addClientId(this.config.authOptions.clientId);
      if (request2.extraQueryParameters) {
        parameterBuilder.addExtraQueryParameters(request2.extraQueryParameters);
      }
      if (!StringUtils.isEmpty(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
      }
      return parameterBuilder.createQueryString();
    };
    DeviceCodeClient2.prototype.continuePolling = function(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
      if (userSpecifiedCancelFlag) {
        this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
        throw ClientAuthError.createDeviceCodeCancelledError();
      } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {
        this.logger.error("User defined timeout for device code polling reached. The timeout was set for " + userSpecifiedTimeout);
        throw ClientAuthError.createUserTimeoutReachedError();
      } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {
        if (userSpecifiedTimeout) {
          this.logger.verbose("User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for " + userSpecifiedTimeout);
        }
        this.logger.error("Device code expired. Expiration time of device code was " + deviceCodeExpirationTime);
        throw ClientAuthError.createDeviceCodeExpiredError();
      }
      return true;
    };
    DeviceCodeClient2.prototype.acquireTokenWithDeviceCode = function(request2, deviceCodeResponse) {
      return __awaiter(this, void 0, void 0, function() {
        var queryParametersString, endpoint, requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParametersString = this.createTokenQueryParameters(request2);
              endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);
              requestBody = this.createTokenRequestBody(request2, deviceCodeResponse);
              headers = this.createTokenRequestHeaders();
              userSpecifiedTimeout = request2.timeout ? TimeUtils.nowSeconds() + request2.timeout : void 0;
              deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;
              pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
              _a2.label = 1;
            case 1:
              if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request2.cancel)) return [3, 8];
              thumbprint = {
                clientId: this.config.authOptions.clientId,
                authority: request2.authority,
                scopes: request2.scopes,
                claims: request2.claims,
                authenticationScheme: request2.authenticationScheme,
                resourceRequestMethod: request2.resourceRequestMethod,
                resourceRequestUri: request2.resourceRequestUri,
                shrClaims: request2.shrClaims,
                sshKid: request2.sshKid
              };
              return [4, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
            case 2:
              response = _a2.sent();
              if (!(response.body && response.body.error)) return [3, 6];
              if (!(response.body.error === Constants$1.AUTHORIZATION_PENDING)) return [3, 4];
              this.logger.info("Authorization pending. Continue polling.");
              return [4, TimeUtils.delay(pollingIntervalMilli)];
            case 3:
              _a2.sent();
              return [3, 5];
            case 4:
              this.logger.info("Unexpected error in polling from the server");
              throw ServerError.createPostRequestFailed(response.body.error);
            case 5:
              return [3, 7];
            case 6:
              this.logger.verbose("Authorization completed successfully. Polling stopped.");
              return [2, response.body];
            case 7:
              return [3, 1];
            case 8:
              this.logger.error("Polling stopped for unknown reasons.");
              throw ClientAuthError.createDeviceCodeUnknownError();
          }
        });
      });
    };
    DeviceCodeClient2.prototype.createTokenRequestBody = function(request2, deviceCodeResponse) {
      var requestParameters = new RequestParameterBuilder();
      requestParameters.addScopes(request2.scopes);
      requestParameters.addClientId(this.config.authOptions.clientId);
      requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
      requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
      var correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
      requestParameters.addCorrelationId(correlationId);
      requestParameters.addClientInfo();
      requestParameters.addLibraryInfo(this.config.libraryInfo);
      requestParameters.addApplicationTelemetry(this.config.telemetry.application);
      requestParameters.addThrottling();
      if (this.serverTelemetryManager) {
        requestParameters.addServerTelemetry(this.serverTelemetryManager);
      }
      if (!StringUtils.isEmptyObj(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        requestParameters.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
      }
      return requestParameters.createQueryString();
    };
    return DeviceCodeClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var RefreshTokenClient = (
  /** @class */
  function(_super) {
    __extends(RefreshTokenClient2, _super);
    function RefreshTokenClient2(configuration, performanceClient) {
      return _super.call(this, configuration, performanceClient) || this;
    }
    RefreshTokenClient2.prototype.acquireToken = function(request2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      return __awaiter(this, void 0, void 0, function() {
        var atsMeasurement, reqTimestamp, response, httpVerToken, requestId, responseHandler;
        var _this = this;
        return __generator(this, function(_h) {
          switch (_h.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request2.correlationId);
              atsMeasurement = (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request2.correlationId);
              this.logger.verbose("RefreshTokenClientAcquireToken called", request2.correlationId);
              reqTimestamp = TimeUtils.nowSeconds();
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request2.correlationId);
              return [4, this.executeTokenRequest(request2, this.authority)];
            case 1:
              response = _h.sent();
              httpVerToken = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_HTTP_VERSION];
              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
                refreshTokenSize: ((_e = response.body.refresh_token) === null || _e === void 0 ? void 0 : _e.length) || 0
              });
              if (httpVerToken) {
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
                  httpVerToken
                });
              }
              requestId = (_f = response.headers) === null || _f === void 0 ? void 0 : _f[HeaderNames.X_MS_REQUEST_ID];
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
              responseHandler.validateTokenResponse(response.body);
              (_g = this.performanceClient) === null || _g === void 0 ? void 0 : _g.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request2.correlationId);
              return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request2, void 0, void 0, true, request2.forceCache, requestId).then(function(result) {
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                  success: true
                });
                return result;
              }).catch(function(error2) {
                _this.logger.verbose("Error in fetching refresh token", request2.correlationId);
                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                  errorCode: error2.errorCode,
                  subErrorCode: error2.subError,
                  success: false
                });
                throw error2;
              })];
          }
        });
      });
    };
    RefreshTokenClient2.prototype.acquireTokenByRefreshToken = function(request2) {
      var _a2, _b2, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
        return __generator(this, function(_e) {
          if (!request2) {
            throw ClientConfigurationError.createEmptyTokenRequestError();
          }
          (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request2.correlationId);
          if (!request2.account) {
            throw ClientAuthError.createNoAccountInSilentRequestError();
          }
          isFOCI = this.cacheManager.isAppMetadataFOCI(request2.account.environment);
          if (isFOCI) {
            try {
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request2.correlationId);
              return [2, this.acquireTokenWithCachedRefreshToken(request2, true)];
            } catch (e) {
              noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
              clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
              if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
                (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request2.correlationId);
                return [2, this.acquireTokenWithCachedRefreshToken(request2, false)];
              } else {
                throw e;
              }
            }
          }
          (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request2.correlationId);
          return [2, this.acquireTokenWithCachedRefreshToken(request2, false)];
        });
      });
    };
    RefreshTokenClient2.prototype.acquireTokenWithCachedRefreshToken = function(request2, foci) {
      var _a2, _b2, _c;
      return __awaiter(this, void 0, void 0, function() {
        var atsMeasurement, refreshToken, refreshTokenRequest;
        return __generator(this, function(_d) {
          (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request2.correlationId);
          atsMeasurement = (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request2.correlationId);
          this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", request2.correlationId);
          refreshToken = this.cacheManager.getRefreshToken(request2.account, foci);
          if (!refreshToken) {
            atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.discardMeasurement();
            throw InteractionRequiredAuthError.createNoTokensFoundError();
          }
          atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
            success: true
          });
          refreshTokenRequest = __assign(__assign({}, request2), { refreshToken: refreshToken.secret, authenticationScheme: request2.authenticationScheme || AuthenticationScheme.BEARER, ccsCredential: {
            credential: request2.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          } });
          (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireToken, request2.correlationId);
          return [2, this.acquireToken(refreshTokenRequest)];
        });
      });
    };
    RefreshTokenClient2.prototype.executeTokenRequest = function(request2, authority) {
      var _a2, _b2, _c;
      return __awaiter(this, void 0, void 0, function() {
        var acquireTokenMeasurement, queryParametersString, endpoint, requestBody, headers, thumbprint;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request2.correlationId);
              acquireTokenMeasurement = (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request2.correlationId);
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request2.correlationId);
              queryParametersString = this.createTokenQueryParameters(request2);
              endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
              return [4, this.createTokenRequestBody(request2)];
            case 1:
              requestBody = _d.sent();
              headers = this.createTokenRequestHeaders(request2.ccsCredential);
              thumbprint = {
                clientId: this.config.authOptions.clientId,
                authority: authority.canonicalAuthority,
                scopes: request2.scopes,
                claims: request2.claims,
                authenticationScheme: request2.authenticationScheme,
                resourceRequestMethod: request2.resourceRequestMethod,
                resourceRequestUri: request2.resourceRequestUri,
                shrClaims: request2.shrClaims,
                sshKid: request2.sshKid
              };
              return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint).then(function(result) {
                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                  success: true
                });
                return result;
              }).catch(function(error2) {
                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                  success: false
                });
                throw error2;
              })];
          }
        });
      });
    };
    RefreshTokenClient2.prototype.createTokenRequestBody = function(request2) {
      var _a2, _b2, _c;
      return __awaiter(this, void 0, void 0, function() {
        var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request2.correlationId);
              correlationId = request2.correlationId;
              acquireTokenMeasurement = (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
              parameterBuilder = new RequestParameterBuilder();
              parameterBuilder.addClientId(this.config.authOptions.clientId);
              parameterBuilder.addScopes(request2.scopes);
              parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
              parameterBuilder.addClientInfo();
              parameterBuilder.addLibraryInfo(this.config.libraryInfo);
              parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
              parameterBuilder.addThrottling();
              if (this.serverTelemetryManager) {
                parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
              }
              parameterBuilder.addCorrelationId(correlationId);
              parameterBuilder.addRefreshToken(request2.refreshToken);
              if (this.config.clientCredentials.clientSecret) {
                parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
              }
              if (this.config.clientCredentials.clientAssertion) {
                clientAssertion = this.config.clientCredentials.clientAssertion;
                parameterBuilder.addClientAssertion(clientAssertion.assertion);
                parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
              }
              if (!(request2.authenticationScheme === AuthenticationScheme.POP)) return [3, 2];
              popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request2.correlationId);
              return [4, popTokenGenerator.generateCnf(request2)];
            case 1:
              reqCnfData = _d.sent();
              parameterBuilder.addPopToken(reqCnfData.reqCnfString);
              return [3, 3];
            case 2:
              if (request2.authenticationScheme === AuthenticationScheme.SSH) {
                if (request2.sshJwk) {
                  parameterBuilder.addSshJwk(request2.sshJwk);
                } else {
                  acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                    success: false
                  });
                  throw ClientConfigurationError.createMissingSshJwkError();
                }
              }
              _d.label = 3;
            case 3:
              if (!StringUtils.isEmptyObj(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
              }
              if (this.config.systemOptions.preventCorsPreflight && request2.ccsCredential) {
                switch (request2.ccsCredential.type) {
                  case CcsCredentialType.HOME_ACCOUNT_ID:
                    try {
                      clientInfo = buildClientInfoFromHomeAccountId(request2.ccsCredential.credential);
                      parameterBuilder.addCcsOid(clientInfo);
                    } catch (e) {
                      this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                    }
                    break;
                  case CcsCredentialType.UPN:
                    parameterBuilder.addCcsUpn(request2.ccsCredential.credential);
                    break;
                }
              }
              acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                success: true
              });
              return [2, parameterBuilder.createQueryString()];
          }
        });
      });
    };
    return RefreshTokenClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ClientCredentialClient = (
  /** @class */
  function(_super) {
    __extends(ClientCredentialClient2, _super);
    function ClientCredentialClient2(configuration, appTokenProvider) {
      var _this = _super.call(this, configuration) || this;
      _this.appTokenProvider = appTokenProvider;
      return _this;
    }
    ClientCredentialClient2.prototype.acquireToken = function(request2) {
      return __awaiter(this, void 0, void 0, function() {
        var cachedAuthenticationResult;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.scopeSet = new ScopeSet(request2.scopes || []);
              if (!request2.skipCache) return [3, 2];
              return [4, this.executeTokenRequest(request2, this.authority)];
            case 1:
              return [2, _a2.sent()];
            case 2:
              return [4, this.getCachedAuthenticationResult(request2)];
            case 3:
              cachedAuthenticationResult = _a2.sent();
              if (!cachedAuthenticationResult) return [3, 4];
              return [2, cachedAuthenticationResult];
            case 4:
              return [4, this.executeTokenRequest(request2, this.authority)];
            case 5:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ClientCredentialClient2.prototype.getCachedAuthenticationResult = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var cachedAccessToken;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              cachedAccessToken = this.readAccessTokenFromCache();
              if (!cachedAccessToken) {
                (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                return [2, null];
              }
              if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                (_b2 = this.serverTelemetryManager) === null || _b2 === void 0 ? void 0 : _b2.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                return [2, null];
              }
              return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                account: null,
                idToken: null,
                accessToken: cachedAccessToken,
                refreshToken: null,
                appMetadata: null
              }, true, request2)];
            case 1:
              return [2, _c.sent()];
          }
        });
      });
    };
    ClientCredentialClient2.prototype.readAccessTokenFromCache = function() {
      var accessTokenFilter = {
        homeAccountId: Constants$1.EMPTY_STRING,
        environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
        credentialType: CredentialType.ACCESS_TOKEN,
        clientId: this.config.authOptions.clientId,
        realm: this.authority.tenant,
        target: ScopeSet.createSearchScopes(this.scopeSet.asArray())
      };
      var accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);
      if (accessTokens.length < 1) {
        return null;
      } else if (accessTokens.length > 1) {
        throw ClientAuthError.createMultipleMatchingTokensInCacheError();
      }
      return accessTokens[0];
    };
    ClientCredentialClient2.prototype.executeTokenRequest = function(request2, authority) {
      return __awaiter(this, void 0, void 0, function() {
        var serverTokenResponse, reqTimestamp, appTokenPropviderParameters, appTokenProviderResult, queryParametersString, endpoint, requestBody, headers, thumbprint, response, responseHandler, tokenResponse;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.appTokenProvider) return [3, 2];
              this.logger.info("Using appTokenProvider extensibility.");
              appTokenPropviderParameters = {
                correlationId: request2.correlationId,
                tenantId: this.config.authOptions.authority.tenant,
                scopes: request2.scopes,
                claims: request2.claims
              };
              reqTimestamp = TimeUtils.nowSeconds();
              return [4, this.appTokenProvider(appTokenPropviderParameters)];
            case 1:
              appTokenProviderResult = _a2.sent();
              serverTokenResponse = {
                access_token: appTokenProviderResult.accessToken,
                expires_in: appTokenProviderResult.expiresInSeconds,
                refresh_in: appTokenProviderResult.refreshInSeconds,
                token_type: AuthenticationScheme.BEARER
              };
              return [3, 4];
            case 2:
              queryParametersString = this.createTokenQueryParameters(request2);
              endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
              requestBody = this.createTokenRequestBody(request2);
              headers = this.createTokenRequestHeaders();
              thumbprint = {
                clientId: this.config.authOptions.clientId,
                authority: request2.authority,
                scopes: request2.scopes,
                claims: request2.claims,
                authenticationScheme: request2.authenticationScheme,
                resourceRequestMethod: request2.resourceRequestMethod,
                resourceRequestUri: request2.resourceRequestUri,
                shrClaims: request2.shrClaims,
                sshKid: request2.sshKid
              };
              reqTimestamp = TimeUtils.nowSeconds();
              return [4, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
            case 3:
              response = _a2.sent();
              serverTokenResponse = response.body;
              _a2.label = 4;
            case 4:
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
              responseHandler.validateTokenResponse(serverTokenResponse);
              return [4, responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request2)];
            case 5:
              tokenResponse = _a2.sent();
              return [2, tokenResponse];
          }
        });
      });
    };
    ClientCredentialClient2.prototype.createTokenRequestBody = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      parameterBuilder.addClientId(this.config.authOptions.clientId);
      parameterBuilder.addScopes(request2.scopes, false);
      parameterBuilder.addGrantType(GrantType.CLIENT_CREDENTIALS_GRANT);
      parameterBuilder.addLibraryInfo(this.config.libraryInfo);
      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
      parameterBuilder.addThrottling();
      if (this.serverTelemetryManager) {
        parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
      }
      var correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
      parameterBuilder.addCorrelationId(correlationId);
      if (this.config.clientCredentials.clientSecret) {
        parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
      }
      var clientAssertion = request2.clientAssertion || this.config.clientCredentials.clientAssertion;
      if (clientAssertion) {
        parameterBuilder.addClientAssertion(clientAssertion.assertion);
        parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
      }
      if (!StringUtils.isEmptyObj(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
      }
      return parameterBuilder.createQueryString();
    };
    return ClientCredentialClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var OnBehalfOfClient = (
  /** @class */
  function(_super) {
    __extends(OnBehalfOfClient2, _super);
    function OnBehalfOfClient2(configuration) {
      return _super.call(this, configuration) || this;
    }
    OnBehalfOfClient2.prototype.acquireToken = function(request2) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              this.scopeSet = new ScopeSet(request2.scopes || []);
              _a2 = this;
              return [4, this.cryptoUtils.hashString(request2.oboAssertion)];
            case 1:
              _a2.userAssertionHash = _b2.sent();
              if (!request2.skipCache) return [3, 3];
              return [4, this.executeTokenRequest(request2, this.authority, this.userAssertionHash)];
            case 2:
              return [2, _b2.sent()];
            case 3:
              _b2.trys.push([3, 5, , 7]);
              return [4, this.getCachedAuthenticationResult(request2)];
            case 4:
              return [2, _b2.sent()];
            case 5:
              _b2.sent();
              return [4, this.executeTokenRequest(request2, this.authority, this.userAssertionHash)];
            case 6:
              return [2, _b2.sent()];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    OnBehalfOfClient2.prototype.getCachedAuthenticationResult = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request2);
              if (!cachedAccessToken) {
                (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                throw ClientAuthError.createRefreshRequiredError();
              } else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                (_b2 = this.serverTelemetryManager) === null || _b2 === void 0 ? void 0 : _b2.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                this.logger.info("OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                throw ClientAuthError.createRefreshRequiredError();
              }
              cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);
              cachedAccount = null;
              if (cachedIdToken) {
                idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);
                localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;
                accountInfo = {
                  homeAccountId: cachedIdToken.homeAccountId,
                  environment: cachedIdToken.environment,
                  tenantId: cachedIdToken.realm,
                  username: Constants$1.EMPTY_STRING,
                  localAccountId: localAccountId || Constants$1.EMPTY_STRING
                };
                cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
              }
              if (this.config.serverTelemetryManager) {
                this.config.serverTelemetryManager.incrementCacheHits();
              }
              return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                account: cachedAccount,
                accessToken: cachedAccessToken,
                idToken: cachedIdToken,
                refreshToken: null,
                appMetadata: null
              }, true, request2, idTokenObject)];
            case 1:
              return [2, _c.sent()];
          }
        });
      });
    };
    OnBehalfOfClient2.prototype.readIdTokenFromCacheForOBO = function(atHomeAccountId) {
      var idTokenFilter = {
        homeAccountId: atHomeAccountId,
        environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
        credentialType: CredentialType.ID_TOKEN,
        clientId: this.config.authOptions.clientId,
        realm: this.authority.tenant
      };
      var idTokens = this.cacheManager.getIdTokensByFilter(idTokenFilter);
      if (idTokens.length < 1) {
        return null;
      }
      return idTokens[0];
    };
    OnBehalfOfClient2.prototype.readAccessTokenFromCacheForOBO = function(clientId, request2) {
      var authScheme = request2.authenticationScheme || AuthenticationScheme.BEARER;
      var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
      var accessTokenFilter = {
        credentialType,
        clientId,
        target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),
        tokenType: authScheme,
        keyId: request2.sshKid,
        requestedClaimsHash: request2.requestedClaimsHash,
        userAssertionHash: this.userAssertionHash
      };
      var accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);
      var numAccessTokens = accessTokens.length;
      if (numAccessTokens < 1) {
        return null;
      } else if (numAccessTokens > 1) {
        throw ClientAuthError.createMultipleMatchingTokensInCacheError();
      }
      return accessTokens[0];
    };
    OnBehalfOfClient2.prototype.executeTokenRequest = function(request2, authority, userAssertionHash) {
      return __awaiter(this, void 0, void 0, function() {
        var queryParametersString, endpoint, requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParametersString = this.createTokenQueryParameters(request2);
              endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
              requestBody = this.createTokenRequestBody(request2);
              headers = this.createTokenRequestHeaders();
              thumbprint = {
                clientId: this.config.authOptions.clientId,
                authority: request2.authority,
                scopes: request2.scopes,
                claims: request2.claims,
                authenticationScheme: request2.authenticationScheme,
                resourceRequestMethod: request2.resourceRequestMethod,
                resourceRequestUri: request2.resourceRequestUri,
                shrClaims: request2.shrClaims,
                sshKid: request2.sshKid
              };
              reqTimestamp = TimeUtils.nowSeconds();
              return [4, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
            case 1:
              response = _a2.sent();
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
              responseHandler.validateTokenResponse(response.body);
              return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request2, void 0, userAssertionHash)];
            case 2:
              tokenResponse = _a2.sent();
              return [2, tokenResponse];
          }
        });
      });
    };
    OnBehalfOfClient2.prototype.createTokenRequestBody = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      parameterBuilder.addClientId(this.config.authOptions.clientId);
      parameterBuilder.addScopes(request2.scopes);
      parameterBuilder.addGrantType(GrantType.JWT_BEARER);
      parameterBuilder.addClientInfo();
      parameterBuilder.addLibraryInfo(this.config.libraryInfo);
      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
      parameterBuilder.addThrottling();
      if (this.serverTelemetryManager) {
        parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
      }
      var correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
      parameterBuilder.addCorrelationId(correlationId);
      parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);
      parameterBuilder.addOboAssertion(request2.oboAssertion);
      if (this.config.clientCredentials.clientSecret) {
        parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
      }
      if (this.config.clientCredentials.clientAssertion) {
        var clientAssertion = this.config.clientCredentials.clientAssertion;
        parameterBuilder.addClientAssertion(clientAssertion.assertion);
        parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
      }
      if (request2.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
      }
      return parameterBuilder.createQueryString();
    };
    return OnBehalfOfClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var SilentFlowClient = (
  /** @class */
  function(_super) {
    __extends(SilentFlowClient2, _super);
    function SilentFlowClient2(configuration, performanceClient) {
      return _super.call(this, configuration, performanceClient) || this;
    }
    SilentFlowClient2.prototype.acquireToken = function(request2) {
      return __awaiter(this, void 0, void 0, function() {
        var e_1, refreshTokenClient;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, this.acquireCachedToken(request2)];
            case 1:
              return [2, _a2.sent()];
            case 2:
              e_1 = _a2.sent();
              if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
                refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
                return [2, refreshTokenClient.acquireTokenByRefreshToken(request2)];
              } else {
                throw e_1;
              }
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SilentFlowClient2.prototype.acquireCachedToken = function(request2) {
      var _a2, _b2, _c, _d, _e;
      return __awaiter(this, void 0, void 0, function() {
        var environment, cacheRecord;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              if (!request2) {
                throw ClientConfigurationError.createEmptyTokenRequestError();
              }
              if (request2.forceRefresh) {
                (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
                this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
                throw ClientAuthError.createRefreshRequiredError();
              } else if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request2.claims)) {
                (_b2 = this.serverTelemetryManager) === null || _b2 === void 0 ? void 0 : _b2.setCacheOutcome(CacheOutcome.CLAIMS_REQUESTED_CACHE_SKIPPED);
                this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.");
                throw ClientAuthError.createRefreshRequiredError();
              }
              if (!request2.account) {
                throw ClientAuthError.createNoAccountInSilentRequestError();
              }
              environment = request2.authority || this.authority.getPreferredCache();
              cacheRecord = this.cacheManager.readCacheRecord(request2.account, request2, environment);
              if (!cacheRecord.accessToken) {
                (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                throw ClientAuthError.createRefreshRequiredError();
              } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                throw ClientAuthError.createRefreshRequiredError();
              } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
                (_e = this.serverTelemetryManager) === null || _e === void 0 ? void 0 : _e.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
                this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
                throw ClientAuthError.createRefreshRequiredError();
              }
              if (this.config.serverTelemetryManager) {
                this.config.serverTelemetryManager.incrementCacheHits();
              }
              return [4, this.generateResultFromCacheRecord(cacheRecord, request2)];
            case 1:
              return [2, _f.sent()];
          }
        });
      });
    };
    SilentFlowClient2.prototype.generateResultFromCacheRecord = function(cacheRecord, request2) {
      return __awaiter(this, void 0, void 0, function() {
        var idTokenObj, authTime;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (cacheRecord.idToken) {
                idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
              }
              if (request2.maxAge || request2.maxAge === 0) {
                authTime = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.auth_time;
                if (!authTime) {
                  throw ClientAuthError.createAuthTimeNotFoundError();
                }
                AuthToken.checkMaxAge(authTime, request2.maxAge);
              }
              return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request2, idTokenObj)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return SilentFlowClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var UsernamePasswordClient = (
  /** @class */
  function(_super) {
    __extends(UsernamePasswordClient2, _super);
    function UsernamePasswordClient2(configuration) {
      return _super.call(this, configuration) || this;
    }
    UsernamePasswordClient2.prototype.acquireToken = function(request2) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var atsMeasurement, reqTimestamp, response, httpVerToken, responseHandler, tokenResponse;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              atsMeasurement = (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.startMeasurement("UsernamePasswordClientAcquireToken", request2.correlationId);
              this.logger.info("in acquireToken call in username-password client");
              reqTimestamp = TimeUtils.nowSeconds();
              return [4, this.executeTokenRequest(this.authority, request2)];
            case 1:
              response = _c.sent();
              httpVerToken = (_b2 = response.headers) === null || _b2 === void 0 ? void 0 : _b2[HeaderNames.X_MS_HTTP_VERSION];
              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
                httpVerToken
              });
              responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
              responseHandler.validateTokenResponse(response.body);
              tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request2);
              return [2, tokenResponse];
          }
        });
      });
    };
    UsernamePasswordClient2.prototype.executeTokenRequest = function(authority, request2) {
      return __awaiter(this, void 0, void 0, function() {
        var queryParametersString, endpoint, requestBody, headers, thumbprint;
        return __generator(this, function(_a2) {
          queryParametersString = this.createTokenQueryParameters(request2);
          endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
          requestBody = this.createTokenRequestBody(request2);
          headers = this.createTokenRequestHeaders({
            credential: request2.username,
            type: CcsCredentialType.UPN
          });
          thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: authority.canonicalAuthority,
            scopes: request2.scopes,
            claims: request2.claims,
            authenticationScheme: request2.authenticationScheme,
            resourceRequestMethod: request2.resourceRequestMethod,
            resourceRequestUri: request2.resourceRequestUri,
            shrClaims: request2.shrClaims,
            sshKid: request2.sshKid
          };
          return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
        });
      });
    };
    UsernamePasswordClient2.prototype.createTokenRequestBody = function(request2) {
      var parameterBuilder = new RequestParameterBuilder();
      parameterBuilder.addClientId(this.config.authOptions.clientId);
      parameterBuilder.addUsername(request2.username);
      parameterBuilder.addPassword(request2.password);
      parameterBuilder.addScopes(request2.scopes);
      parameterBuilder.addResponseTypeForTokenAndIdToken();
      parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
      parameterBuilder.addClientInfo();
      parameterBuilder.addLibraryInfo(this.config.libraryInfo);
      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
      parameterBuilder.addThrottling();
      if (this.serverTelemetryManager) {
        parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
      }
      var correlationId = request2.correlationId || this.config.cryptoInterface.createNewGuid();
      parameterBuilder.addCorrelationId(correlationId);
      if (this.config.clientCredentials.clientSecret) {
        parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
      }
      if (this.config.clientCredentials.clientAssertion) {
        var clientAssertion = this.config.clientCredentials.clientAssertion;
        parameterBuilder.addClientAssertion(clientAssertion.assertion);
        parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
      }
      if (!StringUtils.isEmptyObj(request2.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        parameterBuilder.addClaims(request2.claims, this.config.authOptions.clientCapabilities);
      }
      if (this.config.systemOptions.preventCorsPreflight && request2.username) {
        parameterBuilder.addCcsUpn(request2.username);
      }
      return parameterBuilder.createQueryString();
    };
    return UsernamePasswordClient2;
  }(BaseClient)
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
var rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
var EndpointMetadata = rawMetdataJSON.endpointMetadata;
var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ProtocolMode;
(function(ProtocolMode2) {
  ProtocolMode2["AAD"] = "AAD";
  ProtocolMode2["OIDC"] = "OIDC";
})(ProtocolMode || (ProtocolMode = {}));
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthorityMetadataEntity = (
  /** @class */
  function() {
    function AuthorityMetadataEntity2() {
      this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }
    AuthorityMetadataEntity2.prototype.updateCloudDiscoveryMetadata = function(metadata, fromNetwork) {
      this.aliases = metadata.aliases;
      this.preferred_cache = metadata.preferred_cache;
      this.preferred_network = metadata.preferred_network;
      this.aliasesFromNetwork = fromNetwork;
    };
    AuthorityMetadataEntity2.prototype.updateEndpointMetadata = function(metadata, fromNetwork) {
      this.authorization_endpoint = metadata.authorization_endpoint;
      this.token_endpoint = metadata.token_endpoint;
      this.end_session_endpoint = metadata.end_session_endpoint;
      this.issuer = metadata.issuer;
      this.endpointsFromNetwork = fromNetwork;
      this.jwks_uri = metadata.jwks_uri;
    };
    AuthorityMetadataEntity2.prototype.updateCanonicalAuthority = function(authority) {
      this.canonical_authority = authority;
    };
    AuthorityMetadataEntity2.prototype.resetExpiresAt = function() {
      this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    };
    AuthorityMetadataEntity2.prototype.isExpired = function() {
      return this.expiresAt <= TimeUtils.nowSeconds();
    };
    AuthorityMetadataEntity2.isAuthorityMetadataEntity = function(key2, entity) {
      if (!entity) {
        return false;
      }
      return key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
    };
    return AuthorityMetadataEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
}
/*! @azure/msal-common v13.3.1 2023-10-27 */
var RegionDiscovery = (
  /** @class */
  function() {
    function RegionDiscovery2(networkInterface, performanceClient, correlationId) {
      this.networkInterface = networkInterface;
      this.performanceClient = performanceClient;
      this.correlationId = correlationId;
    }
    RegionDiscovery2.prototype.detectRegion = function(environmentRegion, regionDiscoveryMetadata) {
      var _a2, _b2, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
              autodetectedRegionName = environmentRegion;
              if (!!autodetectedRegionName) return [3, 8];
              options = RegionDiscovery2.IMDS_OPTIONS;
              _e.label = 1;
            case 1:
              _e.trys.push([1, 6, , 7]);
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
              return [4, this.getRegionFromIMDS(Constants$1.IMDS_VERSION, options)];
            case 2:
              localIMDSVersionResponse = _e.sent();
              if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                autodetectedRegionName = localIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
              if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3, 5];
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
              return [4, this.getCurrentVersion(options)];
            case 3:
              currentIMDSVersion = _e.sent();
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return [2, null];
              }
              (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
              return [4, this.getRegionFromIMDS(currentIMDSVersion, options)];
            case 4:
              currentIMDSVersionResponse = _e.sent();
              if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
              _e.label = 5;
            case 5:
              return [3, 7];
            case 6:
              _e.sent();
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
              return [2, null];
            case 7:
              return [3, 9];
            case 8:
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
              _e.label = 9;
            case 9:
              if (!autodetectedRegionName) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
              }
              return [2, autodetectedRegionName || null];
          }
        });
      });
    };
    RegionDiscovery2.prototype.getRegionFromIMDS = function(version2, options) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b2) {
          (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
          return [2, this.networkInterface.sendGetRequestAsync(Constants$1.IMDS_ENDPOINT + "?api-version=" + version2 + "&format=text", options, Constants$1.IMDS_TIMEOUT)];
        });
      });
    };
    RegionDiscovery2.prototype.getCurrentVersion = function(options) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var response;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
              _b2.label = 1;
            case 1:
              _b2.trys.push([1, 3, , 4]);
              return [4, this.networkInterface.sendGetRequestAsync(Constants$1.IMDS_ENDPOINT + "?format=json", options)];
            case 2:
              response = _b2.sent();
              if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
                return [2, response.body["newest-versions"][0]];
              }
              return [2, null];
            case 3:
              _b2.sent();
              return [2, null];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    RegionDiscovery2.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
    return RegionDiscovery2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var Authority = (
  /** @class */
  function() {
    function Authority2(authority, networkInterface, cacheManager, authorityOptions, logger2, performanceClient, correlationId) {
      this.canonicalAuthority = authority;
      this._canonicalAuthority.validateAsUri();
      this.networkInterface = networkInterface;
      this.cacheManager = cacheManager;
      this.authorityOptions = authorityOptions;
      this.regionDiscoveryMetadata = { region_used: void 0, region_source: void 0, region_outcome: void 0 };
      this.logger = logger2;
      this.performanceClient = performanceClient;
      this.correlationId = correlationId;
      this.regionDiscovery = new RegionDiscovery(networkInterface, this.performanceClient, this.correlationId);
    }
    Authority2.prototype.getAuthorityType = function(authorityUri) {
      if (authorityUri.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
        return AuthorityType.Ciam;
      }
      var pathSegments = authorityUri.PathSegments;
      if (pathSegments.length) {
        switch (pathSegments[0].toLowerCase()) {
          case Constants$1.ADFS:
            return AuthorityType.Adfs;
          case Constants$1.DSTS:
            return AuthorityType.Dsts;
        }
      }
      return AuthorityType.Default;
    };
    Object.defineProperty(Authority2.prototype, "authorityType", {
      // See above for AuthorityType
      get: function() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "protocolMode", {
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get: function() {
        return this.authorityOptions.protocolMode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "options", {
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get: function() {
        return this.authorityOptions;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "canonicalAuthority", {
      /**
       * A URL that is the authority set by the developer
       */
      get: function() {
        return this._canonicalAuthority.urlString;
      },
      /**
       * Sets canonical authority.
       */
      set: function(url) {
        this._canonicalAuthority = new UrlString(url);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "canonicalAuthorityUrlComponents", {
      /**
       * Get authority components.
       */
      get: function() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "hostnameAndPort", {
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get: function() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "tenant", {
      /**
       * Get tenant for authority.
       */
      get: function() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "authorizationEndpoint", {
      /**
       * OAuth /authorize endpoint for requests
       */
      get: function() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "tokenEndpoint", {
      /**
       * OAuth /token endpoint for requests
       */
      get: function() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "deviceCodeEndpoint", {
      get: function() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "endSessionEndpoint", {
      /**
       * OAuth logout endpoint for requests
       */
      get: function() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw ClientAuthError.createLogoutNotSupportedError();
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "selfSignedJwtAudience", {
      /**
       * OAuth issuer for requests
       */
      get: function() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Authority2.prototype, "jwksUri", {
      /**
       * Jwks_uri for token signing keys
       */
      get: function() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      },
      enumerable: false,
      configurable: true
    });
    Authority2.prototype.canReplaceTenant = function(authorityUri) {
      return authorityUri.PathSegments.length === 1 && !Authority2.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode === ProtocolMode.AAD;
    };
    Authority2.prototype.replaceTenant = function(urlString) {
      return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
    };
    Authority2.prototype.replacePath = function(urlString) {
      var _this = this;
      var endpoint = urlString;
      var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
      var cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
      var cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
      var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
      currentAuthorityParts.forEach(function(currentPart, index) {
        var cachedPart = cachedAuthorityParts[index];
        if (index === 0 && _this.canReplaceTenant(cachedAuthorityUrlComponents)) {
          var tenantId = new UrlString(_this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
          if (cachedPart !== tenantId) {
            _this.logger.verbose("Replacing tenant domain name " + cachedPart + " with id " + tenantId);
            cachedPart = tenantId;
          }
        }
        if (currentPart !== cachedPart) {
          endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
        }
      });
      return this.replaceTenant(endpoint);
    };
    Object.defineProperty(Authority2.prototype, "defaultOpenIdConfigurationEndpoint", {
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get: function() {
        if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {
          return this.canonicalAuthority + ".well-known/openid-configuration";
        }
        return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
      },
      enumerable: false,
      configurable: true
    });
    Authority2.prototype.discoveryComplete = function() {
      return !!this.metadata;
    };
    Authority2.prototype.resolveEndpointsAsync = function() {
      var _a2, _b2, _c;
      return __awaiter(this, void 0, void 0, function() {
        var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
              metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
              if (!metadataEntity) {
                metadataEntity = new AuthorityMetadataEntity();
                metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
              }
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
              return [4, this.updateCloudDiscoveryMetadata(metadataEntity)];
            case 1:
              cloudDiscoverySource = _d.sent();
              this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
              return [4, this.updateEndpointMetadata(metadataEntity)];
            case 2:
              endpointSource = _d.sent();
              if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
                metadataEntity.resetExpiresAt();
                metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
              }
              cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
              this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
              this.metadata = metadataEntity;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Authority2.prototype.updateEndpointMetadata = function(metadataEntity) {
      var _a2, _b2, _c, _d, _e, _f;
      return __awaiter(this, void 0, void 0, function() {
        var metadata, harcodedMetadata;
        return __generator(this, function(_g) {
          switch (_g.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
              metadata = this.getEndpointMetadataFromConfig();
              if (metadata) {
                metadataEntity.updateEndpointMetadata(metadata, false);
                return [2, AuthorityMetadataSource.CONFIG];
              }
              if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
                return [2, AuthorityMetadataSource.CACHE];
              }
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
              return [4, this.getEndpointMetadataFromNetwork()];
            case 1:
              metadata = _g.sent();
              if (!metadata) return [3, 4];
              if (!((_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion)) return [3, 3];
              (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
              return [4, this.updateMetadataWithRegionalInformation(metadata)];
            case 2:
              metadata = _g.sent();
              _g.label = 3;
            case 3:
              metadataEntity.updateEndpointMetadata(metadata, true);
              return [2, AuthorityMetadataSource.NETWORK];
            case 4:
              harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
              if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3, 7];
              if (!((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion)) return [3, 6];
              (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
              return [4, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
            case 5:
              harcodedMetadata = _g.sent();
              _g.label = 6;
            case 6:
              metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
              return [2, AuthorityMetadataSource.HARDCODED_VALUES];
            case 7:
              throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
          }
        });
      });
    };
    Authority2.prototype.isAuthoritySameType = function(metadataEntity) {
      var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
      var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
      return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
    };
    Authority2.prototype.getEndpointMetadataFromConfig = function() {
      if (this.authorityOptions.authorityMetadata) {
        try {
          return JSON.parse(this.authorityOptions.authorityMetadata);
        } catch (e) {
          throw ClientConfigurationError.createInvalidAuthorityMetadataError();
        }
      }
      return null;
    };
    Authority2.prototype.getEndpointMetadataFromNetwork = function() {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var options, response;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
              options = {};
              _b2.label = 1;
            case 1:
              _b2.trys.push([1, 3, , 4]);
              return [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
            case 2:
              response = _b2.sent();
              return [2, isOpenIdConfigResponse(response.body) ? response.body : null];
            case 3:
              _b2.sent();
              return [2, null];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Authority2.prototype.getEndpointMetadataFromHardcodedValues = function() {
      if (this.canonicalAuthority in EndpointMetadata) {
        return EndpointMetadata[this.canonicalAuthority];
      }
      return null;
    };
    Authority2.prototype.updateMetadataWithRegionalInformation = function(metadata) {
      var _a2, _b2, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var userConfiguredAzureRegion, autodetectedRegionName;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
              userConfiguredAzureRegion = (_b2 = this.authorityOptions.azureRegionConfiguration) === null || _b2 === void 0 ? void 0 : _b2.azureRegion;
              if (!userConfiguredAzureRegion) return [3, 2];
              if (userConfiguredAzureRegion !== Constants$1.AZURE_REGION_AUTO_DISCOVER_FLAG) {
                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
                this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
                return [2, Authority2.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion)];
              }
              (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
              return [4, this.regionDiscovery.detectRegion((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.environmentRegion, this.regionDiscoveryMetadata)];
            case 1:
              autodetectedRegionName = _e.sent();
              if (autodetectedRegionName) {
                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
                this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
                return [2, Authority2.replaceWithRegionalInformation(metadata, autodetectedRegionName)];
              }
              this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
              _e.label = 2;
            case 2:
              return [2, metadata];
          }
        });
      });
    };
    Authority2.prototype.updateCloudDiscoveryMetadata = function(metadataEntity) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var metadata, metadataEntityExpired, harcodedMetadata;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
              this.logger.verbose("Attempting to get cloud discovery metadata in the config");
              this.logger.verbosePii("Known Authorities: " + (this.authorityOptions.knownAuthorities || Constants$1.NOT_APPLICABLE));
              this.logger.verbosePii("Authority Metadata: " + (this.authorityOptions.authorityMetadata || Constants$1.NOT_APPLICABLE));
              this.logger.verbosePii("Canonical Authority: " + (metadataEntity.canonical_authority || Constants$1.NOT_APPLICABLE));
              metadata = this.getCloudDiscoveryMetadataFromConfig();
              if (metadata) {
                this.logger.verbose("Found cloud discovery metadata in the config.");
                metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
                return [2, AuthorityMetadataSource.CONFIG];
              }
              this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache.");
              metadataEntityExpired = metadataEntity.isExpired();
              if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
                this.logger.verbose("Found metadata in the cache.");
                return [2, AuthorityMetadataSource.CACHE];
              } else if (metadataEntityExpired) {
                this.logger.verbose("The metadata entity is expired.");
              }
              this.logger.verbose("Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network.");
              (_b2 = this.performanceClient) === null || _b2 === void 0 ? void 0 : _b2.setPreQueueTime(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
              return [4, this.getCloudDiscoveryMetadataFromNetwork()];
            case 1:
              metadata = _c.sent();
              if (metadata) {
                this.logger.verbose("cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()");
                metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
                return [2, AuthorityMetadataSource.NETWORK];
              }
              this.logger.verbose("Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values.");
              harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
              if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
                this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
                metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
                return [2, AuthorityMetadataSource.HARDCODED_VALUES];
              }
              this.logger.error("Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error.");
              throw ClientConfigurationError.createUntrustedAuthorityError();
          }
        });
      });
    };
    Authority2.prototype.getCloudDiscoveryMetadataFromConfig = function() {
      if (this.authorityType === AuthorityType.Ciam) {
        this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
        return Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      }
      if (this.authorityOptions.cloudDiscoveryMetadata) {
        this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
        try {
          this.logger.verbose("Attempting to parse the cloud discovery metadata.");
          var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
          var metadata = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
          this.logger.verbose("Parsed the cloud discovery metadata.");
          if (metadata) {
            this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
            return metadata;
          } else {
            this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
          }
        } catch (e) {
          this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
          throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
        }
      }
      if (this.isInKnownAuthorities()) {
        this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
        return Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      }
      return null;
    };
    Authority2.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var instanceDiscoveryEndpoint, options, match, response, typedResponseBody, metadata, error_1, typedError;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
              instanceDiscoveryEndpoint = "" + Constants$1.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
              options = {};
              match = null;
              _b2.label = 1;
            case 1:
              _b2.trys.push([1, 3, , 4]);
              return [4, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
            case 2:
              response = _b2.sent();
              typedResponseBody = void 0;
              metadata = void 0;
              if (isCloudInstanceDiscoveryResponse(response.body)) {
                typedResponseBody = response.body;
                metadata = typedResponseBody.metadata;
                this.logger.verbosePii("tenant_discovery_endpoint is: " + typedResponseBody.tenant_discovery_endpoint);
              } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
                this.logger.warning("A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: " + response.status);
                typedResponseBody = response.body;
                if (typedResponseBody.error === Constants$1.INVALID_INSTANCE) {
                  this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
                  return [2, null];
                }
                this.logger.warning("The CloudInstanceDiscoveryErrorResponse error is " + typedResponseBody.error);
                this.logger.warning("The CloudInstanceDiscoveryErrorResponse error description is " + typedResponseBody.error_description);
                this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
                metadata = [];
              } else {
                this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
                return [2, null];
              }
              this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
              match = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
              return [3, 4];
            case 3:
              error_1 = _b2.sent();
              if (error_1 instanceof AuthError) {
                this.logger.error("There was a network error while attempting to get the cloud discovery instance metadata.\nError: " + error_1.errorCode + "\nError Description: " + error_1.errorMessage);
              } else {
                typedError = error_1;
                this.logger.error("A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: " + typedError.name + "\nError Description: " + typedError.message);
              }
              return [2, null];
            case 4:
              if (!match) {
                this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
                this.logger.verbose("Creating custom Authority for custom domain scenario.");
                match = Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
              }
              return [2, match];
          }
        });
      });
    };
    Authority2.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function() {
      if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
        return InstanceDiscoveryMetadata[this.canonicalAuthority];
      }
      return null;
    };
    Authority2.prototype.isInKnownAuthorities = function() {
      var _this = this;
      var matches = this.authorityOptions.knownAuthorities.filter(function(authority) {
        return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
      });
      return matches.length > 0;
    };
    Authority2.generateAuthority = function(authorityString, azureCloudOptions) {
      var authorityAzureCloudInstance;
      if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
        var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants$1.DEFAULT_COMMON_TENANT;
        authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
      }
      return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
    };
    Authority2.createCloudDiscoveryMetadataFromHost = function(host) {
      return {
        preferred_network: host,
        preferred_cache: host,
        aliases: [host]
      };
    };
    Authority2.getCloudDiscoveryMetadataFromNetworkResponse = function(response, authority) {
      for (var i = 0; i < response.length; i++) {
        var metadata = response[i];
        if (metadata.aliases.indexOf(authority) > -1) {
          return metadata;
        }
      }
      return null;
    };
    Authority2.prototype.getPreferredCache = function() {
      if (this.discoveryComplete()) {
        return this.metadata.preferred_cache;
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    };
    Authority2.prototype.isAlias = function(host) {
      return this.metadata.aliases.indexOf(host) > -1;
    };
    Authority2.isPublicCloudAuthority = function(host) {
      return Constants$1.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
    };
    Authority2.buildRegionalAuthorityString = function(host, region, queryString) {
      var authorityUrlInstance = new UrlString(host);
      authorityUrlInstance.validateAsUri();
      var authorityUrlParts = authorityUrlInstance.getUrlComponents();
      var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
      if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
        hostNameAndPort = region + "." + Constants$1.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
      }
      var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
      if (queryString)
        return url + "?" + queryString;
      return url;
    };
    Authority2.replaceWithRegionalInformation = function(metadata, azureRegion) {
      metadata.authorization_endpoint = Authority2.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
      metadata.token_endpoint = Authority2.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants$1.REGIONAL_AUTH_NON_MSI_QUERY_STRING);
      if (metadata.end_session_endpoint) {
        metadata.end_session_endpoint = Authority2.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
      }
      return metadata;
    };
    Authority2.transformCIAMAuthority = function(authority) {
      var ciamAuthority = authority.endsWith(Constants$1.FORWARD_SLASH) ? authority : "" + authority + Constants$1.FORWARD_SLASH;
      var authorityUrl = new UrlString(authority);
      var authorityUrlComponents = authorityUrl.getUrlComponents();
      if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
        var tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
        ciamAuthority = "" + ciamAuthority + tenantIdOrDomain + Constants$1.AAD_TENANT_DOMAIN_SUFFIX;
      }
      return ciamAuthority;
    };
    Authority2.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
    return Authority2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var AuthorityFactory = (
  /** @class */
  function() {
    function AuthorityFactory2() {
    }
    AuthorityFactory2.createDiscoveredInstance = function(authorityUri, networkClient, cacheManager, authorityOptions, logger2, performanceClient, correlationId) {
      return __awaiter(this, void 0, void 0, function() {
        var authorityUriFinal, acquireTokenAuthority, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              performanceClient === null || performanceClient === void 0 ? void 0 : performanceClient.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
              authorityUriFinal = Authority.transformCIAMAuthority(authorityUri);
              acquireTokenAuthority = AuthorityFactory2.createInstance(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger2, performanceClient, correlationId);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              performanceClient === null || performanceClient === void 0 ? void 0 : performanceClient.setPreQueueTime(PerformanceEvents.AuthorityResolveEndpointsAsync, correlationId);
              return [4, acquireTokenAuthority.resolveEndpointsAsync()];
            case 2:
              _a2.sent();
              return [2, acquireTokenAuthority];
            case 3:
              e_1 = _a2.sent();
              throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AuthorityFactory2.createInstance = function(authorityUrl, networkInterface, cacheManager, authorityOptions, logger2, performanceClient, correlationId) {
      if (StringUtils.isEmpty(authorityUrl)) {
        throw ClientConfigurationError.createUrlEmptyError();
      }
      return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, logger2, performanceClient, correlationId);
    };
    return AuthorityFactory2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ServerTelemetryEntity = (
  /** @class */
  function() {
    function ServerTelemetryEntity2() {
      this.failedRequests = [];
      this.errors = [];
      this.cacheHits = 0;
    }
    ServerTelemetryEntity2.isServerTelemetryEntity = function(key2, entity) {
      var validateKey = key2.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
      var validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
      }
      return validateKey && validateEntity;
    };
    return ServerTelemetryEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ThrottlingEntity = (
  /** @class */
  function() {
    function ThrottlingEntity2() {
    }
    ThrottlingEntity2.isThrottlingEntity = function(key2, entity) {
      var validateKey = false;
      if (key2) {
        validateKey = key2.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
      }
      var validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("throttleTime");
      }
      return validateKey && validateEntity;
    };
    return ThrottlingEntity2;
  }()
);
/*! @azure/msal-common v13.3.1 2023-10-27 */
var ServerTelemetryManager = (
  /** @class */
  function() {
    function ServerTelemetryManager2(telemetryRequest, cacheManager) {
      this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
      this.cacheManager = cacheManager;
      this.apiId = telemetryRequest.apiId;
      this.correlationId = telemetryRequest.correlationId;
      this.wrapperSKU = telemetryRequest.wrapperSKU || Constants$1.EMPTY_STRING;
      this.wrapperVer = telemetryRequest.wrapperVer || Constants$1.EMPTY_STRING;
      this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
    }
    ServerTelemetryManager2.prototype.generateCurrentRequestHeaderValue = function() {
      var request2 = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
      var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      var regionDiscoveryFields = this.getRegionDiscoveryFields();
      var requestWithRegionDiscoveryFields = [request2, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    };
    ServerTelemetryManager2.prototype.generateLastRequestHeaderValue = function() {
      var lastRequests = this.getLastRequests();
      var maxErrors = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
      var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      var errors2 = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      var errorCount = lastRequests.errors.length;
      var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
      var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors2, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    };
    ServerTelemetryManager2.prototype.cacheFailedRequest = function(error2) {
      var lastRequests = this.getLastRequests();
      if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
        lastRequests.failedRequests.shift();
        lastRequests.failedRequests.shift();
        lastRequests.errors.shift();
      }
      lastRequests.failedRequests.push(this.apiId, this.correlationId);
      if (!StringUtils.isEmpty(error2.subError)) {
        lastRequests.errors.push(error2.subError);
      } else if (!StringUtils.isEmpty(error2.errorCode)) {
        lastRequests.errors.push(error2.errorCode);
      } else if (!!error2 && error2.toString()) {
        lastRequests.errors.push(error2.toString());
      } else {
        lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
      }
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      return;
    };
    ServerTelemetryManager2.prototype.incrementCacheHits = function() {
      var lastRequests = this.getLastRequests();
      lastRequests.cacheHits += 1;
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      return lastRequests.cacheHits;
    };
    ServerTelemetryManager2.prototype.getLastRequests = function() {
      var initialValue = new ServerTelemetryEntity();
      var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
      return lastRequests || initialValue;
    };
    ServerTelemetryManager2.prototype.clearTelemetryCache = function() {
      var lastRequests = this.getLastRequests();
      var numErrorsFlushed = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
      var errorCount = lastRequests.errors.length;
      if (numErrorsFlushed === errorCount) {
        this.cacheManager.removeItem(this.telemetryCacheKey);
      } else {
        var serverTelemEntity = new ServerTelemetryEntity();
        serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2);
        serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
      }
    };
    ServerTelemetryManager2.maxErrorsToSend = function(serverTelemetryEntity) {
      var i;
      var maxErrors = 0;
      var dataSize = 0;
      var errorCount = serverTelemetryEntity.errors.length;
      for (i = 0; i < errorCount; i++) {
        var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants$1.EMPTY_STRING;
        var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants$1.EMPTY_STRING;
        var errorCode = serverTelemetryEntity.errors[i] || Constants$1.EMPTY_STRING;
        dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
        if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
          maxErrors += 1;
        } else {
          break;
        }
      }
      return maxErrors;
    };
    ServerTelemetryManager2.prototype.getRegionDiscoveryFields = function() {
      var regionDiscoveryFields = [];
      regionDiscoveryFields.push(this.regionUsed || Constants$1.EMPTY_STRING);
      regionDiscoveryFields.push(this.regionSource || Constants$1.EMPTY_STRING);
      regionDiscoveryFields.push(this.regionOutcome || Constants$1.EMPTY_STRING);
      return regionDiscoveryFields.join(",");
    };
    ServerTelemetryManager2.prototype.updateRegionDiscoveryMetadata = function(regionDiscoveryMetadata) {
      this.regionUsed = regionDiscoveryMetadata.region_used;
      this.regionSource = regionDiscoveryMetadata.region_source;
      this.regionOutcome = regionDiscoveryMetadata.region_outcome;
    };
    ServerTelemetryManager2.prototype.setCacheOutcome = function(cacheOutcome) {
      this.cacheOutcome = cacheOutcome;
    };
    return ServerTelemetryManager2;
  }()
);
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto$2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate$1(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return stringify(rnds);
}
var jws$3 = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module2, exports$1) {
    var buffer2 = require$$0$5;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var Buffer$8 = requireSafeBuffer().Buffer;
var Stream$2 = require$$0$4;
var util$4 = require$$1$2;
function DataStream$2(data) {
  this.buffer = null;
  this.writable = true;
  this.readable = true;
  if (!data) {
    this.buffer = Buffer$8.alloc(0);
    return this;
  }
  if (typeof data.pipe === "function") {
    this.buffer = Buffer$8.alloc(0);
    data.pipe(this);
    return this;
  }
  if (data.length || typeof data === "object") {
    this.buffer = data;
    this.writable = false;
    process.nextTick((function() {
      this.emit("end", data);
      this.readable = false;
      this.emit("close");
    }).bind(this));
    return this;
  }
  throw new TypeError("Unexpected data type (" + typeof data + ")");
}
util$4.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function write(data) {
  this.buffer = Buffer$8.concat([this.buffer, Buffer$8.from(data)]);
  this.emit("data", data);
};
DataStream$2.prototype.end = function end(data) {
  if (data)
    this.write(data);
  this.emit("end", data);
  this.emit("close");
  this.writable = false;
  this.readable = false;
};
var dataStream = DataStream$2;
function getParamSize(keySize) {
  var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
  return result;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(alg) {
  var paramBytes = paramBytesForAlg[alg];
  if (paramBytes) {
    return paramBytes;
  }
  throw new Error('Unknown algorithm "' + alg + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1;
var Buffer$7 = requireSafeBuffer().Buffer;
var getParamBytesForAlg = paramBytesForAlg_1;
var MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(signature) {
  if (Buffer$7.isBuffer(signature)) {
    return signature;
  } else if ("string" === typeof signature) {
    return Buffer$7.from(signature, "base64");
  }
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(signature, alg) {
  signature = signatureAsBuffer(signature);
  var paramBytes = getParamBytesForAlg(alg);
  var maxEncodedParamLength = paramBytes + 1;
  var inputLength = signature.length;
  var offset = 0;
  if (signature[offset++] !== ENCODED_TAG_SEQ) {
    throw new Error('Could not find expected "seq"');
  }
  var seqLength = signature[offset++];
  if (seqLength === (MAX_OCTET | 1)) {
    seqLength = signature[offset++];
  }
  if (inputLength - offset < seqLength) {
    throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
  }
  if (signature[offset++] !== ENCODED_TAG_INT) {
    throw new Error('Could not find expected "int" for "r"');
  }
  var rLength = signature[offset++];
  if (inputLength - offset - 2 < rLength) {
    throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
  }
  if (maxEncodedParamLength < rLength) {
    throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
  }
  var rOffset = offset;
  offset += rLength;
  if (signature[offset++] !== ENCODED_TAG_INT) {
    throw new Error('Could not find expected "int" for "s"');
  }
  var sLength = signature[offset++];
  if (inputLength - offset !== sLength) {
    throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
  }
  if (maxEncodedParamLength < sLength) {
    throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
  }
  var sOffset = offset;
  offset += sLength;
  if (offset !== inputLength) {
    throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
  }
  var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
  var dst = Buffer$7.allocUnsafe(rPadding + rLength + sPadding + sLength);
  for (offset = 0; offset < rPadding; ++offset) {
    dst[offset] = 0;
  }
  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
  offset = paramBytes;
  for (var o = offset; offset < o + sPadding; ++offset) {
    dst[offset] = 0;
  }
  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
  dst = dst.toString("base64");
  dst = base64Url(dst);
  return dst;
}
function countPadding(buf, start, stop) {
  var padding = 0;
  while (start + padding < stop && buf[start + padding] === 0) {
    ++padding;
  }
  var needsSign = buf[start + padding] >= MAX_OCTET;
  if (needsSign) {
    --padding;
  }
  return padding;
}
function joseToDer(signature, alg) {
  signature = signatureAsBuffer(signature);
  var paramBytes = getParamBytesForAlg(alg);
  var signatureBytes = signature.length;
  if (signatureBytes !== paramBytes * 2) {
    throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
  }
  var rPadding = countPadding(signature, 0, paramBytes);
  var sPadding = countPadding(signature, paramBytes, signature.length);
  var rLength = paramBytes - rPadding;
  var sLength = paramBytes - sPadding;
  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
  var shortLength = rsBytes < MAX_OCTET;
  var dst = Buffer$7.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
  var offset = 0;
  dst[offset++] = ENCODED_TAG_SEQ;
  if (shortLength) {
    dst[offset++] = rsBytes;
  } else {
    dst[offset++] = MAX_OCTET | 1;
    dst[offset++] = rsBytes & 255;
  }
  dst[offset++] = ENCODED_TAG_INT;
  dst[offset++] = rLength;
  if (rPadding < 0) {
    dst[offset++] = 0;
    offset += signature.copy(dst, offset, 0, paramBytes);
  } else {
    offset += signature.copy(dst, offset, rPadding, paramBytes);
  }
  dst[offset++] = ENCODED_TAG_INT;
  dst[offset++] = sLength;
  if (sPadding < 0) {
    dst[offset++] = 0;
    signature.copy(dst, offset, paramBytes);
  } else {
    signature.copy(dst, offset, paramBytes + sPadding);
  }
  return dst;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
};
var bufferEqualConstantTime;
var hasRequiredBufferEqualConstantTime;
function requireBufferEqualConstantTime() {
  if (hasRequiredBufferEqualConstantTime) return bufferEqualConstantTime;
  hasRequiredBufferEqualConstantTime = 1;
  var Buffer2 = require$$0$5.Buffer;
  var SlowBuffer = require$$0$5.SlowBuffer;
  bufferEqualConstantTime = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0; i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
  return bufferEqualConstantTime;
}
var Buffer$6 = requireSafeBuffer().Buffer;
var crypto$1 = crypto$2;
var formatEcdsa = ecdsaSigFormatter;
var util$3 = require$$1$2;
var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
var MSG_INVALID_SECRET = "secret must be a string or buffer";
var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
var supportsKeyObjects = typeof crypto$1.createPublicKey === "function";
if (supportsKeyObjects) {
  MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
  MSG_INVALID_SECRET += "or a KeyObject";
}
function checkIsPublicKey(key2) {
  if (Buffer$6.isBuffer(key2)) {
    return;
  }
  if (typeof key2 === "string") {
    return;
  }
  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key2 !== "object") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key2.type !== "string") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key2.asymmetricKeyType !== "string") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key2.export !== "function") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
}
function checkIsPrivateKey(key2) {
  if (Buffer$6.isBuffer(key2)) {
    return;
  }
  if (typeof key2 === "string") {
    return;
  }
  if (typeof key2 === "object") {
    return;
  }
  throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(key2) {
  if (Buffer$6.isBuffer(key2)) {
    return;
  }
  if (typeof key2 === "string") {
    return key2;
  }
  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (typeof key2 !== "object") {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (key2.type !== "secret") {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (typeof key2.export !== "function") {
    throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  var padding = 4 - base64url2.length % 4;
  if (padding !== 4) {
    for (var i = 0; i < padding; ++i) {
      base64url2 += "=";
    }
  }
  return base64url2.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(template) {
  var args = [].slice.call(arguments, 1);
  var errMsg = util$3.format.bind(util$3, template).apply(null, args);
  return new TypeError(errMsg);
}
function bufferOrString(obj2) {
  return Buffer$6.isBuffer(obj2) || typeof obj2 === "string";
}
function normalizeInput(thing) {
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}
function createHmacSigner(bits) {
  return function sign4(thing, secret) {
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto$1.createHmac("sha" + bits, secret);
    var sig = (hmac.update(thing), hmac.digest("base64"));
    return fromBase64(sig);
  };
}
var bufferEqual;
var timingSafeEqual = "timingSafeEqual" in crypto$1 ? function timingSafeEqual2(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return crypto$1.timingSafeEqual(a, b);
} : function timingSafeEqual3(a, b) {
  if (!bufferEqual) {
    bufferEqual = requireBufferEqualConstantTime();
  }
  return bufferEqual(a, b);
};
function createHmacVerifier(bits) {
  return function verify3(thing, signature, secret) {
    var computedSig = createHmacSigner(bits)(thing, secret);
    return timingSafeEqual(Buffer$6.from(signature), Buffer$6.from(computedSig));
  };
}
function createKeySigner(bits) {
  return function sign4(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto$1.createSign("RSA-SHA" + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
    return fromBase64(sig);
  };
}
function createKeyVerifier(bits) {
  return function verify3(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto$1.createVerify("RSA-SHA" + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature, "base64");
  };
}
function createPSSKeySigner(bits) {
  return function sign4(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto$1.createSign("RSA-SHA" + bits);
    var sig = (signer.update(thing), signer.sign({
      key: privateKey,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(sig);
  };
}
function createPSSKeyVerifier(bits) {
  return function verify3(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto$1.createVerify("RSA-SHA" + bits);
    verifier.update(thing);
    return verifier.verify({
      key: publicKey,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, signature, "base64");
  };
}
function createECDSASigner(bits) {
  var inner = createKeySigner(bits);
  return function sign4() {
    var signature = inner.apply(null, arguments);
    signature = formatEcdsa.derToJose(signature, "ES" + bits);
    return signature;
  };
}
function createECDSAVerifer(bits) {
  var inner = createKeyVerifier(bits);
  return function verify3(thing, signature, publicKey) {
    signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
    var result = inner(thing, signature, publicKey);
    return result;
  };
}
function createNoneSigner() {
  return function sign4() {
    return "";
  };
}
function createNoneVerifier() {
  return function verify3(thing, signature) {
    return signature === "";
  };
}
var jwa$2 = function jwa(algorithm) {
  var signerFactories = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  };
  var verifierFactories = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  };
  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!match)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match[1] || match[3]).toLowerCase();
  var bits = match[2];
  return {
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits)
  };
};
var Buffer$5 = require$$0$5.Buffer;
var tostring = function toString(obj2) {
  if (typeof obj2 === "string")
    return obj2;
  if (typeof obj2 === "number" || Buffer$5.isBuffer(obj2))
    return obj2.toString();
  return JSON.stringify(obj2);
};
var Buffer$4 = requireSafeBuffer().Buffer;
var DataStream$1 = dataStream;
var jwa$1 = jwa$2;
var Stream$1 = require$$0$4;
var toString$1 = tostring;
var util$2 = require$$1$2;
function base64url(string, encoding) {
  return Buffer$4.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(header, payload, encoding) {
  encoding = encoding || "utf8";
  var encodedHeader = base64url(toString$1(header), "binary");
  var encodedPayload = base64url(toString$1(payload), encoding);
  return util$2.format("%s.%s", encodedHeader, encodedPayload);
}
function jwsSign(opts) {
  var header = opts.header;
  var payload = opts.payload;
  var secretOrKey = opts.secret || opts.privateKey;
  var encoding = opts.encoding;
  var algo = jwa$1(header.alg);
  var securedInput = jwsSecuredInput(header, payload, encoding);
  var signature = algo.sign(securedInput, secretOrKey);
  return util$2.format("%s.%s", securedInput, signature);
}
function SignStream$1(opts) {
  var secret = opts.secret || opts.privateKey || opts.key;
  var secretStream = new DataStream$1(secret);
  this.readable = true;
  this.header = opts.header;
  this.encoding = opts.encoding;
  this.secret = this.privateKey = this.key = secretStream;
  this.payload = new DataStream$1(opts.payload);
  this.secret.once("close", (function() {
    if (!this.payload.writable && this.readable)
      this.sign();
  }).bind(this));
  this.payload.once("close", (function() {
    if (!this.secret.writable && this.readable)
      this.sign();
  }).bind(this));
}
util$2.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function sign() {
  try {
    var signature = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    this.emit("done", signature);
    this.emit("data", signature);
    this.emit("end");
    this.readable = false;
    return signature;
  } catch (e) {
    this.readable = false;
    this.emit("error", e);
    this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1;
var Buffer$3 = requireSafeBuffer().Buffer;
var DataStream = dataStream;
var jwa2 = jwa$2;
var Stream = require$$0$4;
var toString2 = tostring;
var util$1 = require$$1$2;
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$j(thing) {
  return Object.prototype.toString.call(thing) === "[object Object]";
}
function safeJsonParse(thing) {
  if (isObject$j(thing))
    return thing;
  try {
    return JSON.parse(thing);
  } catch (e) {
    return void 0;
  }
}
function headerFromJWS(jwsSig) {
  var encodedHeader = jwsSig.split(".", 1)[0];
  return safeJsonParse(Buffer$3.from(encodedHeader, "base64").toString("binary"));
}
function securedInputFromJWS(jwsSig) {
  return jwsSig.split(".", 2).join(".");
}
function signatureFromJWS(jwsSig) {
  return jwsSig.split(".")[2];
}
function payloadFromJWS(jwsSig, encoding) {
  encoding = encoding || "utf8";
  var payload = jwsSig.split(".")[1];
  return Buffer$3.from(payload, "base64").toString(encoding);
}
function isValidJws(string) {
  return JWS_REGEX.test(string) && !!headerFromJWS(string);
}
function jwsVerify(jwsSig, algorithm, secretOrKey) {
  if (!algorithm) {
    var err = new Error("Missing algorithm parameter for jws.verify");
    err.code = "MISSING_ALGORITHM";
    throw err;
  }
  jwsSig = toString2(jwsSig);
  var signature = signatureFromJWS(jwsSig);
  var securedInput = securedInputFromJWS(jwsSig);
  var algo = jwa2(algorithm);
  return algo.verify(securedInput, signature, secretOrKey);
}
function jwsDecode(jwsSig, opts) {
  opts = opts || {};
  jwsSig = toString2(jwsSig);
  if (!isValidJws(jwsSig))
    return null;
  var header = headerFromJWS(jwsSig);
  if (!header)
    return null;
  var payload = payloadFromJWS(jwsSig);
  if (header.typ === "JWT" || opts.json)
    payload = JSON.parse(payload, opts.encoding);
  return {
    header,
    payload,
    signature: signatureFromJWS(jwsSig)
  };
}
function VerifyStream$1(opts) {
  opts = opts || {};
  var secretOrKey = opts.secret || opts.publicKey || opts.key;
  var secretStream = new DataStream(secretOrKey);
  this.readable = true;
  this.algorithm = opts.algorithm;
  this.encoding = opts.encoding;
  this.secret = this.publicKey = this.key = secretStream;
  this.signature = new DataStream(opts.signature);
  this.secret.once("close", (function() {
    if (!this.signature.writable && this.readable)
      this.verify();
  }).bind(this));
  this.signature.once("close", (function() {
    if (!this.secret.writable && this.readable)
      this.verify();
  }).bind(this));
}
util$1.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function verify() {
  try {
    var valid2 = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
    var obj2 = jwsDecode(this.signature.buffer, this.encoding);
    this.emit("done", valid2, obj2);
    this.emit("data", valid2);
    this.emit("end");
    this.readable = false;
    return valid2;
  } catch (e) {
    this.readable = false;
    this.emit("error", e);
    this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1;
var SignStream = signStream;
var VerifyStream = verifyStream;
var ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function createSign(opts) {
  return new SignStream(opts);
};
jws$3.createVerify = function createVerify(opts) {
  return new VerifyStream(opts);
};
var jws$2 = jws$3;
var decode$1 = function(jwt, options) {
  options = options || {};
  var decoded = jws$2.decode(jwt, options);
  if (!decoded) {
    return null;
  }
  var payload = decoded.payload;
  if (typeof payload === "string") {
    try {
      var obj2 = JSON.parse(payload);
      if (obj2 !== null && typeof obj2 === "object") {
        payload = obj2;
      }
    } catch (e) {
    }
  }
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload,
      signature: decoded.signature
    };
  }
  return payload;
};
var JsonWebTokenError$3 = function(message2, error2) {
  Error.call(this, message2);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = "JsonWebTokenError";
  this.message = message2;
  if (error2) this.inner = error2;
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3;
var JsonWebTokenError$2 = JsonWebTokenError_1;
var NotBeforeError$1 = function(message2, date2) {
  JsonWebTokenError$2.call(this, message2);
  this.name = "NotBeforeError";
  this.date = date2;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1;
var JsonWebTokenError$1 = JsonWebTokenError_1;
var TokenExpiredError$1 = function(message2, expiredAt) {
  JsonWebTokenError$1.call(this, message2);
  this.name = "TokenExpiredError";
  this.expiredAt = expiredAt;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1;
var ms = requireMs();
var timespan$2 = function(time2, iat) {
  var timestamp = iat || Math.floor(Date.now() / 1e3);
  if (typeof time2 === "string") {
    var milliseconds = ms(time2);
    if (typeof milliseconds === "undefined") {
      return;
    }
    return Math.floor(timestamp + milliseconds / 1e3);
  } else if (typeof time2 === "number") {
    return timestamp + time2;
  } else {
    return;
  }
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$8 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$3 = debug$8;
(function(module2, exports$1) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1$3;
  exports$1 = module2.exports = {};
  const re2 = exports$1.re = [];
  const safeRe = exports$1.safeRe = [];
  const src2 = exports$1.src = [];
  const safeSrc = exports$1.safeSrc = [];
  const t2 = exports$1.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token2, max2] of safeRegexReplacements) {
      value = value.split(`${token2}*`).join(`${token2}{0,${max2}}`).split(`${token2}+`).join(`${token2}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name2, index, value);
    t2[name2] = index;
    src2[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports$1.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports$1.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports$1.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric$1 = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  if (typeof a === "number" && typeof b === "number") {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  const anum = numeric$1.test(a);
  const bnum = numeric$1.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$7 = debug_1$3;
const { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$7("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$7("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.major < other.major) {
      return -1;
    }
    if (this.major > other.major) {
      return 1;
    }
    if (this.minor < other.minor) {
      return -1;
    }
    if (this.minor > other.minor) {
      return 1;
    }
    if (this.patch < other.patch) {
      return -1;
    }
    if (this.patch > other.patch) {
      return 1;
    }
    return 0;
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$7("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$7("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base2 = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base2];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base2);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base2];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$4 = SemVer$d;
const SemVer$c = semver$4;
const parse$7 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$7;
const parse$6 = parse_1;
const valid$2 = (version2, options) => {
  const v = parse$6(version2, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$5 = parse_1;
const clean$1 = (version2, options) => {
  const s = parse$5(version2.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$4;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$4 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$4(version1, null, true);
  const v2 = parse$4(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$4;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$4;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$4;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$3 = parse_1;
const prerelease$1 = (version2, options) => {
  const parsed = parse$3(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$4;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$4;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$4;
const parse$2 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$2(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key2) {
    const value = this.map.get(key2);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key2);
      this.map.set(key2, value);
      return value;
    }
  }
  delete(key2) {
    return this.map.delete(key2);
  }
  set(key2, value) {
    const deleted = this.delete(key2);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key2, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range$1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range$1;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$1 = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$3;
  const SemVer3 = semver$4;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t2.BUILD], "");
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_2, M, m, p, pr) => {
      debug2("tilde", comp, _2, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_2, M, m, p, pr) => {
      debug2("caret", comp, _2, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed2 = set2[i].semver;
          if (allowed2.major === version2.major && allowed2.minor === version2.minor && allowed2.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$3;
  const SemVer3 = semver$4;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$4;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions2, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$4;
const Range$6 = requireRange();
const minSatisfying$1 = (versions2, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$4;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$4;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions2, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions2.sort((a, b) => compare$2(a, b, options));
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first) {
        first = version2;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set2.push([first, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$4;
const identifiers = identifiers$1;
const parse$1 = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$3 = {
  parse: parse$1,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$2 = semver$3;
var asymmetricKeyDetailsSupported = semver$2.satisfies(process.version, ">=15.7.0");
const semver$1 = semver$3;
var rsaPssKeyDetailsSupported = semver$1.satisfies(process.version, ">=16.9.0");
const ASYMMETRIC_KEY_DETAILS_SUPPORTED = asymmetricKeyDetailsSupported;
const RSA_PSS_KEY_DETAILS_SUPPORTED = rsaPssKeyDetailsSupported;
const allowedAlgorithmsForKeys = {
  "ec": ["ES256", "ES384", "ES512"],
  "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
  "rsa-pss": ["PS256", "PS384", "PS512"]
};
const allowedCurves = {
  ES256: "prime256v1",
  ES384: "secp384r1",
  ES512: "secp521r1"
};
var validateAsymmetricKey$2 = function(algorithm, key2) {
  if (!algorithm || !key2) return;
  const keyType = key2.asymmetricKeyType;
  if (!keyType) return;
  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
  if (!allowedAlgorithms) {
    throw new Error(`Unknown key type "${keyType}".`);
  }
  if (!allowedAlgorithms.includes(algorithm)) {
    throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
  }
  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
    switch (keyType) {
      case "ec":
        const keyCurve = key2.asymmetricKeyDetails.namedCurve;
        const allowedCurve = allowedCurves[algorithm];
        if (keyCurve !== allowedCurve) {
          throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
        }
        break;
      case "rsa-pss":
        if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
          const length = parseInt(algorithm.slice(-3), 10);
          const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key2.asymmetricKeyDetails;
          if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
            throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
          }
          if (saltLength !== void 0 && saltLength > length >> 3) {
            throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
          }
        }
        break;
    }
  }
};
var semver = semver$3;
var psSupported = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
const JsonWebTokenError = JsonWebTokenError_1;
const NotBeforeError = NotBeforeError_1;
const TokenExpiredError = TokenExpiredError_1;
const decode = decode$1;
const timespan$1 = timespan$2;
const validateAsymmetricKey$1 = validateAsymmetricKey$2;
const PS_SUPPORTED$1 = psSupported;
const jws$1 = jws$3;
const { KeyObject: KeyObject$1, createSecretKey: createSecretKey$1, createPublicKey } = crypto$2;
const PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
const EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
const RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
const HS_ALGS = ["HS256", "HS384", "HS512"];
if (PS_SUPPORTED$1) {
  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
}
var verify2 = function(jwtString, secretOrPublicKey, options, callback) {
  if (typeof options === "function" && !callback) {
    callback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  options = Object.assign({}, options);
  let done;
  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }
  if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
    return done(new JsonWebTokenError("clockTimestamp must be a number"));
  }
  if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
    return done(new JsonWebTokenError("nonce must be a non-empty string"));
  }
  if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
    return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
  }
  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!jwtString) {
    return done(new JsonWebTokenError("jwt must be provided"));
  }
  if (typeof jwtString !== "string") {
    return done(new JsonWebTokenError("jwt must be a string"));
  }
  const parts = jwtString.split(".");
  if (parts.length !== 3) {
    return done(new JsonWebTokenError("jwt malformed"));
  }
  let decodedToken;
  try {
    decodedToken = decode(jwtString, { complete: true });
  } catch (err) {
    return done(err);
  }
  if (!decodedToken) {
    return done(new JsonWebTokenError("invalid token"));
  }
  const header = decodedToken.header;
  let getSecret;
  if (typeof secretOrPublicKey === "function") {
    if (!callback) {
      return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    }
    getSecret = secretOrPublicKey;
  } else {
    getSecret = function(header2, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }
  return getSecret(header, function(err, secretOrPublicKey2) {
    if (err) {
      return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
    }
    const hasSignature = parts[2].trim() !== "";
    if (!hasSignature && secretOrPublicKey2) {
      return done(new JsonWebTokenError("jwt signature is required"));
    }
    if (hasSignature && !secretOrPublicKey2) {
      return done(new JsonWebTokenError("secret or public key must be provided"));
    }
    if (!hasSignature && !options.algorithms) {
      return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
    }
    if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject$1)) {
      try {
        secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
      } catch (_2) {
        try {
          secretOrPublicKey2 = createSecretKey$1(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
        } catch (_3) {
          return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
        }
      }
    }
    if (!options.algorithms) {
      if (secretOrPublicKey2.type === "secret") {
        options.algorithms = HS_ALGS;
      } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
        options.algorithms = RSA_KEY_ALGS;
      } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
        options.algorithms = EC_KEY_ALGS;
      } else {
        options.algorithms = PUB_KEY_ALGS;
      }
    }
    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
      return done(new JsonWebTokenError("invalid algorithm"));
    }
    if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
      return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
      return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey$1(header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
    }
    let valid2;
    try {
      valid2 = jws$1.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
    } catch (e) {
      return done(e);
    }
    if (!valid2) {
      return done(new JsonWebTokenError("invalid signature"));
    }
    const payload = decodedToken.payload;
    if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
      if (typeof payload.nbf !== "number") {
        return done(new JsonWebTokenError("invalid nbf value"));
      }
      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
        return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
      }
    }
    if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
      if (typeof payload.exp !== "number") {
        return done(new JsonWebTokenError("invalid exp value"));
      }
      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
      }
    }
    if (options.audience) {
      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
      const match = target.some(function(targetAudience) {
        return audiences.some(function(audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });
      if (!match) {
        return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
      }
    }
    if (options.issuer) {
      const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
      if (invalid_issuer) {
        return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
      }
    }
    if (options.subject) {
      if (payload.sub !== options.subject) {
        return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
      }
    }
    if (options.jwtid) {
      if (payload.jti !== options.jwtid) {
        return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
      }
    }
    if (options.nonce) {
      if (payload.nonce !== options.nonce) {
        return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
      }
    }
    if (options.maxAge) {
      if (typeof payload.iat !== "number") {
        return done(new JsonWebTokenError("iat required when maxAge is specified"));
      }
      const maxAgeTimestamp = timespan$1(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === "undefined") {
        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
      }
    }
    if (options.complete === true) {
      const signature = decodedToken.signature;
      return done(null, {
        header,
        payload,
        signature
      });
    }
    return done(null, payload);
  });
};
var INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER$1 = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = 0 / 0;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
var reTrim$2 = /^\s+|\s+$/g;
var reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$2 = /^0b[01]+$/i;
var reIsOctal$2 = /^0o[0-7]+$/i;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeParseInt$2 = parseInt;
function arrayMap(array, iteratee) {
  var index = -1, length = array ? array.length : 0, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + -1;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
function baseValues(object, props) {
  return arrayMap(props, function(key2) {
    return object[key2];
  });
}
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$1 = objectProto$6.hasOwnProperty;
var objectToString$6 = objectProto$6.toString;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(value, inherited) {
  var result = isArray$2(value) || isArguments$1(value) ? baseTimes(value.length, String) : [];
  var length = result.length, skipIndexes = !!length;
  for (var key2 in value) {
    if (hasOwnProperty$1.call(value, key2) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$1.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto2;
}
function includes$1(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger$2(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString$3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}
function isArguments$1(value) {
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString$6.call(value) == argsTag);
}
var isArray$2 = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function isArrayLikeObject(value) {
  return isObjectLike$6(value) && isArrayLike(value);
}
function isFunction$1(value) {
  var tag = isObject$i(value) ? objectToString$6.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isObject$i(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike$6(value) {
  return !!value && typeof value == "object";
}
function isString$3(value) {
  return typeof value == "string" || !isArray$2(value) && isObjectLike$6(value) && objectToString$6.call(value) == stringTag$1;
}
function isSymbol$2(value) {
  return typeof value == "symbol" || isObjectLike$6(value) && objectToString$6.call(value) == symbolTag$2;
}
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$2(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign4 = value < 0 ? -1 : 1;
    return sign4 * MAX_INTEGER$2;
  }
  return value === value ? value : 0;
}
function toInteger$2(value) {
  var result = toFinite$2(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN$2;
  }
  if (isObject$i(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$i(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$2, "");
  var isBinary = reIsBinary$2.test(value);
  return isBinary || reIsOctal$2.test(value) ? freeParseInt$2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$2.test(value) ? NAN$2 : +value;
}
function keys$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function values(object) {
  return object ? baseValues(object, keys$1(object)) : [];
}
var lodash_includes = includes$1;
var boolTag = "[object Boolean]";
var objectProto$5 = Object.prototype;
var objectToString$5 = objectProto$5.toString;
function isBoolean$1(value) {
  return value === true || value === false || isObjectLike$5(value) && objectToString$5.call(value) == boolTag;
}
function isObjectLike$5(value) {
  return !!value && typeof value == "object";
}
var lodash_isboolean = isBoolean$1;
var INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = 0 / 0;
var symbolTag$1 = "[object Symbol]";
var reTrim$1 = /^\s+|\s+$/g;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
var objectProto$4 = Object.prototype;
var objectToString$4 = objectProto$4.toString;
function isInteger$2(value) {
  return typeof value == "number" && value == toInteger$1(value);
}
function isObject$h(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike$4(value) {
  return !!value && typeof value == "object";
}
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && objectToString$4.call(value) == symbolTag$1;
}
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$1(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign4 = value < 0 ? -1 : 1;
    return sign4 * MAX_INTEGER$1;
  }
  return value === value ? value : 0;
}
function toInteger$1(value) {
  var result = toFinite$1(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$h(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$h(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, "");
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var lodash_isinteger = isInteger$2;
var numberTag = "[object Number]";
var objectProto$3 = Object.prototype;
var objectToString$3 = objectProto$3.toString;
function isObjectLike$3(value) {
  return !!value && typeof value == "object";
}
function isNumber$1(value) {
  return typeof value == "number" || isObjectLike$3(value) && objectToString$3.call(value) == numberTag;
}
var lodash_isnumber = isNumber$1;
var objectTag = "[object Object]";
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto$2.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
var objectToString$2 = objectProto$2.toString;
var getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
function isPlainObject$1(value) {
  if (!isObjectLike$2(value) || objectToString$2.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto2 = getPrototype(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$1;
var stringTag = "[object String]";
var objectProto$1 = Object.prototype;
var objectToString$1 = objectProto$1.toString;
var isArray$1 = Array.isArray;
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isString$2(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$1(value) && objectToString$1.call(value) == stringTag;
}
var lodash_isstring = isString$2;
var FUNC_ERROR_TEXT = "Expected a function";
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
function before(n, func) {
  var result;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result;
  };
}
function once$1(func) {
  return before(2, func);
}
function isObject$g(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign4 = value < 0 ? -1 : 1;
    return sign4 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$g(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$g(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_once = once$1;
const timespan = timespan$2;
const PS_SUPPORTED = psSupported;
const validateAsymmetricKey = validateAsymmetricKey$2;
const jws = jws$3;
const includes = lodash_includes;
const isBoolean = lodash_isboolean;
const isInteger$1 = lodash_isinteger;
const isNumber = lodash_isnumber;
const isPlainObject = lodash_isplainobject;
const isString$1 = lodash_isstring;
const once = lodash_once;
const { KeyObject, createSecretKey, createPrivateKey } = crypto$2;
const SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
if (PS_SUPPORTED) {
  SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
}
const sign_options_schema = {
  expiresIn: { isValid: function(value) {
    return isInteger$1(value) || isString$1(value) && value;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) {
    return isInteger$1(value) || isString$1(value) && value;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) {
    return isString$1(value) || Array.isArray(value);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
  allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
};
const registered_claims_schema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
};
function validate(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object).forEach(function(key2) {
    const validator = schema[key2];
    if (!validator) {
      if (!allowUnknown) {
        throw new Error('"' + key2 + '" is not allowed in "' + parameterName + '"');
      }
      return;
    }
    if (!validator.isValid(object[key2])) {
      throw new Error(validator.message);
    }
  });
}
function validateOptions(options) {
  return validate(sign_options_schema, false, options, "options");
}
function validatePayload(payload) {
  return validate(registered_claims_schema, true, payload, "payload");
}
const options_to_payload = {
  "audience": "aud",
  "issuer": "iss",
  "subject": "sub",
  "jwtid": "jti"
};
const options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
];
var sign$2 = function(payload, secretOrPrivateKey, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }
  const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
  const header = Object.assign({
    alg: options.algorithm || "HS256",
    typ: isObjectPayload ? "JWT" : void 0,
    kid: options.keyid
  }, options.header);
  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  if (!secretOrPrivateKey && options.algorithm !== "none") {
    return failure(new Error("secretOrPrivateKey must have a value"));
  }
  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
    try {
      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
    } catch (_2) {
      try {
        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
      } catch (_3) {
        return failure(new Error("secretOrPrivateKey is not valid key material"));
      }
    }
  }
  if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
    return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
    if (secretOrPrivateKey.type !== "private") {
      return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
    }
    if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
    secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
    }
  }
  if (typeof payload === "undefined") {
    return failure(new Error("payload is required"));
  } else if (isObjectPayload) {
    try {
      validatePayload(payload);
    } catch (error2) {
      return failure(error2);
    }
    if (!options.mutatePayload) {
      payload = Object.assign({}, payload);
    }
  } else {
    const invalid_options = options_for_objects.filter(function(opt) {
      return typeof options[opt] !== "undefined";
    });
    if (invalid_options.length > 0) {
      return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
    }
  }
  if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }
  if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }
  try {
    validateOptions(options);
  } catch (error2) {
    return failure(error2);
  }
  if (!options.allowInvalidAsymmetricKeyTypes) {
    try {
      validateAsymmetricKey(header.alg, secretOrPrivateKey);
    } catch (error2) {
      return failure(error2);
    }
  }
  const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
  if (options.noTimestamp) {
    delete payload.iat;
  } else if (isObjectPayload) {
    payload.iat = timestamp;
  }
  if (typeof options.notBefore !== "undefined") {
    try {
      payload.nbf = timespan(options.notBefore, timestamp);
    } catch (err) {
      return failure(err);
    }
    if (typeof payload.nbf === "undefined") {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }
  if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
    try {
      payload.exp = timespan(options.expiresIn, timestamp);
    } catch (err) {
      return failure(err);
    }
    if (typeof payload.exp === "undefined") {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }
  Object.keys(options_to_payload).forEach(function(key2) {
    const claim = options_to_payload[key2];
    if (typeof options[key2] !== "undefined") {
      if (typeof payload[claim] !== "undefined") {
        return failure(new Error('Bad "options.' + key2 + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key2];
    }
  });
  const encoding = options.encoding || "utf8";
  if (typeof callback === "function") {
    callback = callback && once(callback);
    jws.createSign({
      header,
      privateKey: secretOrPrivateKey,
      payload,
      encoding
    }).once("error", callback).once("done", function(signature) {
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
      callback(null, signature);
    });
  } else {
    let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
    if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
    }
    return signature;
  }
};
var jsonwebtoken = {
  decode: decode$1,
  verify: verify2,
  sign: sign$2,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
};
var HttpMethod;
(function(HttpMethod2) {
  HttpMethod2["GET"] = "get";
  HttpMethod2["POST"] = "post";
})(HttpMethod || (HttpMethod = {}));
var HttpStatus;
(function(HttpStatus2) {
  HttpStatus2[HttpStatus2["SUCCESS_RANGE_START"] = 200] = "SUCCESS_RANGE_START";
  HttpStatus2[HttpStatus2["SUCCESS_RANGE_END"] = 299] = "SUCCESS_RANGE_END";
  HttpStatus2[HttpStatus2["REDIRECT"] = 302] = "REDIRECT";
  HttpStatus2[HttpStatus2["CLIENT_ERROR_RANGE_START"] = 400] = "CLIENT_ERROR_RANGE_START";
  HttpStatus2[HttpStatus2["CLIENT_ERROR_RANGE_END"] = 499] = "CLIENT_ERROR_RANGE_END";
  HttpStatus2[HttpStatus2["SERVER_ERROR_RANGE_START"] = 500] = "SERVER_ERROR_RANGE_START";
  HttpStatus2[HttpStatus2["SERVER_ERROR_RANGE_END"] = 599] = "SERVER_ERROR_RANGE_END";
})(HttpStatus || (HttpStatus = {}));
var ProxyStatus;
(function(ProxyStatus2) {
  ProxyStatus2[ProxyStatus2["SUCCESS_RANGE_START"] = 200] = "SUCCESS_RANGE_START";
  ProxyStatus2[ProxyStatus2["SUCCESS_RANGE_END"] = 299] = "SUCCESS_RANGE_END";
  ProxyStatus2[ProxyStatus2["SERVER_ERROR"] = 500] = "SERVER_ERROR";
})(ProxyStatus || (ProxyStatus = {}));
const REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
const RANDOM_OCTET_SIZE = 32;
const Hash = {
  SHA256: "sha256"
};
const CharSet = {
  CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
};
const Constants = {
  MSAL_SKU: "msal.js.node",
  JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
  AUTHORIZATION_PENDING: "authorization_pending",
  HTTP_PROTOCOL: "http://",
  LOCALHOST: "localhost"
};
var ApiId;
(function(ApiId2) {
  ApiId2[ApiId2["acquireTokenSilent"] = 62] = "acquireTokenSilent";
  ApiId2[ApiId2["acquireTokenByUsernamePassword"] = 371] = "acquireTokenByUsernamePassword";
  ApiId2[ApiId2["acquireTokenByDeviceCode"] = 671] = "acquireTokenByDeviceCode";
  ApiId2[ApiId2["acquireTokenByClientCredential"] = 771] = "acquireTokenByClientCredential";
  ApiId2[ApiId2["acquireTokenByCode"] = 871] = "acquireTokenByCode";
  ApiId2[ApiId2["acquireTokenByRefreshToken"] = 872] = "acquireTokenByRefreshToken";
})(ApiId || (ApiId = {}));
const JwtConstants = {
  RSA_256: "RS256",
  AUDIENCE: "aud",
  EXPIRATION_TIME: "exp",
  ISSUER: "iss",
  SUBJECT: "sub",
  NOT_BEFORE: "nbf",
  JWT_ID: "jti"
};
const LOOPBACK_SERVER_CONSTANTS = {
  INTERVAL_MS: 100,
  TIMEOUT_MS: 5e3
};
class NetworkUtils {
  static getNetworkResponse(headers, body, statusCode) {
    return {
      headers,
      body,
      status: statusCode
    };
  }
  /*
   * Utility function that converts a URL object into an ordinary options object as expected by the
   * http.request and https.request APIs.
   * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
   */
  static urlToHttpOptions(url) {
    const options = {
      protocol: url.protocol,
      hostname: url.hostname && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
      hash: url.hash,
      search: url.search,
      pathname: url.pathname,
      path: `${url.pathname || ""}${url.search || ""}`,
      href: url.href
    };
    if (url.port !== "") {
      options.port = Number(url.port);
    }
    if (url.username || url.password) {
      options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
    }
    return options;
  }
}
class HttpClient {
  constructor(proxyUrl, customAgentOptions) {
    this.proxyUrl = proxyUrl || "";
    this.customAgentOptions = customAgentOptions || {};
  }
  /**
   * Http Get request
   * @param url
   * @param options
   */
  async sendGetRequestAsync(url, options) {
    if (this.proxyUrl) {
      return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.GET, options, this.customAgentOptions);
    } else {
      return networkRequestViaHttps(url, HttpMethod.GET, options, this.customAgentOptions);
    }
  }
  /**
   * Http Post request
   * @param url
   * @param options
   */
  async sendPostRequestAsync(url, options, cancellationToken) {
    if (this.proxyUrl) {
      return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.POST, options, this.customAgentOptions, cancellationToken);
    } else {
      return networkRequestViaHttps(url, HttpMethod.POST, options, this.customAgentOptions, cancellationToken);
    }
  }
}
const networkRequestViaProxy = (destinationUrlString, proxyUrlString, httpMethod, options, agentOptions, timeout2) => {
  const destinationUrl = new URL(destinationUrlString);
  const proxyUrl = new URL(proxyUrlString);
  const headers = (options == null ? void 0 : options.headers) || {};
  const tunnelRequestOptions = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    method: "CONNECT",
    path: destinationUrl.hostname,
    headers
  };
  if (timeout2) {
    tunnelRequestOptions.timeout = timeout2;
  }
  if (agentOptions && Object.keys(agentOptions).length) {
    tunnelRequestOptions.agent = new http$1.Agent(agentOptions);
  }
  let postRequestStringContent = "";
  if (httpMethod === HttpMethod.POST) {
    const body = (options == null ? void 0 : options.body) || "";
    postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
  }
  const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
  return new Promise((resolve, reject) => {
    const request2 = http$1.request(tunnelRequestOptions);
    if (tunnelRequestOptions.timeout) {
      request2.on("timeout", () => {
        request2.destroy();
        reject(new Error("Request time out"));
      });
    }
    request2.end();
    request2.on("connect", (response, socket) => {
      const proxyStatusCode = (response == null ? void 0 : response.statusCode) || ProxyStatus.SERVER_ERROR;
      if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START || proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
        request2.destroy();
        socket.destroy();
        reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${(response == null ? void 0 : response.statusMessage) || "Unknown"}`));
      }
      if (tunnelRequestOptions.timeout) {
        socket.setTimeout(tunnelRequestOptions.timeout);
        socket.on("timeout", () => {
          request2.destroy();
          socket.destroy();
          reject(new Error("Request time out"));
        });
      }
      socket.write(outgoingRequestString);
      const data = [];
      socket.on("data", (chunk) => {
        data.push(chunk);
      });
      socket.on("end", () => {
        const dataString = Buffer.concat([...data]).toString();
        const dataStringArray = dataString.split("\r\n");
        const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
        const statusMessage = dataStringArray[0].split(" ").slice(2).join(" ");
        const body = dataStringArray[dataStringArray.length - 1];
        const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
        const entries = /* @__PURE__ */ new Map();
        headersArray.forEach((header) => {
          const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
          const headerKey = headerKeyValue[0];
          let headerValue = headerKeyValue[1];
          try {
            const object = JSON.parse(headerValue);
            if (object && typeof object === "object") {
              headerValue = object;
            }
          } catch (e) {
          }
          entries.set(headerKey, headerValue);
        });
        const headers2 = Object.fromEntries(entries);
        const parsedHeaders = headers2;
        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
        if ((httpStatusCode < HttpStatus.SUCCESS_RANGE_START || httpStatusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
          request2.destroy();
        }
        resolve(networkResponse);
      });
      socket.on("error", (chunk) => {
        request2.destroy();
        socket.destroy();
        reject(new Error(chunk.toString()));
      });
    });
    request2.on("error", (chunk) => {
      request2.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
const networkRequestViaHttps = (urlString, httpMethod, options, agentOptions, timeout2) => {
  const isPostRequest = httpMethod === HttpMethod.POST;
  const body = (options == null ? void 0 : options.body) || "";
  const url = new URL(urlString);
  const headers = (options == null ? void 0 : options.headers) || {};
  const customOptions = {
    method: httpMethod,
    headers,
    ...NetworkUtils.urlToHttpOptions(url)
  };
  if (timeout2) {
    customOptions.timeout = timeout2;
  }
  if (agentOptions && Object.keys(agentOptions).length) {
    customOptions.agent = new https$2.Agent(agentOptions);
  }
  if (isPostRequest) {
    customOptions.headers = {
      ...customOptions.headers,
      "Content-Length": body.length
    };
  }
  return new Promise((resolve, reject) => {
    const request2 = https$2.request(customOptions);
    if (timeout2) {
      request2.on("timeout", () => {
        request2.destroy();
        reject(new Error("Request time out"));
      });
    }
    if (isPostRequest) {
      request2.write(body);
    }
    request2.end();
    request2.on("response", (response) => {
      const headers2 = response.headers;
      const statusCode = response.statusCode;
      const statusMessage = response.statusMessage;
      const data = [];
      response.on("data", (chunk) => {
        data.push(chunk);
      });
      response.on("end", () => {
        const body2 = Buffer.concat([...data]).toString();
        const parsedHeaders = headers2;
        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(statusCode, statusMessage, parsedHeaders, body2), statusCode);
        if ((statusCode < HttpStatus.SUCCESS_RANGE_START || statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
        networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
          request2.destroy();
        }
        resolve(networkResponse);
      });
    });
    request2.on("error", (chunk) => {
      request2.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
const parseBody = (statusCode, statusMessage, headers, body) => {
  let parsedBody;
  try {
    parsedBody = JSON.parse(body);
  } catch (error2) {
    let errorType;
    let errorDescriptionHelper;
    if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START && statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
      errorType = "client_error";
      errorDescriptionHelper = "A client";
    } else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START && statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
      errorType = "server_error";
      errorDescriptionHelper = "A server";
    } else {
      errorType = "unknown_error";
      errorDescriptionHelper = "An unknown";
    }
    parsedBody = {
      error: errorType,
      error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || "Unknown"}
Headers: ${JSON.stringify(headers)}`
    };
  }
  return parsedBody;
};
const DEFAULT_AUTH_OPTIONS = {
  clientId: Constants$1.EMPTY_STRING,
  authority: Constants$1.DEFAULT_AUTHORITY,
  clientSecret: Constants$1.EMPTY_STRING,
  clientAssertion: Constants$1.EMPTY_STRING,
  clientCertificate: {
    thumbprint: Constants$1.EMPTY_STRING,
    privateKey: Constants$1.EMPTY_STRING,
    x5c: Constants$1.EMPTY_STRING
  },
  knownAuthorities: [],
  cloudDiscoveryMetadata: Constants$1.EMPTY_STRING,
  authorityMetadata: Constants$1.EMPTY_STRING,
  clientCapabilities: [],
  protocolMode: ProtocolMode.AAD,
  azureCloudOptions: {
    azureCloudInstance: AzureCloudInstance.None,
    tenant: Constants$1.EMPTY_STRING
  },
  skipAuthorityMetadataCache: false
};
const DEFAULT_CACHE_OPTIONS = {
  claimsBasedCachingEnabled: true
};
const DEFAULT_LOGGER_OPTIONS = {
  loggerCallback: () => {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel$1.Info
};
const DEFAULT_SYSTEM_OPTIONS = {
  loggerOptions: DEFAULT_LOGGER_OPTIONS,
  networkClient: /* @__PURE__ */ new HttpClient(),
  proxyUrl: Constants$1.EMPTY_STRING,
  customAgentOptions: {}
};
const DEFAULT_TELEMETRY_OPTIONS = {
  application: {
    appName: Constants$1.EMPTY_STRING,
    appVersion: Constants$1.EMPTY_STRING
  }
};
function buildAppConfiguration({
  auth,
  broker,
  cache,
  system,
  telemetry
}) {
  const systemOptions = {
    ...DEFAULT_SYSTEM_OPTIONS,
    networkClient: new HttpClient(system == null ? void 0 : system.proxyUrl, system == null ? void 0 : system.customAgentOptions),
    loggerOptions: (system == null ? void 0 : system.loggerOptions) || DEFAULT_LOGGER_OPTIONS
  };
  return {
    auth: {
      ...DEFAULT_AUTH_OPTIONS,
      ...auth
    },
    broker: {
      ...broker
    },
    cache: {
      ...DEFAULT_CACHE_OPTIONS,
      ...cache
    },
    system: {
      ...systemOptions,
      ...system
    },
    telemetry: {
      ...DEFAULT_TELEMETRY_OPTIONS,
      ...telemetry
    }
  };
}
class GuidGenerator {
  /**
   *
   * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
   * uuidv4 generates guids from cryprtographically-string random
   */
  generateGuid() {
    return v4();
  }
  /**
   * verifies if a string is  GUID
   * @param guid
   */
  isGuid(guid) {
    const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regexGuid.test(guid);
  }
}
class EncodingUtils {
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param str text
   */
  static base64Encode(str, encoding) {
    return Buffer.from(str, encoding).toString("base64");
  }
  /**
   * encode a URL
   * @param str
   */
  static base64EncodeUrl(str, encoding) {
    return EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants$1.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
  }
  /**
   * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
   * 'base64': Base64 encoding.
   *
   * @param base64Str Base64 encoded text
   */
  static base64Decode(base64Str) {
    return Buffer.from(base64Str, "base64").toString("utf8");
  }
  /**
   * @param base64Str Base64 encoded Url
   */
  static base64DecodeUrl(base64Str) {
    let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
    while (str.length % 4) {
      str += "=";
    }
    return EncodingUtils.base64Decode(str);
  }
}
class HashUtils {
  /**
   * generate 'SHA256' hash
   * @param buffer
   */
  sha256(buffer2) {
    return crypto$2.createHash(Hash.SHA256).update(buffer2).digest();
  }
}
class PkceGenerator {
  constructor() {
    this.hashUtils = new HashUtils();
  }
  /**
   * generates the codeVerfier and the challenge from the codeVerfier
   * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
   */
  async generatePkceCodes() {
    const verifier = this.generateCodeVerifier();
    const challenge = this.generateCodeChallengeFromVerifier(verifier);
    return {
      verifier,
      challenge
    };
  }
  /**
   * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
   */
  generateCodeVerifier() {
    const charArr = [];
    const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
    while (charArr.length <= RANDOM_OCTET_SIZE) {
      const byte = crypto$2.randomBytes(1)[0];
      if (byte >= maxNumber) {
        continue;
      }
      const index = byte % CharSet.CV_CHARSET.length;
      charArr.push(CharSet.CV_CHARSET[index]);
    }
    const verifier = charArr.join(Constants$1.EMPTY_STRING);
    return EncodingUtils.base64EncodeUrl(verifier);
  }
  /**
   * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
   * @param codeVerifier
   */
  generateCodeChallengeFromVerifier(codeVerifier) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
  }
}
class CryptoProvider {
  constructor() {
    this.pkceGenerator = new PkceGenerator();
    this.guidGenerator = new GuidGenerator();
    this.hashUtils = new HashUtils();
  }
  /**
   * Creates a new random GUID - used to populate state and nonce.
   * @returns string (GUID)
   */
  createNewGuid() {
    return this.guidGenerator.generateGuid();
  }
  /**
   * Encodes input string to base64.
   * @param input - string to be encoded
   */
  base64Encode(input) {
    return EncodingUtils.base64Encode(input);
  }
  /**
   * Decodes input string from base64.
   * @param input - string to be decoded
   */
  base64Decode(input) {
    return EncodingUtils.base64Decode(input);
  }
  /**
   * Generates PKCE codes used in Authorization Code Flow.
   */
  generatePkceCodes() {
    return this.pkceGenerator.generatePkceCodes();
  }
  /**
   * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
   */
  getPublicKeyThumbprint() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes cryptographic keypair from key store matching the keyId passed in
   * @param kid
   */
  removeTokenBindingKey() {
    throw new Error("Method not implemented.");
  }
  /**
   * Removes all cryptographic keys from Keystore
   */
  clearKeystore() {
    throw new Error("Method not implemented.");
  }
  /**
   * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
   */
  signJwt() {
    throw new Error("Method not implemented.");
  }
  /**
   * Returns the SHA-256 hash of an input string
   */
  async hashString(plainText) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
  }
}
class Deserializer {
  /**
   * Parse the JSON blob in memory and deserialize the content
   * @param cachedJson
   */
  static deserializeJSONBlob(jsonFile) {
    const deserializedCache = StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);
    return deserializedCache;
  }
  /**
   * Deserializes accounts to AccountEntity objects
   * @param accounts
   */
  static deserializeAccounts(accounts) {
    const accountObjects = {};
    if (accounts) {
      Object.keys(accounts).map(function(key2) {
        const serializedAcc = accounts[key2];
        const mappedAcc = {
          homeAccountId: serializedAcc.home_account_id,
          environment: serializedAcc.environment,
          realm: serializedAcc.realm,
          localAccountId: serializedAcc.local_account_id,
          username: serializedAcc.username,
          authorityType: serializedAcc.authority_type,
          name: serializedAcc.name,
          clientInfo: serializedAcc.client_info,
          lastModificationTime: serializedAcc.last_modification_time,
          lastModificationApp: serializedAcc.last_modification_app
        };
        const account = new AccountEntity();
        CacheManager.toObject(account, mappedAcc);
        accountObjects[key2] = account;
      });
    }
    return accountObjects;
  }
  /**
   * Deserializes id tokens to IdTokenEntity objects
   * @param idTokens
   */
  static deserializeIdTokens(idTokens) {
    const idObjects = {};
    if (idTokens) {
      Object.keys(idTokens).map(function(key2) {
        const serializedIdT = idTokens[key2];
        const mappedIdT = {
          homeAccountId: serializedIdT.home_account_id,
          environment: serializedIdT.environment,
          credentialType: serializedIdT.credential_type,
          clientId: serializedIdT.client_id,
          secret: serializedIdT.secret,
          realm: serializedIdT.realm
        };
        const idToken = new IdTokenEntity();
        CacheManager.toObject(idToken, mappedIdT);
        idObjects[key2] = idToken;
      });
    }
    return idObjects;
  }
  /**
   * Deserializes access tokens to AccessTokenEntity objects
   * @param accessTokens
   */
  static deserializeAccessTokens(accessTokens) {
    const atObjects = {};
    if (accessTokens) {
      Object.keys(accessTokens).map(function(key2) {
        const serializedAT = accessTokens[key2];
        const mappedAT = {
          homeAccountId: serializedAT.home_account_id,
          environment: serializedAT.environment,
          credentialType: serializedAT.credential_type,
          clientId: serializedAT.client_id,
          secret: serializedAT.secret,
          realm: serializedAT.realm,
          target: serializedAT.target,
          cachedAt: serializedAT.cached_at,
          expiresOn: serializedAT.expires_on,
          extendedExpiresOn: serializedAT.extended_expires_on,
          refreshOn: serializedAT.refresh_on,
          keyId: serializedAT.key_id,
          tokenType: serializedAT.token_type,
          requestedClaims: serializedAT.requestedClaims,
          requestedClaimsHash: serializedAT.requestedClaimsHash,
          userAssertionHash: serializedAT.userAssertionHash
        };
        const accessToken = new AccessTokenEntity();
        CacheManager.toObject(accessToken, mappedAT);
        atObjects[key2] = accessToken;
      });
    }
    return atObjects;
  }
  /**
   * Deserializes refresh tokens to RefreshTokenEntity objects
   * @param refreshTokens
   */
  static deserializeRefreshTokens(refreshTokens) {
    const rtObjects = {};
    if (refreshTokens) {
      Object.keys(refreshTokens).map(function(key2) {
        const serializedRT = refreshTokens[key2];
        const mappedRT = {
          homeAccountId: serializedRT.home_account_id,
          environment: serializedRT.environment,
          credentialType: serializedRT.credential_type,
          clientId: serializedRT.client_id,
          secret: serializedRT.secret,
          familyId: serializedRT.family_id,
          target: serializedRT.target,
          realm: serializedRT.realm
        };
        const refreshToken = new RefreshTokenEntity();
        CacheManager.toObject(refreshToken, mappedRT);
        rtObjects[key2] = refreshToken;
      });
    }
    return rtObjects;
  }
  /**
   * Deserializes appMetadata to AppMetaData objects
   * @param appMetadata
   */
  static deserializeAppMetadata(appMetadata) {
    const appMetadataObjects = {};
    if (appMetadata) {
      Object.keys(appMetadata).map(function(key2) {
        const serializedAmdt = appMetadata[key2];
        const mappedAmd = {
          clientId: serializedAmdt.client_id,
          environment: serializedAmdt.environment,
          familyId: serializedAmdt.family_id
        };
        const amd = new AppMetadataEntity();
        CacheManager.toObject(amd, mappedAmd);
        appMetadataObjects[key2] = amd;
      });
    }
    return appMetadataObjects;
  }
  /**
   * Deserialize an inMemory Cache
   * @param jsonCache
   */
  static deserializeAllCache(jsonCache) {
    return {
      accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
      idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
      accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
      refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
      appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
    };
  }
}
class Serializer {
  /**
   * serialize the JSON blob
   * @param data
   */
  static serializeJSONBlob(data) {
    return JSON.stringify(data);
  }
  /**
   * Serialize Accounts
   * @param accCache
   */
  static serializeAccounts(accCache) {
    const accounts = {};
    Object.keys(accCache).map(function(key2) {
      const accountEntity = accCache[key2];
      accounts[key2] = {
        home_account_id: accountEntity.homeAccountId,
        environment: accountEntity.environment,
        realm: accountEntity.realm,
        local_account_id: accountEntity.localAccountId,
        username: accountEntity.username,
        authority_type: accountEntity.authorityType,
        name: accountEntity.name,
        client_info: accountEntity.clientInfo,
        last_modification_time: accountEntity.lastModificationTime,
        last_modification_app: accountEntity.lastModificationApp
      };
    });
    return accounts;
  }
  /**
   * Serialize IdTokens
   * @param idTCache
   */
  static serializeIdTokens(idTCache) {
    const idTokens = {};
    Object.keys(idTCache).map(function(key2) {
      const idTEntity = idTCache[key2];
      idTokens[key2] = {
        home_account_id: idTEntity.homeAccountId,
        environment: idTEntity.environment,
        credential_type: idTEntity.credentialType,
        client_id: idTEntity.clientId,
        secret: idTEntity.secret,
        realm: idTEntity.realm
      };
    });
    return idTokens;
  }
  /**
   * Serializes AccessTokens
   * @param atCache
   */
  static serializeAccessTokens(atCache) {
    const accessTokens = {};
    Object.keys(atCache).map(function(key2) {
      const atEntity = atCache[key2];
      accessTokens[key2] = {
        home_account_id: atEntity.homeAccountId,
        environment: atEntity.environment,
        credential_type: atEntity.credentialType,
        client_id: atEntity.clientId,
        secret: atEntity.secret,
        realm: atEntity.realm,
        target: atEntity.target,
        cached_at: atEntity.cachedAt,
        expires_on: atEntity.expiresOn,
        extended_expires_on: atEntity.extendedExpiresOn,
        refresh_on: atEntity.refreshOn,
        key_id: atEntity.keyId,
        token_type: atEntity.tokenType,
        requestedClaims: atEntity.requestedClaims,
        requestedClaimsHash: atEntity.requestedClaimsHash,
        userAssertionHash: atEntity.userAssertionHash
      };
    });
    return accessTokens;
  }
  /**
   * Serialize refreshTokens
   * @param rtCache
   */
  static serializeRefreshTokens(rtCache) {
    const refreshTokens = {};
    Object.keys(rtCache).map(function(key2) {
      const rtEntity = rtCache[key2];
      refreshTokens[key2] = {
        home_account_id: rtEntity.homeAccountId,
        environment: rtEntity.environment,
        credential_type: rtEntity.credentialType,
        client_id: rtEntity.clientId,
        secret: rtEntity.secret,
        family_id: rtEntity.familyId,
        target: rtEntity.target,
        realm: rtEntity.realm
      };
    });
    return refreshTokens;
  }
  /**
   * Serialize amdtCache
   * @param amdtCache
   */
  static serializeAppMetadata(amdtCache) {
    const appMetadata = {};
    Object.keys(amdtCache).map(function(key2) {
      const amdtEntity = amdtCache[key2];
      appMetadata[key2] = {
        client_id: amdtEntity.clientId,
        environment: amdtEntity.environment,
        family_id: amdtEntity.familyId
      };
    });
    return appMetadata;
  }
  /**
   * Serialize the cache
   * @param jsonContent
   */
  static serializeAllCache(inMemCache) {
    return {
      Account: this.serializeAccounts(inMemCache.accounts),
      IdToken: this.serializeIdTokens(inMemCache.idTokens),
      AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
      RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
      AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
    };
  }
}
class NodeStorage extends CacheManager {
  constructor(logger2, clientId, cryptoImpl) {
    super(clientId, cryptoImpl, logger2);
    this.cache = {};
    this.changeEmitters = [];
    this.logger = logger2;
  }
  /**
   * Queue up callbacks
   * @param func - a callback function for cache change indication
   */
  registerChangeEmitter(func) {
    this.changeEmitters.push(func);
  }
  /**
   * Invoke the callback when cache changes
   */
  emitChange() {
    this.changeEmitters.forEach((func) => func.call(null));
  }
  /**
   * Converts cacheKVStore to InMemoryCache
   * @param cache - key value store
   */
  cacheToInMemoryCache(cache) {
    const inMemoryCache = {
      accounts: {},
      idTokens: {},
      accessTokens: {},
      refreshTokens: {},
      appMetadata: {}
    };
    for (const key2 in cache) {
      if (cache[key2] instanceof AccountEntity) {
        inMemoryCache.accounts[key2] = cache[key2];
      } else if (cache[key2] instanceof IdTokenEntity) {
        inMemoryCache.idTokens[key2] = cache[key2];
      } else if (cache[key2] instanceof AccessTokenEntity) {
        inMemoryCache.accessTokens[key2] = cache[key2];
      } else if (cache[key2] instanceof RefreshTokenEntity) {
        inMemoryCache.refreshTokens[key2] = cache[key2];
      } else if (cache[key2] instanceof AppMetadataEntity) {
        inMemoryCache.appMetadata[key2] = cache[key2];
      } else {
        continue;
      }
    }
    return inMemoryCache;
  }
  /**
   * converts inMemoryCache to CacheKVStore
   * @param inMemoryCache - kvstore map for inmemory
   */
  inMemoryCacheToCache(inMemoryCache) {
    let cache = this.getCache();
    cache = {
      ...cache,
      ...inMemoryCache.accounts,
      ...inMemoryCache.idTokens,
      ...inMemoryCache.accessTokens,
      ...inMemoryCache.refreshTokens,
      ...inMemoryCache.appMetadata
    };
    return cache;
  }
  /**
   * gets the current in memory cache for the client
   */
  getInMemoryCache() {
    this.logger.trace("Getting in-memory cache");
    const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
    return inMemoryCache;
  }
  /**
   * sets the current in memory cache for the client
   * @param inMemoryCache - key value map in memory
   */
  setInMemoryCache(inMemoryCache) {
    this.logger.trace("Setting in-memory cache");
    const cache = this.inMemoryCacheToCache(inMemoryCache);
    this.setCache(cache);
    this.emitChange();
  }
  /**
   * get the current cache key-value store
   */
  getCache() {
    this.logger.trace("Getting cache key-value store");
    return this.cache;
  }
  /**
   * sets the current cache (key value store)
   * @param cacheMap - key value map
   */
  setCache(cache) {
    this.logger.trace("Setting cache key value store");
    this.cache = cache;
    this.emitChange();
  }
  /**
   * Gets cache item with given key.
   * @param key - lookup key for the cache entry
   */
  getItem(key2) {
    this.logger.tracePii(`Item key: ${key2}`);
    const cache = this.getCache();
    return cache[key2];
  }
  /**
   * Gets cache item with given key-value
   * @param key - lookup key for the cache entry
   * @param value - value of the cache entry
   */
  setItem(key2, value) {
    this.logger.tracePii(`Item key: ${key2}`);
    const cache = this.getCache();
    cache[key2] = value;
    this.setCache(cache);
  }
  getAccountKeys() {
    const inMemoryCache = this.getInMemoryCache();
    const accountKeys = Object.keys(inMemoryCache.accounts);
    return accountKeys;
  }
  getTokenKeys() {
    const inMemoryCache = this.getInMemoryCache();
    const tokenKeys = {
      idToken: Object.keys(inMemoryCache.idTokens),
      accessToken: Object.keys(inMemoryCache.accessTokens),
      refreshToken: Object.keys(inMemoryCache.refreshTokens)
    };
    return tokenKeys;
  }
  /**
   * fetch the account entity
   * @param accountKey - lookup key to fetch cache type AccountEntity
   */
  getAccount(accountKey) {
    const account = this.getItem(accountKey);
    if (AccountEntity.isAccountEntity(account)) {
      return account;
    }
    return null;
  }
  /**
   * set account entity
   * @param account - cache value to be set of type AccountEntity
   */
  setAccount(account) {
    const accountKey = account.generateAccountKey();
    this.setItem(accountKey, account);
  }
  /**
   * fetch the idToken credential
   * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
   */
  getIdTokenCredential(idTokenKey) {
    const idToken = this.getItem(idTokenKey);
    if (IdTokenEntity.isIdTokenEntity(idToken)) {
      return idToken;
    }
    return null;
  }
  /**
   * set idToken credential
   * @param idToken - cache value to be set of type IdTokenEntity
   */
  setIdTokenCredential(idToken) {
    const idTokenKey = idToken.generateCredentialKey();
    this.setItem(idTokenKey, idToken);
  }
  /**
   * fetch the accessToken credential
   * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
   */
  getAccessTokenCredential(accessTokenKey) {
    const accessToken = this.getItem(accessTokenKey);
    if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {
      return accessToken;
    }
    return null;
  }
  /**
   * set accessToken credential
   * @param accessToken -  cache value to be set of type AccessTokenEntity
   */
  setAccessTokenCredential(accessToken) {
    const accessTokenKey = accessToken.generateCredentialKey();
    this.setItem(accessTokenKey, accessToken);
  }
  /**
   * fetch the refreshToken credential
   * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
   */
  getRefreshTokenCredential(refreshTokenKey) {
    const refreshToken = this.getItem(refreshTokenKey);
    if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {
      return refreshToken;
    }
    return null;
  }
  /**
   * set refreshToken credential
   * @param refreshToken - cache value to be set of type RefreshTokenEntity
   */
  setRefreshTokenCredential(refreshToken) {
    const refreshTokenKey = refreshToken.generateCredentialKey();
    this.setItem(refreshTokenKey, refreshToken);
  }
  /**
   * fetch appMetadata entity from the platform cache
   * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
   */
  getAppMetadata(appMetadataKey) {
    const appMetadata = this.getItem(appMetadataKey);
    if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {
      return appMetadata;
    }
    return null;
  }
  /**
   * set appMetadata entity to the platform cache
   * @param appMetadata - cache value to be set of type AppMetadataEntity
   */
  setAppMetadata(appMetadata) {
    const appMetadataKey = appMetadata.generateAppMetadataKey();
    this.setItem(appMetadataKey, appMetadata);
  }
  /**
   * fetch server telemetry entity from the platform cache
   * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
   */
  getServerTelemetry(serverTelemetrykey) {
    const serverTelemetryEntity = this.getItem(serverTelemetrykey);
    if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
      return serverTelemetryEntity;
    }
    return null;
  }
  /**
   * set server telemetry entity to the platform cache
   * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
   * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
   */
  setServerTelemetry(serverTelemetryKey, serverTelemetry) {
    this.setItem(serverTelemetryKey, serverTelemetry);
  }
  /**
   * fetch authority metadata entity from the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   */
  getAuthorityMetadata(key2) {
    const authorityMetadataEntity = this.getItem(key2);
    if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key2, authorityMetadataEntity)) {
      return authorityMetadataEntity;
    }
    return null;
  }
  /**
   * Get all authority metadata keys
   */
  getAuthorityMetadataKeys() {
    return this.getKeys().filter((key2) => {
      return this.isAuthorityMetadata(key2);
    });
  }
  /**
   * set authority metadata entity to the platform cache
   * @param key - lookup key to fetch cache type AuthorityMetadataEntity
   * @param metadata - cache value to be set of type AuthorityMetadataEntity
   */
  setAuthorityMetadata(key2, metadata) {
    this.setItem(key2, metadata);
  }
  /**
   * fetch throttling entity from the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   */
  getThrottlingCache(throttlingCacheKey) {
    const throttlingCache = this.getItem(throttlingCacheKey);
    if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
      return throttlingCache;
    }
    return null;
  }
  /**
   * set throttling entity to the platform cache
   * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
   * @param throttlingCache - cache value to be set of type ThrottlingEntity
   */
  setThrottlingCache(throttlingCacheKey, throttlingCache) {
    this.setItem(throttlingCacheKey, throttlingCache);
  }
  /**
   * Removes the cache item from memory with the given key.
   * @param key - lookup key to remove a cache entity
   * @param inMemory - key value map of the cache
   */
  removeItem(key2) {
    this.logger.tracePii(`Item key: ${key2}`);
    let result = false;
    const cache = this.getCache();
    if (!!cache[key2]) {
      delete cache[key2];
      result = true;
    }
    if (result) {
      this.setCache(cache);
      this.emitChange();
    }
    return result;
  }
  /**
   * Checks whether key is in cache.
   * @param key - look up key for a cache entity
   */
  containsKey(key2) {
    return this.getKeys().includes(key2);
  }
  /**
   * Gets all keys in window.
   */
  getKeys() {
    this.logger.trace("Retrieving all cache keys");
    const cache = this.getCache();
    return [...Object.keys(cache)];
  }
  /**
   * Clears all cache entries created by MSAL (except tokens).
   */
  async clear() {
    this.logger.trace("Clearing cache entries created by MSAL");
    const cacheKeys = this.getKeys();
    cacheKeys.forEach((key2) => {
      this.removeItem(key2);
    });
    this.emitChange();
  }
  /**
   * Initialize in memory cache from an exisiting cache vault
   * @param cache - blob formatted cache (JSON)
   */
  static generateInMemoryCache(cache) {
    return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
  }
  /**
   * retrieves the final JSON
   * @param inMemoryCache - itemised cache read from the JSON
   */
  static generateJsonCache(inMemoryCache) {
    return Serializer.serializeAllCache(inMemoryCache);
  }
  /**
   * Updates a credential's cache key if the current cache key is outdated
   */
  updateCredentialCacheKey(currentCacheKey, credential) {
    const updatedCacheKey = credential.generateCredentialKey();
    if (currentCacheKey !== updatedCacheKey) {
      const cacheItem = this.getItem(currentCacheKey);
      if (cacheItem) {
        this.removeItem(currentCacheKey);
        this.setItem(updatedCacheKey, cacheItem);
        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
        return updatedCacheKey;
      } else {
        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
      }
    }
    return currentCacheKey;
  }
}
const defaultSerializedCache = {
  Account: {},
  IdToken: {},
  AccessToken: {},
  RefreshToken: {},
  AppMetadata: {}
};
class TokenCache {
  constructor(storage, logger2, cachePlugin) {
    this.cacheHasChanged = false;
    this.storage = storage;
    this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
    if (cachePlugin) {
      this.persistence = cachePlugin;
    }
    this.logger = logger2;
  }
  /**
   * Set to true if cache state has changed since last time serialize or writeToPersistence was called
   */
  hasChanged() {
    return this.cacheHasChanged;
  }
  /**
   * Serializes in memory cache to JSON
   */
  serialize() {
    this.logger.trace("Serializing in-memory cache");
    let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
    if (!StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
    } else {
      this.logger.trace("No cache snapshot to merge");
    }
    this.cacheHasChanged = false;
    return JSON.stringify(finalState);
  }
  /**
   * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
   * @param cache - blob formatted cache
   */
  deserialize(cache) {
    this.logger.trace("Deserializing JSON to in-memory cache");
    this.cacheSnapshot = cache;
    if (!StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
      this.storage.setInMemoryCache(deserializedCache);
    } else {
      this.logger.trace("No cache snapshot to deserialize");
    }
  }
  /**
   * Fetches the cache key-value map
   */
  getKVStore() {
    return this.storage.getCache();
  }
  /**
   * API that retrieves all accounts currently in cache to the user
   */
  async getAllAccounts() {
    this.logger.trace("getAllAccounts called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      return this.storage.getAllAccounts();
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Returns the signed in account matching homeAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param homeAccountId - unique identifier for an account (uid.utid)
   */
  async getAccountByHomeId(homeAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * Returns the signed in account matching localAccountId.
   * (the account object is created at the time of successful login)
   * or null when no matching account is found
   * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
   */
  async getAccountByLocalId(localAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
    } else {
      return null;
    }
  }
  /**
   * API to remove a specific account and the relevant data from cache
   * @param account - AccountInfo passed by the user
   */
  async removeAccount(account) {
    this.logger.trace("removeAccount called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, true);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  /**
   * Called when the cache has changed state.
   */
  handleChangeEvent() {
    this.cacheHasChanged = true;
  }
  /**
   * Merge in memory cache with the cache snapshot.
   * @param oldState - cache before changes
   * @param currentState - current cache state in the library
   */
  mergeState(oldState, currentState) {
    this.logger.trace("Merging in-memory cache with cache snapshot");
    const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
    return this.mergeUpdates(stateAfterRemoval, currentState);
  }
  /**
   * Deep update of oldState based on newState values
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeUpdates(oldState, newState) {
    Object.keys(newState).forEach((newKey) => {
      const newValue = newState[newKey];
      if (!oldState.hasOwnProperty(newKey)) {
        if (newValue !== null) {
          oldState[newKey] = newValue;
        }
      } else {
        const newValueNotNull = newValue !== null;
        const newValueIsObject = typeof newValue === "object";
        const newValueIsNotArray = !Array.isArray(newValue);
        const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
        if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
          this.mergeUpdates(oldState[newKey], newValue);
        } else {
          oldState[newKey] = newValue;
        }
      }
    });
    return oldState;
  }
  /**
   * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
   * oldState that are not recognized, they are left untouched.
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeRemovals(oldState, newState) {
    this.logger.trace("Remove updated entries in cache");
    const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
    const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
    const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
    const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
    const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
    return {
      ...oldState,
      Account: accounts,
      AccessToken: accessTokens,
      RefreshToken: refreshTokens,
      IdToken: idTokens,
      AppMetadata: appMetadata
    };
  }
  /**
   * Helper to merge new cache with the old one
   * @param oldState - cache before changes
   * @param newState - updated cache
   */
  mergeRemovalsDict(oldState, newState) {
    const finalState = {
      ...oldState
    };
    Object.keys(oldState).forEach((oldKey) => {
      if (!newState || !newState.hasOwnProperty(oldKey)) {
        delete finalState[oldKey];
      }
    });
    return finalState;
  }
  /**
   * Helper to overlay as a part of cache merge
   * @param passedInCache - cache read from the blob
   */
  overlayDefaults(passedInCache) {
    this.logger.trace("Overlaying input cache with the default cache");
    return {
      Account: {
        ...defaultSerializedCache.Account,
        ...passedInCache.Account
      },
      IdToken: {
        ...defaultSerializedCache.IdToken,
        ...passedInCache.IdToken
      },
      AccessToken: {
        ...defaultSerializedCache.AccessToken,
        ...passedInCache.AccessToken
      },
      RefreshToken: {
        ...defaultSerializedCache.RefreshToken,
        ...passedInCache.RefreshToken
      },
      AppMetadata: {
        ...defaultSerializedCache.AppMetadata,
        ...passedInCache.AppMetadata
      }
    };
  }
}
const name$1 = "@azure/msal-node";
const version$1 = "1.18.4";
const NodeAuthErrorMessage = {
  invalidLoopbackAddressType: {
    code: "invalid_loopback_server_address_type",
    desc: "Loopback server address is not type string. This is unexpected."
  },
  unableToLoadRedirectUri: {
    code: "unable_to_load_redirectUrl",
    desc: "Loopback server callback was invoked without a url. This is unexpected."
  },
  noAuthCodeInResponse: {
    code: "no_auth_code_in_response",
    desc: "No auth code found in the server response. Please check your network trace to determine what happened."
  },
  noLoopbackServerExists: {
    code: "no_loopback_server_exists",
    desc: "No loopback server exists yet."
  },
  loopbackServerAlreadyExists: {
    code: "loopback_server_already_exists",
    desc: "Loopback server already exists. Cannot create another."
  },
  loopbackServerTimeout: {
    code: "loopback_server_timeout",
    desc: "Timed out waiting for auth code listener to be registered."
  },
  stateNotFoundError: {
    code: "state_not_found",
    desc: "State not found. Please verify that the request originated from msal."
  }
};
class NodeAuthError extends AuthError {
  constructor(errorCode, errorMessage) {
    super(errorCode, errorMessage);
    this.name = "NodeAuthError";
  }
  /**
   * Creates an error thrown if loopback server address is of type string.
   */
  static createInvalidLoopbackAddressTypeError() {
    return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server is unable to get a url.
   */
  static createUnableToLoadRedirectUrlError() {
    return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
  }
  /**
   * Creates an error thrown if the server response does not contain an auth code.
   */
  static createNoAuthCodeInResponseError() {
    return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server has not been spun up yet.
   */
  static createNoLoopbackServerExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
  }
  /**
   * Creates an error thrown if a loopback server already exists when attempting to create another one.
   */
  static createLoopbackServerAlreadyExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
  }
  /**
   * Creates an error thrown if the loopback server times out registering the auth code listener.
   */
  static createLoopbackServerTimeoutError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
  }
  /**
   * Creates an error thrown when the state is not present.
   */
  static createStateNotFoundError() {
    return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
  }
}
class ClientApplication {
  /**
   * Constructor for the ClientApplication
   */
  constructor(configuration) {
    this.config = buildAppConfiguration(configuration);
    this.cryptoProvider = new CryptoProvider();
    this.logger = new Logger(this.config.system.loggerOptions, name$1, version$1);
    this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);
    this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
  }
  /**
   * Creates the URL of the authorization request, letting the user input credentials and consent to the
   * application. The URL targets the /authorize endpoint of the authority configured in the
   * application object.
   *
   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
   * `acquireTokenByCode(AuthorizationCodeRequest)`.
   */
  async getAuthCodeUrl(request2) {
    this.logger.info("getAuthCodeUrl called", request2.correlationId);
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2),
      responseMode: request2.responseMode || ResponseMode.QUERY,
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request2.azureCloudOptions);
    const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
    this.logger.verbose("Auth code client created", validRequest.correlationId);
    return authorizationCodeClient.getAuthCodeUrl(validRequest);
  }
  /**
   * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
   * Authorization Code flow.
   *
   * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
   * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
   * AuthorizationCodeRequest are the same.
   */
  async acquireTokenByCode(request2, authCodePayLoad) {
    this.logger.info("acquireTokenByCode called");
    if (request2.state && authCodePayLoad) {
      this.logger.info("acquireTokenByCode - validating state");
      this.validateState(request2.state, authCodePayLoad.state || "");
      authCodePayLoad = {
        ...authCodePayLoad,
        state: ""
      };
    }
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
    try {
      const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request2.azureCloudOptions);
      const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
      this.logger.verbose("Auth code client created", validRequest.correlationId);
      return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token by exchanging the refresh token provided for a new set of tokens.
   *
   * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
   * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
   * handle the caching and refreshing of tokens automatically.
   */
  async acquireTokenByRefreshToken(request2) {
    this.logger.info("acquireTokenByRefreshToken called", request2.correlationId);
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
    try {
      const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request2.azureCloudOptions);
      const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
      this.logger.verbose("Refresh token client created", validRequest.correlationId);
      return refreshTokenClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token silently when a user specifies the account the token is requested for.
   *
   * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
   * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
   * In case the refresh_token is expired or not found, an error is thrown
   * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
   */
  async acquireTokenSilent(request2) {
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2),
      forceRefresh: request2.forceRefresh || false
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
    try {
      const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request2.azureCloudOptions);
      const silentFlowClient = new SilentFlowClient(silentFlowClientConfig);
      this.logger.verbose("Silent flow client created", validRequest.correlationId);
      return silentFlowClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires tokens with password grant by exchanging client applications username and password for credentials
   *
   * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
   * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
   * Microsoft's documentation and recommendations are at:
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
   *
   * @param request - UsenamePasswordRequest
   */
  async acquireTokenByUsernamePassword(request2) {
    this.logger.info("acquireTokenByUsernamePassword called", request2.correlationId);
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2)
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
    try {
      const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request2.azureCloudOptions);
      const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
      this.logger.verbose("Username password client created", validRequest.correlationId);
      return usernamePasswordClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Gets the token cache for the application.
   */
  getTokenCache() {
    this.logger.info("getTokenCache called");
    return this.tokenCache;
  }
  /**
   * Validates OIDC state by comparing the user cached state with the state received from the server.
   *
   * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
   * CSRF attacks.
   * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
   * @param state
   * @param cachedState
   */
  validateState(state2, cachedState) {
    if (!state2) {
      throw NodeAuthError.createStateNotFoundError();
    }
    if (state2 !== cachedState) {
      throw ClientAuthError.createStateMismatchError();
    }
  }
  /**
   * Returns the logger instance
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Replaces the default logger set in configurations with new Logger with new configurations
   * @param logger - Logger instance
   */
  setLogger(logger2) {
    this.logger = logger2;
  }
  /**
   * Builds the common configuration to be passed to the common component based on the platform configurarion
   * @param authority - user passed authority in configuration
   * @param serverTelemetryManager - initializes servertelemetry if passed
   */
  async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
    this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
    const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;
    this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);
    const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);
    serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
    const clientConfiguration = {
      authOptions: {
        clientId: this.config.auth.clientId,
        authority: discoveredAuthority,
        clientCapabilities: this.config.auth.clientCapabilities
      },
      loggerOptions: {
        logLevel: this.config.system.loggerOptions.logLevel,
        loggerCallback: this.config.system.loggerOptions.loggerCallback,
        piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
        correlationId: requestCorrelationId
      },
      cacheOptions: {
        claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
      },
      cryptoInterface: this.cryptoProvider,
      networkInterface: this.config.system.networkClient,
      storageInterface: this.storage,
      serverTelemetryManager,
      clientCredentials: {
        clientSecret: this.clientSecret,
        clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : void 0
      },
      libraryInfo: {
        sku: Constants.MSAL_SKU,
        version: version$1,
        cpu: process.arch || Constants$1.EMPTY_STRING,
        os: process.platform || Constants$1.EMPTY_STRING
      },
      telemetry: this.config.telemetry,
      persistencePlugin: this.config.cache.cachePlugin,
      serializableCache: this.tokenCache
    };
    return clientConfiguration;
  }
  getClientAssertion(authority) {
    return {
      assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
      assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
    };
  }
  /**
   * Generates a request with the default scopes & generates a correlationId.
   * @param authRequest - BaseAuthRequest for initialization
   */
  async initializeBaseRequest(authRequest) {
    this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
    if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
      this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
    }
    authRequest.authenticationScheme = AuthenticationScheme.BEARER;
    if (this.config.cache.claimsBasedCachingEnabled && authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
    !StringUtils.isEmptyObj(authRequest.claims)) {
      authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
    }
    return {
      ...authRequest,
      scopes: [...authRequest && authRequest.scopes || [], ...OIDC_DEFAULT_SCOPES],
      correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
      authority: authRequest.authority || this.config.auth.authority
    };
  }
  /**
   * Initializes the server telemetry payload
   * @param apiId - Id for a specific request
   * @param correlationId - GUID
   * @param forceRefresh - boolean to indicate network call
   */
  initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
    const telemetryPayload = {
      clientId: this.config.auth.clientId,
      correlationId,
      apiId,
      forceRefresh: forceRefresh || false
    };
    return new ServerTelemetryManager(telemetryPayload, this.storage);
  }
  /**
   * Create authority instance. If authority not passed in request, default to authority set on the application
   * object. If no authority set in application object, then default to common authority.
   * @param authorityString - authority from user configuration
   */
  async createAuthority(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {
    this.logger.verbose("createAuthority called", requestCorrelationId);
    const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);
    const authorityOptions = {
      protocolMode: this.config.auth.protocolMode,
      knownAuthorities: this.config.auth.knownAuthorities,
      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
      authorityMetadata: this.config.auth.authorityMetadata,
      azureRegionConfiguration,
      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
    };
    return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger);
  }
  /**
   * Clear the cache
   */
  clearCache() {
    this.storage.clear();
  }
}
class LoopbackClient {
  /**
   * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
   * @param successTemplate
   * @param errorTemplate
   * @returns
   */
  async listenForAuthCode(successTemplate, errorTemplate) {
    if (!!this.server) {
      throw NodeAuthError.createLoopbackServerAlreadyExistsError();
    }
    const authCodeListener = new Promise((resolve, reject) => {
      this.server = http$1.createServer(async (req2, res) => {
        const url = req2.url;
        if (!url) {
          res.end(errorTemplate || "Error occurred loading redirectUrl");
          reject(NodeAuthError.createUnableToLoadRedirectUrlError());
          return;
        } else if (url === Constants$1.FORWARD_SLASH) {
          res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
          return;
        }
        const authCodeResponse = UrlString.getDeserializedQueryString(url);
        if (authCodeResponse.code) {
          const redirectUri = await this.getRedirectUri();
          res.writeHead(HttpStatus.REDIRECT, {
            location: redirectUri
          });
          res.end();
        }
        resolve(authCodeResponse);
      });
      this.server.listen(0);
    });
    await new Promise((resolve) => {
      let ticks = 0;
      const id = setInterval(() => {
        if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
          throw NodeAuthError.createLoopbackServerTimeoutError();
        }
        if (this.server.listening) {
          clearInterval(id);
          resolve();
        }
        ticks++;
      }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
    });
    return authCodeListener;
  }
  /**
   * Get the port that the loopback server is running on
   * @returns
   */
  getRedirectUri() {
    if (!this.server) {
      throw NodeAuthError.createNoLoopbackServerExistsError();
    }
    const address = this.server.address();
    if (!address || typeof address === "string" || !address.port) {
      this.closeServer();
      throw NodeAuthError.createInvalidLoopbackAddressTypeError();
    }
    const port = address && address.port;
    return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;
  }
  /**
   * Close the loopback server
   */
  closeServer() {
    if (!!this.server) {
      this.server.close();
    }
  }
}
class PublicClientApplication extends ClientApplication {
  /**
   * Important attributes in the Configuration object for auth are:
   * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
   * - authority: the authority URL for your application.
   *
   * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
   * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
   * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
   * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
   * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
   *
   * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
   * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
   * construction.
   *
   * ADFS authorities are of the form https://\{instance\}/adfs.
   */
  constructor(configuration) {
    super(configuration);
    if (this.config.broker.nativeBrokerPlugin) {
      if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
        this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
        this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
      } else {
        this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");
      }
    }
  }
  /**
   * Acquires a token from the authority using OAuth2.0 device code flow.
   * This flow is designed for devices that do not have access to a browser or have input constraints.
   * The authorization server issues a DeviceCode object with a verification code, an end-user code,
   * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
   * instructed to use another device to navigate to the verification URI to input credentials.
   * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
   * until the end-user completes input of credentials.
   */
  async acquireTokenByDeviceCode(request2) {
    this.logger.info("acquireTokenByDeviceCode called", request2.correlationId);
    const validRequest = Object.assign(request2, await this.initializeBaseRequest(request2));
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
    try {
      const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request2.azureCloudOptions);
      const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
      this.logger.verbose("Device code client created", validRequest.correlationId);
      return deviceCodeClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
   */
  async acquireTokenInteractive(request2) {
    const correlationId = request2.correlationId || this.cryptoProvider.createNewGuid();
    this.logger.trace("acquireTokenInteractive called", correlationId);
    const {
      openBrowser,
      successTemplate,
      errorTemplate,
      windowHandle,
      loopbackClient: customLoopbackClient,
      ...remainingProperties
    } = request2;
    if (this.nativeBrokerPlugin) {
      var _remainingProperties$;
      const brokerRequest = {
        ...remainingProperties,
        clientId: this.config.auth.clientId,
        scopes: request2.scopes || OIDC_DEFAULT_SCOPES,
        redirectUri: `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}`,
        authority: request2.authority || this.config.auth.authority,
        correlationId,
        extraParameters: {
          ...remainingProperties.extraQueryParameters,
          ...remainingProperties.tokenQueryParameters
        },
        accountId: (_remainingProperties$ = remainingProperties.account) == null ? void 0 : _remainingProperties$.nativeAccountId
      };
      return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
    }
    const {
      verifier,
      challenge
    } = await this.cryptoProvider.generatePkceCodes();
    const loopbackClient = customLoopbackClient || new LoopbackClient();
    try {
      const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);
      const redirectUri = loopbackClient.getRedirectUri();
      const validRequest = {
        ...remainingProperties,
        correlationId,
        scopes: request2.scopes || OIDC_DEFAULT_SCOPES,
        redirectUri,
        responseMode: ResponseMode.QUERY,
        codeChallenge: challenge,
        codeChallengeMethod: CodeChallengeMethodValues.S256
      };
      const authCodeUrl = await this.getAuthCodeUrl(validRequest);
      await openBrowser(authCodeUrl);
      const authCodeResponse = await authCodeListener.finally(() => {
        loopbackClient.closeServer();
      });
      if (authCodeResponse.error) {
        throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
      } else if (!authCodeResponse.code) {
        throw NodeAuthError.createNoAuthCodeInResponseError();
      }
      const clientInfo = authCodeResponse.client_info;
      const tokenRequest = {
        code: authCodeResponse.code,
        codeVerifier: verifier,
        clientInfo: clientInfo || Constants$1.EMPTY_STRING,
        ...validRequest
      };
      return this.acquireTokenByCode(tokenRequest);
    } catch (e) {
      loopbackClient.closeServer();
      throw e;
    }
  }
  /**
   * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
   * @param request
   * @returns
   */
  async acquireTokenSilent(request2) {
    const correlationId = request2.correlationId || this.cryptoProvider.createNewGuid();
    this.logger.trace("acquireTokenSilent called", correlationId);
    if (this.nativeBrokerPlugin) {
      const brokerRequest = {
        ...request2,
        clientId: this.config.auth.clientId,
        scopes: request2.scopes || OIDC_DEFAULT_SCOPES,
        redirectUri: `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}`,
        authority: request2.authority || this.config.auth.authority,
        correlationId,
        extraParameters: request2.tokenQueryParameters,
        accountId: request2.account.nativeAccountId,
        forceRefresh: request2.forceRefresh || false
      };
      return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
    }
    return super.acquireTokenSilent(request2);
  }
  /**
   * Removes cache artifacts associated with the given account
   * @param request
   * @returns
   */
  async signOut(request2) {
    if (this.nativeBrokerPlugin && request2.account.nativeAccountId) {
      const signoutRequest = {
        clientId: this.config.auth.clientId,
        accountId: request2.account.nativeAccountId,
        correlationId: request2.correlationId || this.cryptoProvider.createNewGuid()
      };
      await this.nativeBrokerPlugin.signOut(signoutRequest);
    }
    await this.getTokenCache().removeAccount(request2.account);
  }
  /**
   * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
   * @returns
   */
  async getAllAccounts() {
    if (this.nativeBrokerPlugin) {
      const correlationId = this.cryptoProvider.createNewGuid();
      return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
    }
    return this.getTokenCache().getAllAccounts();
  }
}
class ClientAssertion {
  /**
   * Initialize the ClientAssertion class from the clientAssertion passed by the user
   * @param assertion - refer https://tools.ietf.org/html/rfc7521
   */
  static fromAssertion(assertion) {
    const clientAssertion = new ClientAssertion();
    clientAssertion.jwt = assertion;
    return clientAssertion;
  }
  /**
   * Initialize the ClientAssertion class from the certificate passed by the user
   * @param thumbprint - identifier of a certificate
   * @param privateKey - secret key
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */
  static fromCertificate(thumbprint, privateKey, publicCertificate) {
    const clientAssertion = new ClientAssertion();
    clientAssertion.privateKey = privateKey;
    clientAssertion.thumbprint = thumbprint;
    if (publicCertificate) {
      clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
    }
    return clientAssertion;
  }
  /**
   * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
   * @param cryptoProvider - library's crypto helper
   * @param issuer - iss claim
   * @param jwtAudience - aud claim
   */
  getJwt(cryptoProvider, issuer, jwtAudience) {
    if (this.privateKey && this.thumbprint) {
      if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
        return this.jwt;
      }
      return this.createJwt(cryptoProvider, issuer, jwtAudience);
    }
    if (this.jwt) {
      return this.jwt;
    }
    throw ClientAuthError.createInvalidAssertionError();
  }
  /**
   * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
   */
  createJwt(cryptoProvider, issuer, jwtAudience) {
    this.issuer = issuer;
    this.jwtAudience = jwtAudience;
    const issuedAt = TimeUtils.nowSeconds();
    this.expirationTime = issuedAt + 600;
    const header = {
      alg: JwtConstants.RSA_256,
      x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
    };
    if (this.publicCertificate) {
      Object.assign(header, {
        x5c: this.publicCertificate
      });
    }
    const payload = {
      [JwtConstants.AUDIENCE]: this.jwtAudience,
      [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
      [JwtConstants.ISSUER]: this.issuer,
      [JwtConstants.SUBJECT]: this.issuer,
      [JwtConstants.NOT_BEFORE]: issuedAt,
      [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
    };
    this.jwt = jsonwebtoken.sign(payload, this.privateKey, {
      header
    });
    return this.jwt;
  }
  /**
   * Utility API to check expiration
   */
  isExpired() {
    return this.expirationTime < TimeUtils.nowSeconds();
  }
  /**
   * Extracts the raw certs from a given certificate string and returns them in an array.
   * @param publicCertificate - electronic document provided to prove the ownership of the public key
   */
  static parseCertificate(publicCertificate) {
    const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
    const certs = [];
    let matches;
    while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
      certs.push(matches[1].replace(/\r*\n/g, Constants$1.EMPTY_STRING));
    }
    return certs;
  }
}
class ConfidentialClientApplication extends ClientApplication {
  /**
   * Constructor for the ConfidentialClientApplication
   *
   * Required attributes in the Configuration object are:
   * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
   * - authority: the authority URL for your application.
   * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
   *
   * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
   * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
   * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
   * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
   *
   * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
   * Full B2C functionality will be available in this library in future versions.
   *
   * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
   */
  constructor(configuration) {
    super(configuration);
    this.setClientCredential(this.config);
    this.appTokenProvider = void 0;
  }
  /**
   * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
   * is meant for Azure SDK to enhance Managed Identity support.
   *
   * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
   */
  SetAppTokenProvider(provider) {
    this.appTokenProvider = provider;
  }
  /**
   * Acquires tokens from the authority for the application (not for an end user).
   */
  async acquireTokenByClientCredential(request2) {
    this.logger.info("acquireTokenByClientCredential called", request2.correlationId);
    let clientAssertion;
    if (request2.clientAssertion) {
      clientAssertion = {
        assertion: request2.clientAssertion,
        assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
      };
    }
    const baseRequest = await this.initializeBaseRequest(request2);
    const validBaseRequest = {
      ...baseRequest,
      scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope))
    };
    const validRequest = {
      ...request2,
      ...validBaseRequest,
      clientAssertion
    };
    const azureRegionConfiguration = {
      azureRegion: validRequest.azureRegion,
      environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
    try {
      const clientCredentialConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request2.azureCloudOptions);
      const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
      this.logger.verbose("Client credential client created", validRequest.correlationId);
      return clientCredentialClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  /**
   * Acquires tokens from the authority for the application.
   *
   * Used in scenarios where the current app is a middle-tier service which was called with a token
   * representing an end user. The current app can use the token (oboAssertion) to request another
   * token to access downstream web API, on behalf of that user.
   *
   * The current middle-tier app has no user interaction to obtain consent.
   * See how to gain consent upfront for your middle-tier app from this article.
   * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
   */
  async acquireTokenOnBehalfOf(request2) {
    this.logger.info("acquireTokenOnBehalfOf called", request2.correlationId);
    const validRequest = {
      ...request2,
      ...await this.initializeBaseRequest(request2)
    };
    try {
      const onBehalfOfConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request2.azureCloudOptions);
      const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
      this.logger.verbose("On behalf of client created", validRequest.correlationId);
      return oboClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      throw e;
    }
  }
  setClientCredential(configuration) {
    const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);
    const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);
    const certificate = configuration.auth.clientCertificate || {
      thumbprint: Constants$1.EMPTY_STRING,
      privateKey: Constants$1.EMPTY_STRING
    };
    const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);
    if (this.appTokenProvider) {
      return;
    }
    if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
      throw ClientAuthError.createInvalidCredentialError();
    }
    if (configuration.auth.clientSecret) {
      this.clientSecret = configuration.auth.clientSecret;
      return;
    }
    if (configuration.auth.clientAssertion) {
      this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);
      return;
    }
    if (!certificateNotEmpty) {
      throw ClientAuthError.createInvalidCredentialError();
    } else {
      var _configuration$auth$c;
      this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, (_configuration$auth$c = configuration.auth.clientCertificate) == null ? void 0 : _configuration$auth$c.x5c);
    }
  }
}
const XML_ATTRKEY = "$";
const XML_CHARKEY = "_";
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName == null ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = {
    ...responseObject.headers,
    ...responseObject.body
  };
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? {
      ...responseObject.headers,
      body: responseObject.body
    } : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a2;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return {
      ...parsedHeaders,
      body: fullResponse.parsedBody
    };
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper == null ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper == null ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return {
      ...parsedHeaders,
      blobBody: fullResponse.blobBody,
      readableStreamBody: fullResponse.readableStreamBody
    };
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = fullResponse.parsedBody ?? [];
    for (const key2 of Object.keys(modelProperties)) {
      if (modelProperties[key2].serializedName) {
        arrayResponse[key2] = (_a2 = fullResponse.parsedBody) == null ? void 0 : _a2[key2];
      }
    }
    if (parsedHeaders) {
      for (const key2 of Object.keys(parsedHeaders)) {
        arrayResponse[key2] = parsedHeaders[key2];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
const MapperTypeNames = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
};
let AbortError$3 = class AbortError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "AbortError";
  }
};
function log(message2, ...args) {
  process$1.stderr.write(`${util$5.format(message2, ...args)}${os$1.EOL}`);
}
const debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
let enabledString;
let enabledNamespaces = [];
let skippedNamespaces = [];
const debuggers = [];
if (debugEnvVariable) {
  enable(debugEnvVariable);
}
const debugObj = Object.assign((namespace) => {
  return createDebugger(namespace);
}, {
  enable,
  enabled,
  disable,
  log
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const namespaceList = namespaces.split(",").map((ns) => ns.trim());
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(ns.substring(1));
    } else {
      enabledNamespaces.push(ns);
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (namespaceMatches(namespace, skipped)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (namespaceMatches(namespace, enabledNamespace)) {
      return true;
    }
  }
  return false;
}
function namespaceMatches(namespace, patternToMatch) {
  if (patternToMatch.indexOf("*") === -1) {
    return namespace === patternToMatch;
  }
  let pattern = patternToMatch;
  if (patternToMatch.indexOf("**") !== -1) {
    const patternParts = [];
    let lastCharacter = "";
    for (const character of patternToMatch) {
      if (character === "*" && lastCharacter === "*") {
        continue;
      } else {
        lastCharacter = character;
        patternParts.push(character);
      }
    }
    pattern = patternParts.join("");
  }
  let namespaceIndex = 0;
  let patternIndex = 0;
  const patternLength = pattern.length;
  const namespaceLength = namespace.length;
  let lastWildcard = -1;
  let lastWildcardNamespace = -1;
  while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
    if (pattern[patternIndex] === "*") {
      lastWildcard = patternIndex;
      patternIndex++;
      if (patternIndex === patternLength) {
        return true;
      }
      while (namespace[namespaceIndex] !== pattern[patternIndex]) {
        namespaceIndex++;
        if (namespaceIndex === namespaceLength) {
          return false;
        }
      }
      lastWildcardNamespace = namespaceIndex;
      namespaceIndex++;
      patternIndex++;
      continue;
    } else if (pattern[patternIndex] === namespace[namespaceIndex]) {
      patternIndex++;
      namespaceIndex++;
    } else if (lastWildcard >= 0) {
      patternIndex = lastWildcard + 1;
      namespaceIndex = lastWildcardNamespace + 1;
      if (namespaceIndex === namespaceLength) {
        return false;
      }
      while (namespace[namespaceIndex] !== pattern[patternIndex]) {
        namespaceIndex++;
        if (namespaceIndex === namespaceLength) {
          return false;
        }
      }
      lastWildcardNamespace = namespaceIndex;
      namespaceIndex++;
      patternIndex++;
      continue;
    } else {
      return false;
    }
  }
  const namespaceDone = namespaceIndex === namespace.length;
  const patternDone = patternIndex === pattern.length;
  const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
  return namespaceDone && (patternDone || trailingWildCard);
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug2, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug2(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
const levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function isTypeSpecRuntimeLogLevel(level) {
  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
}
function createLoggerContext(options) {
  const registeredLoggers = /* @__PURE__ */ new Set();
  const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || void 0;
  let logLevel;
  const clientLogger = debugObj(options.namespace);
  clientLogger.log = (...args) => {
    debugObj.log(...args);
  };
  function contextSetLogLevel(level) {
    if (level && !isTypeSpecRuntimeLogLevel(level)) {
      throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
    }
    logLevel = level;
    const enabledNamespaces2 = [];
    for (const logger2 of registeredLoggers) {
      if (shouldEnable(logger2)) {
        enabledNamespaces2.push(logger2.namespace);
      }
    }
    debugObj.enable(enabledNamespaces2.join(","));
  }
  if (logLevelFromEnv) {
    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
      contextSetLogLevel(logLevelFromEnv);
    } else {
      console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
    }
  }
  function shouldEnable(logger2) {
    return Boolean(logLevel && levelMap[logger2.level] <= levelMap[logLevel]);
  }
  function createLogger(parent, level) {
    const logger2 = Object.assign(parent.extend(level), {
      level
    });
    patchLogMethod(parent, logger2);
    if (shouldEnable(logger2)) {
      const enabledNamespaces2 = debugObj.disable();
      debugObj.enable(enabledNamespaces2 + "," + logger2.namespace);
    }
    registeredLoggers.add(logger2);
    return logger2;
  }
  function contextGetLogLevel() {
    return logLevel;
  }
  function contextCreateClientLogger(namespace) {
    const clientRootLogger = clientLogger.extend(namespace);
    patchLogMethod(clientLogger, clientRootLogger);
    return {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  return {
    setLogLevel: contextSetLogLevel,
    getLogLevel: contextGetLogLevel,
    createClientLogger: contextCreateClientLogger,
    logger: clientLogger
  };
}
const context$1 = createLoggerContext({
  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
  namespace: "typeSpecRuntime"
});
function createClientLogger$1(namespace) {
  return context$1.createClientLogger(namespace);
}
function normalizeName(name2) {
  return name2.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
class HttpHeadersImpl {
  constructor(rawHeaders) {
    __publicField(this, "_headersMap");
    this._headersMap = /* @__PURE__ */ new Map();
    if (rawHeaders) {
      for (const headerName of Object.keys(rawHeaders)) {
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  set(name2, value) {
    this._headersMap.set(normalizeName(name2), { name: name2, value: String(value).trim() });
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param name - The name of the header. This value is case-insensitive.
   */
  get(name2) {
    var _a2;
    return (_a2 = this._headersMap.get(normalizeName(name2))) == null ? void 0 : _a2.value;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   * @param name - The name of the header to set. This value is case-insensitive.
   */
  has(name2) {
    return this._headersMap.has(normalizeName(name2));
  }
  /**
   * Remove the header with the provided headerName.
   * @param name - The name of the header to remove.
   */
  delete(name2) {
    this._headersMap.delete(normalizeName(name2));
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJSON(options = {}) {
    const result = {};
    if (options.preserveCase) {
      for (const entry of this._headersMap.values()) {
        result[entry.name] = entry.value;
      }
    } else {
      for (const [normalizedName, entry] of this._headersMap) {
        result[normalizedName] = entry.value;
      }
    }
    return result;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: true }));
  }
  /**
   * Iterate over tuples of header [name, value] pairs.
   */
  [Symbol.iterator]() {
    return headerIterator(this._headersMap);
  }
}
function createHttpHeaders$1(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
function randomUUID() {
  return crypto.randomUUID();
}
class PipelineRequestImpl {
  constructor(options) {
    __publicField(this, "url");
    __publicField(this, "method");
    __publicField(this, "headers");
    __publicField(this, "timeout");
    __publicField(this, "withCredentials");
    __publicField(this, "body");
    __publicField(this, "multipartBody");
    __publicField(this, "formData");
    __publicField(this, "streamResponseStatusCodes");
    __publicField(this, "enableBrowserStreams");
    __publicField(this, "proxySettings");
    __publicField(this, "disableKeepAlive");
    __publicField(this, "abortSignal");
    __publicField(this, "requestId");
    __publicField(this, "allowInsecureConnection");
    __publicField(this, "onUploadProgress");
    __publicField(this, "onDownloadProgress");
    __publicField(this, "requestOverrides");
    __publicField(this, "authSchemes");
    this.url = options.url;
    this.body = options.body;
    this.headers = options.headers ?? createHttpHeaders$1();
    this.method = options.method ?? "GET";
    this.timeout = options.timeout ?? 0;
    this.multipartBody = options.multipartBody;
    this.formData = options.formData;
    this.disableKeepAlive = options.disableKeepAlive ?? false;
    this.proxySettings = options.proxySettings;
    this.streamResponseStatusCodes = options.streamResponseStatusCodes;
    this.withCredentials = options.withCredentials ?? false;
    this.abortSignal = options.abortSignal;
    this.onUploadProgress = options.onUploadProgress;
    this.onDownloadProgress = options.onDownloadProgress;
    this.requestId = options.requestId || randomUUID();
    this.allowInsecureConnection = options.allowInsecureConnection ?? false;
    this.enableBrowserStreams = options.enableBrowserStreams ?? false;
    this.requestOverrides = options.requestOverrides;
    this.authSchemes = options.authSchemes;
  }
}
function createPipelineRequest$1(options) {
  return new PipelineRequestImpl(options);
}
const ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
class HttpPipeline {
  constructor(policies) {
    __publicField(this, "_policies", []);
    __publicField(this, "_orderedPolicies");
    this._policies = (policies == null ? void 0 : policies.slice(0)) ?? [];
    this._orderedPolicies = void 0;
  }
  addPolicy(policy, options = {}) {
    if (options.phase && options.afterPhase) {
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    }
    if (options.phase && !ValidPhaseNames.has(options.phase)) {
      throw new Error(`Invalid phase name: ${options.phase}`);
    }
    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
    }
    this._policies.push({
      policy,
      options
    });
    this._orderedPolicies = void 0;
  }
  removePolicy(options) {
    const removedPolicies = [];
    this._policies = this._policies.filter((policyDescriptor) => {
      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
        removedPolicies.push(policyDescriptor.policy);
        return false;
      } else {
        return true;
      }
    });
    this._orderedPolicies = void 0;
    return removedPolicies;
  }
  sendRequest(httpClient, request2) {
    const policies = this.getOrderedPolicies();
    const pipeline = policies.reduceRight((next, policy) => {
      return (req2) => {
        return policy.sendRequest(req2, next);
      };
    }, (req2) => httpClient.sendRequest(req2));
    return pipeline(request2);
  }
  getOrderedPolicies() {
    if (!this._orderedPolicies) {
      this._orderedPolicies = this.orderPolicies();
    }
    return this._orderedPolicies;
  }
  clone() {
    return new HttpPipeline(this._policies);
  }
  static create() {
    return new HttpPipeline();
  }
  orderPolicies() {
    const result = [];
    const policyMap = /* @__PURE__ */ new Map();
    function createPhase(name2) {
      return {
        name: name2,
        policies: /* @__PURE__ */ new Set(),
        hasRun: false,
        hasAfterPolicies: false
      };
    }
    const serializePhase = createPhase("Serialize");
    const noPhase = createPhase("None");
    const deserializePhase = createPhase("Deserialize");
    const retryPhase = createPhase("Retry");
    const signPhase = createPhase("Sign");
    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
    function getPhase(phase) {
      if (phase === "Retry") {
        return retryPhase;
      } else if (phase === "Serialize") {
        return serializePhase;
      } else if (phase === "Deserialize") {
        return deserializePhase;
      } else if (phase === "Sign") {
        return signPhase;
      } else {
        return noPhase;
      }
    }
    for (const descriptor of this._policies) {
      const policy = descriptor.policy;
      const options = descriptor.options;
      const policyName = policy.name;
      if (policyMap.has(policyName)) {
        throw new Error("Duplicate policy names not allowed in pipeline");
      }
      const node2 = {
        policy,
        dependsOn: /* @__PURE__ */ new Set(),
        dependants: /* @__PURE__ */ new Set()
      };
      if (options.afterPhase) {
        node2.afterPhase = getPhase(options.afterPhase);
        node2.afterPhase.hasAfterPolicies = true;
      }
      policyMap.set(policyName, node2);
      const phase = getPhase(options.phase);
      phase.policies.add(node2);
    }
    for (const descriptor of this._policies) {
      const { policy, options } = descriptor;
      const policyName = policy.name;
      const node2 = policyMap.get(policyName);
      if (!node2) {
        throw new Error(`Missing node for policy ${policyName}`);
      }
      if (options.afterPolicies) {
        for (const afterPolicyName of options.afterPolicies) {
          const afterNode = policyMap.get(afterPolicyName);
          if (afterNode) {
            node2.dependsOn.add(afterNode);
            afterNode.dependants.add(node2);
          }
        }
      }
      if (options.beforePolicies) {
        for (const beforePolicyName of options.beforePolicies) {
          const beforeNode = policyMap.get(beforePolicyName);
          if (beforeNode) {
            beforeNode.dependsOn.add(node2);
            node2.dependants.add(beforeNode);
          }
        }
      }
    }
    function walkPhase(phase) {
      phase.hasRun = true;
      for (const node2 of phase.policies) {
        if (node2.afterPhase && (!node2.afterPhase.hasRun || node2.afterPhase.policies.size)) {
          continue;
        }
        if (node2.dependsOn.size === 0) {
          result.push(node2.policy);
          for (const dependant of node2.dependants) {
            dependant.dependsOn.delete(node2);
          }
          policyMap.delete(node2.policy.name);
          phase.policies.delete(node2);
        }
      }
    }
    function walkPhases() {
      for (const phase of orderedPhases) {
        walkPhase(phase);
        if (phase.policies.size > 0 && phase !== noPhase) {
          if (!noPhase.hasRun) {
            walkPhase(noPhase);
          }
          return;
        }
        if (phase.hasAfterPolicies) {
          walkPhase(noPhase);
        }
      }
    }
    let iteration = 0;
    while (policyMap.size > 0) {
      iteration++;
      const initialResultLength = result.length;
      walkPhases();
      if (result.length <= initialResultLength && iteration > 1) {
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
      }
    }
    return result;
  }
}
function createEmptyPipeline$1() {
  return HttpPipeline.create();
}
function isObject$f(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
function isError$1(e) {
  if (isObject$f(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
const custom = util$5.inspect.custom;
const RedactedString = "REDACTED";
const defaultAllowedHeaderNames = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
];
const defaultAllowedQueryParameters = ["api-version"];
class Sanitizer {
  constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
    __publicField(this, "allowedHeaderNames");
    __publicField(this, "allowedQueryParameters");
    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
  }
  /**
   * Sanitizes an object for logging.
   * @param obj - The object to sanitize
   * @returns - The sanitized object as a string
   */
  sanitize(obj2) {
    const seen = /* @__PURE__ */ new Set();
    return JSON.stringify(obj2, (key2, value) => {
      if (value instanceof Error) {
        return {
          ...value,
          name: value.name,
          message: value.message
        };
      }
      if (key2 === "headers") {
        return this.sanitizeHeaders(value);
      } else if (key2 === "url") {
        return this.sanitizeUrl(value);
      } else if (key2 === "query") {
        return this.sanitizeQuery(value);
      } else if (key2 === "body") {
        return void 0;
      } else if (key2 === "response") {
        return void 0;
      } else if (key2 === "operationSpec") {
        return void 0;
      } else if (Array.isArray(value) || isObject$f(value)) {
        if (seen.has(value)) {
          return "[Circular]";
        }
        seen.add(value);
      }
      return value;
    }, 2);
  }
  /**
   * Sanitizes a URL for logging.
   * @param value - The URL to sanitize
   * @returns - The sanitized URL as a string
   */
  sanitizeUrl(value) {
    if (typeof value !== "string" || value === null || value === "") {
      return value;
    }
    const url = new URL(value);
    if (!url.search) {
      return value;
    }
    for (const [key2] of url.searchParams) {
      if (!this.allowedQueryParameters.has(key2.toLowerCase())) {
        url.searchParams.set(key2, RedactedString);
      }
    }
    return url.toString();
  }
  sanitizeHeaders(obj2) {
    const sanitized = {};
    for (const key2 of Object.keys(obj2)) {
      if (this.allowedHeaderNames.has(key2.toLowerCase())) {
        sanitized[key2] = obj2[key2];
      } else {
        sanitized[key2] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeQuery(value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const sanitized = {};
    for (const k of Object.keys(value)) {
      if (this.allowedQueryParameters.has(k.toLowerCase())) {
        sanitized[k] = value[k];
      } else {
        sanitized[k] = RedactedString;
      }
    }
    return sanitized;
  }
}
const errorSanitizer = new Sanitizer();
let RestError$1 = (_a = class extends Error {
  constructor(message2, options = {}) {
    var _a2;
    super(message2);
    /**
     * The code of the error itself (use statics on RestError if possible.)
     */
    __publicField(this, "code");
    /**
     * The HTTP status code of the request (if applicable.)
     */
    __publicField(this, "statusCode");
    /**
     * The request that was made.
     * This property is non-enumerable.
     */
    __publicField(this, "request");
    /**
     * The response received (if any.)
     * This property is non-enumerable.
     */
    __publicField(this, "response");
    /**
     * Bonus property set by the throw site.
     */
    __publicField(this, "details");
    this.name = "RestError";
    this.code = options.code;
    this.statusCode = options.statusCode;
    Object.defineProperty(this, "request", { value: options.request, enumerable: false });
    Object.defineProperty(this, "response", { value: options.response, enumerable: false });
    const agent = ((_a2 = this.request) == null ? void 0 : _a2.agent) ? {
      maxFreeSockets: this.request.agent.maxFreeSockets,
      maxSockets: this.request.agent.maxSockets
    } : void 0;
    Object.defineProperty(this, custom, {
      value: () => {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
          ...this,
          request: { ...this.request, agent },
          response: this.response
        })}`;
      },
      enumerable: false
    });
    Object.setPrototypeOf(this, _a.prototype);
  }
}, /**
 * Something went wrong when making the request.
 * This means the actual request failed for some reason,
 * such as a DNS issue or the connection being lost.
 */
__publicField(_a, "REQUEST_SEND_ERROR", "REQUEST_SEND_ERROR"), /**
 * This means that parsing the response from the server failed.
 * It may have been malformed.
 */
__publicField(_a, "PARSE_ERROR", "PARSE_ERROR"), _a);
function isRestError$1(e) {
  if (e instanceof RestError$1) {
    return true;
  }
  return isError$1(e) && e.name === "RestError";
}
function stringToUint8Array(value, format) {
  return Buffer.from(value, format);
}
const logger$o = createClientLogger$1("ts-http-runtime");
const DEFAULT_TLS_SETTINGS = {};
function isReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isStreamComplete(stream2) {
  if (stream2.readable === false) {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    const handler2 = () => {
      resolve();
      stream2.removeListener("close", handler2);
      stream2.removeListener("end", handler2);
      stream2.removeListener("error", handler2);
    };
    stream2.on("close", handler2);
    stream2.on("end", handler2);
    stream2.on("error", handler2);
  });
}
function isArrayBuffer(body) {
  return body && typeof body.byteLength === "number";
}
class ReportTransform extends node_stream.Transform {
  constructor(progressCallback) {
    super();
    __publicField(this, "loadedBytes", 0);
    __publicField(this, "progressCallback");
    this.progressCallback = progressCallback;
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  _transform(chunk, _encoding, callback) {
    this.push(chunk);
    this.loadedBytes += chunk.length;
    try {
      this.progressCallback({ loadedBytes: this.loadedBytes });
      callback();
    } catch (e) {
      callback(e);
    }
  }
}
class NodeHttpClient {
  constructor() {
    __publicField(this, "cachedHttpAgent");
    __publicField(this, "cachedHttpsAgents", /* @__PURE__ */ new WeakMap());
  }
  /**
   * Makes a request over an underlying transport layer and returns the response.
   * @param request - The request to be made.
   */
  async sendRequest(request2) {
    var _a2, _b2;
    const abortController = new AbortController();
    let abortListener;
    if (request2.abortSignal) {
      if (request2.abortSignal.aborted) {
        throw new AbortError$3("The operation was aborted. Request has already been canceled.");
      }
      abortListener = (event) => {
        if (event.type === "abort") {
          abortController.abort();
        }
      };
      request2.abortSignal.addEventListener("abort", abortListener);
    }
    let timeoutId;
    if (request2.timeout > 0) {
      timeoutId = setTimeout(() => {
        const sanitizer = new Sanitizer();
        logger$o.info(`request to '${sanitizer.sanitizeUrl(request2.url)}' timed out. canceling...`);
        abortController.abort();
      }, request2.timeout);
    }
    const acceptEncoding = request2.headers.get("Accept-Encoding");
    const shouldDecompress = (acceptEncoding == null ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding == null ? void 0 : acceptEncoding.includes("deflate"));
    let body = typeof request2.body === "function" ? request2.body() : request2.body;
    if (body && !request2.headers.has("Content-Length")) {
      const bodyLength = getBodyLength(body);
      if (bodyLength !== null) {
        request2.headers.set("Content-Length", bodyLength);
      }
    }
    let responseStream;
    try {
      if (body && request2.onUploadProgress) {
        const onUploadProgress = request2.onUploadProgress;
        const uploadReportStream = new ReportTransform(onUploadProgress);
        uploadReportStream.on("error", (e) => {
          logger$o.error("Error in upload progress", e);
        });
        if (isReadableStream(body)) {
          body.pipe(uploadReportStream);
        } else {
          uploadReportStream.end(body);
        }
        body = uploadReportStream;
      }
      const res = await this.makeRequest(request2, abortController, body);
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
      const headers = getResponseHeaders(res);
      const status = res.statusCode ?? 0;
      const response = {
        status,
        headers,
        request: request2
      };
      if (request2.method === "HEAD") {
        res.resume();
        return response;
      }
      responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
      const onDownloadProgress = request2.onDownloadProgress;
      if (onDownloadProgress) {
        const downloadReportStream = new ReportTransform(onDownloadProgress);
        downloadReportStream.on("error", (e) => {
          logger$o.error("Error in download progress", e);
        });
        responseStream.pipe(downloadReportStream);
        responseStream = downloadReportStream;
      }
      if (
        // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
        ((_a2 = request2.streamResponseStatusCodes) == null ? void 0 : _a2.has(Number.POSITIVE_INFINITY)) || ((_b2 = request2.streamResponseStatusCodes) == null ? void 0 : _b2.has(response.status))
      ) {
        response.readableStreamBody = responseStream;
      } else {
        response.bodyAsText = await streamToText(responseStream);
      }
      return response;
    } finally {
      if (request2.abortSignal && abortListener) {
        let uploadStreamDone = Promise.resolve();
        if (isReadableStream(body)) {
          uploadStreamDone = isStreamComplete(body);
        }
        let downloadStreamDone = Promise.resolve();
        if (isReadableStream(responseStream)) {
          downloadStreamDone = isStreamComplete(responseStream);
        }
        Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
          var _a3;
          if (abortListener) {
            (_a3 = request2.abortSignal) == null ? void 0 : _a3.removeEventListener("abort", abortListener);
          }
        }).catch((e) => {
          logger$o.warning("Error when cleaning up abortListener on httpRequest", e);
        });
      }
    }
  }
  makeRequest(request2, abortController, body) {
    const url = new URL(request2.url);
    const isInsecure = url.protocol !== "https:";
    if (isInsecure && !request2.allowInsecureConnection) {
      throw new Error(`Cannot connect to ${request2.url} while allowInsecureConnection is false.`);
    }
    const agent = request2.agent ?? this.getOrCreateAgent(request2, isInsecure);
    const options = {
      agent,
      hostname: url.hostname,
      path: `${url.pathname}${url.search}`,
      port: url.port,
      method: request2.method,
      headers: request2.headers.toJSON({ preserveCase: true }),
      ...request2.requestOverrides
    };
    return new Promise((resolve, reject) => {
      const req2 = isInsecure ? http$2.request(options, resolve) : https$3.request(options, resolve);
      req2.once("error", (err) => {
        reject(new RestError$1(err.message, { code: err.code ?? RestError$1.REQUEST_SEND_ERROR, request: request2 }));
      });
      abortController.signal.addEventListener("abort", () => {
        const abortError2 = new AbortError$3("The operation was aborted. Rejecting from abort signal callback while making request.");
        req2.destroy(abortError2);
        reject(abortError2);
      });
      if (body && isReadableStream(body)) {
        body.pipe(req2);
      } else if (body) {
        if (typeof body === "string" || Buffer.isBuffer(body)) {
          req2.end(body);
        } else if (isArrayBuffer(body)) {
          req2.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
        } else {
          logger$o.error("Unrecognized body type", body);
          reject(new RestError$1("Unrecognized body type"));
        }
      } else {
        req2.end();
      }
    });
  }
  getOrCreateAgent(request2, isInsecure) {
    const disableKeepAlive = request2.disableKeepAlive;
    if (isInsecure) {
      if (disableKeepAlive) {
        return http$2.globalAgent;
      }
      if (!this.cachedHttpAgent) {
        this.cachedHttpAgent = new http$2.Agent({ keepAlive: true });
      }
      return this.cachedHttpAgent;
    } else {
      if (disableKeepAlive && !request2.tlsSettings) {
        return https$3.globalAgent;
      }
      const tlsSettings = request2.tlsSettings ?? DEFAULT_TLS_SETTINGS;
      let agent = this.cachedHttpsAgents.get(tlsSettings);
      if (agent && agent.options.keepAlive === !disableKeepAlive) {
        return agent;
      }
      logger$o.info("No cached TLS Agent exist, creating a new Agent");
      agent = new https$3.Agent({
        // keepAlive is true if disableKeepAlive is false.
        keepAlive: !disableKeepAlive,
        // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
        ...tlsSettings
      });
      this.cachedHttpsAgents.set(tlsSettings, agent);
      return agent;
    }
  }
}
function getResponseHeaders(res) {
  const headers = createHttpHeaders$1();
  for (const header of Object.keys(res.headers)) {
    const value = res.headers[header];
    if (Array.isArray(value)) {
      if (value.length > 0) {
        headers.set(header, value[0]);
      }
    } else if (value) {
      headers.set(header, value);
    }
  }
  return headers;
}
function getDecodedResponseStream(stream2, headers) {
  const contentEncoding = headers.get("Content-Encoding");
  if (contentEncoding === "gzip") {
    const unzip = zlib.createGunzip();
    stream2.pipe(unzip);
    return unzip;
  } else if (contentEncoding === "deflate") {
    const inflate = zlib.createInflate();
    stream2.pipe(inflate);
    return inflate;
  }
  return stream2;
}
function streamToText(stream2) {
  return new Promise((resolve, reject) => {
    const buffer2 = [];
    stream2.on("data", (chunk) => {
      if (Buffer.isBuffer(chunk)) {
        buffer2.push(chunk);
      } else {
        buffer2.push(Buffer.from(chunk));
      }
    });
    stream2.on("end", () => {
      resolve(Buffer.concat(buffer2).toString("utf8"));
    });
    stream2.on("error", (e) => {
      if (e && (e == null ? void 0 : e.name) === "AbortError") {
        reject(e);
      } else {
        reject(new RestError$1(`Error reading response as text: ${e.message}`, {
          code: RestError$1.PARSE_ERROR
        }));
      }
    });
  });
}
function getBodyLength(body) {
  if (!body) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (isReadableStream(body)) {
    return null;
  } else if (isArrayBuffer(body)) {
    return body.byteLength;
  } else if (typeof body === "string") {
    return Buffer.from(body).length;
  } else {
    return null;
  }
}
function createNodeHttpClient() {
  return new NodeHttpClient();
}
function createDefaultHttpClient$1() {
  return createNodeHttpClient();
}
const logPolicyName = "logPolicy";
function logPolicy$1(options = {}) {
  const logger2 = options.logger ?? logger$o.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request2, next) {
      if (!logger2.enabled) {
        return next(request2);
      }
      logger2(`Request: ${sanitizer.sanitize(request2)}`);
      const response = await next(request2);
      logger2(`Response status code: ${response.status}`);
      logger2(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
const redirectPolicyName = "redirectPolicy";
const allowedRedirect = ["GET", "HEAD"];
function redirectPolicy$1(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request2, next) {
      const response = await next(request2);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request: request2, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request2.method) || status === 302 && allowedRedirect.includes(request2.method) || status === 303 && request2.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request2.url);
    request2.url = url.toString();
    if (status === 303) {
      request2.method = "GET";
      request2.headers.delete("Content-Length");
      delete request2.body;
    }
    request2.headers.delete("Authorization");
    const res = await next(request2);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
const DEFAULT_RETRY_POLICY_COUNT = 3;
const decompressResponsePolicyName = "decompressResponsePolicy";
function decompressResponsePolicy$1() {
  return {
    name: decompressResponsePolicyName,
    async sendRequest(request2, next) {
      if (request2.method !== "HEAD") {
        request2.headers.set("Accept-Encoding", "gzip,deflate");
      }
      return next(request2);
    }
  };
}
function getRandomIntegerInclusive(min2, max2) {
  min2 = Math.ceil(min2);
  max2 = Math.floor(max2);
  const offset = Math.floor(Math.random() * (max2 - min2 + 1));
  return offset + min2;
}
function calculateRetryDelay(retryAttempt, config) {
  const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
  const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
  const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);
  return { retryAfterInMs };
}
const StandardAbortMessage$1 = "The operation was aborted.";
function delay$1(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError$3((options == null ? void 0 : options.abortErrorMsg) ? options == null ? void 0 : options.abortErrorMsg : StandardAbortMessage$1));
    };
    const removeListeners = () => {
      if ((options == null ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options == null ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options == null ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
const RetryAfterHeader = "Retry-After";
const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date2 = Date.parse(retryAfterHeader);
    const diff2 = date2 - Date.now();
    return Number.isFinite(diff2) ? Math.max(0, diff2) : void 0;
  } catch {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
const DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
function exponentialRetryStrategy(options = {}) {
  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      return calculateRetryDelay(retryCount, {
        retryDelayInMs: retryInterval,
        maxRetryDelayInMs: maxRetryInterval
      });
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}
const retryPolicyLogger = createClientLogger$1("ts-http-runtime retryPolicy");
const retryPolicyName = "retryPolicy";
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger2 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request2, next) {
      var _a2;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest: while (true) {
        retryCount += 1;
        response = void 0;
        responseError = void 0;
        try {
          logger2.info(`Retry ${retryCount}: Attempting to send request`, request2.requestId);
          response = await next(request2);
          logger2.info(`Retry ${retryCount}: Received a response from request`, request2.requestId);
        } catch (e) {
          logger2.error(`Retry ${retryCount}: Received an error from request`, request2.requestId);
          responseError = e;
          if (!e || responseError.name !== "RestError") {
            throw e;
          }
          response = responseError.response;
        }
        if ((_a2 = request2.abortSignal) == null ? void 0 : _a2.aborted) {
          logger2.error(`Retry ${retryCount}: Request aborted.`);
          const abortError2 = new AbortError$3();
          throw abortError2;
        }
        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {
          logger2.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
          if (responseError) {
            throw responseError;
          } else if (response) {
            return response;
          } else {
            throw new Error("Maximum retries reached with no response or error to throw");
          }
        }
        logger2.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
        strategiesLoop: for (const strategy of strategies) {
          const strategyLogger = strategy.logger || logger2;
          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
          const modifiers = strategy.retry({
            retryCount,
            response,
            responseError
          });
          if (modifiers.skipStrategy) {
            strategyLogger.info(`Retry ${retryCount}: Skipped.`);
            continue strategiesLoop;
          }
          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
          if (errorToThrow) {
            strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
            throw errorToThrow;
          }
          if (retryAfterInMs || retryAfterInMs === 0) {
            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
            await delay$1(retryAfterInMs, void 0, { abortSignal: request2.abortSignal });
            continue retryRequest;
          }
          if (redirectTo) {
            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
            request2.url = redirectTo;
            continue retryRequest;
          }
        }
        if (responseError) {
          logger2.info(`None of the retry strategies could work with the received error. Throwing it.`);
          throw responseError;
        }
        if (response) {
          logger2.info(`None of the retry strategies could work with the received response. Returning it.`);
          return response;
        }
      }
    }
  };
}
const defaultRetryPolicyName = "defaultRetryPolicy";
function defaultRetryPolicy$1(options = {}) {
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
const isNodeLike$1 = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_b = globalThis.process.versions) == null ? void 0 : _b.node);
const formDataPolicyName = "formDataPolicy";
function formDataToFormDataMap(formData) {
  const formDataMap = {};
  for (const [key2, value] of formData.entries()) {
    formDataMap[key2] ?? (formDataMap[key2] = []);
    formDataMap[key2].push(value);
  }
  return formDataMap;
}
function formDataPolicy$1() {
  return {
    name: formDataPolicyName,
    async sendRequest(request2, next) {
      if (isNodeLike$1 && typeof FormData !== "undefined" && request2.body instanceof FormData) {
        request2.formData = formDataToFormDataMap(request2.body);
        request2.body = void 0;
      }
      if (request2.formData) {
        const contentType = request2.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request2.body = wwwFormUrlEncode(request2.formData);
        } else {
          await prepareFormData(request2.formData, request2);
        }
        request2.formData = void 0;
      }
      return next(request2);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams();
  for (const [key2, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key2, subValue.toString());
      }
    } else {
      urlSearchParams.append(key2, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request2) {
  const contentType = request2.headers.get("Content-Type");
  if (contentType && !contentType.startsWith("multipart/form-data")) {
    return;
  }
  request2.headers.set("Content-Type", contentType ?? "multipart/form-data");
  const parts = [];
  for (const [fieldName, values2] of Object.entries(formData)) {
    for (const value of Array.isArray(values2) ? values2 : [values2]) {
      if (typeof value === "string") {
        parts.push({
          headers: createHttpHeaders$1({
            "Content-Disposition": `form-data; name="${fieldName}"`
          }),
          body: stringToUint8Array(value, "utf-8")
        });
      } else if (value === void 0 || value === null || typeof value !== "object") {
        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
      } else {
        const fileName = value.name || "blob";
        const headers = createHttpHeaders$1();
        headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
        headers.set("Content-Type", value.type || "application/octet-stream");
        parts.push({
          headers,
          body: value
        });
      }
    }
  }
  request2.multipartBody = { parts };
}
var dist$2 = {};
var dist$1 = {};
var helpers = {};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m, k);
  if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.req = helpers.json = helpers.toBuffer = void 0;
const http = __importStar$2(http$1);
const https$1 = __importStar$2(https$2);
async function toBuffer(stream2) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream2) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers.toBuffer = toBuffer;
async function json(stream2) {
  const buf = await toBuffer(stream2);
  const str = buf.toString("utf8");
  try {
    return JSON.parse(str);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str})`;
    throw err;
  }
}
helpers.json = json;
function req(url, opts = {}) {
  const href = typeof url === "string" ? url : url.href;
  const req2 = (href.startsWith("https:") ? https$1 : http).request(url, opts);
  const promise = new Promise((resolve, reject) => {
    req2.once("response", resolve).once("error", reject).end();
  });
  req2.then = promise.then.bind(promise);
  return req2;
}
helpers.req = req;
(function(exports$1) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$12) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding2(exports$12, m, p);
  };
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.Agent = void 0;
  const net2 = __importStar2(require$$0$6);
  const http2 = __importStar2(http$1);
  const https_1 = https$2;
  __exportStar(helpers, exports$1);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          try {
            return socket.addRequest(req2, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports$1.Agent = Agent;
})(dist$1);
var parseProxyResponse$1 = {};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parseProxyResponse$1, "__esModule", { value: true });
parseProxyResponse$1.parseProxyResponse = void 0;
const debug_1$2 = __importDefault$2(srcExports);
const debug$6 = (0, debug_1$2.default)("https-proxy-agent:parse-proxy-response");
function parseProxyResponse(socket) {
  return new Promise((resolve, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b)
        ondata(b);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug$6("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug$6("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug$6("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key2 = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key2];
        if (typeof current === "string") {
          headers[key2] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key2] = value;
        }
      }
      debug$6("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}
parseProxyResponse$1.parseProxyResponse = parseProxyResponse;
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m, k);
  if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$2, "__esModule", { value: true });
var HttpsProxyAgent_1 = dist$2.HttpsProxyAgent = void 0;
const net$1 = __importStar$1(require$$0$6);
const tls$1 = __importStar$1(require$$1$3);
const assert_1 = __importDefault$1(require$$2$1);
const debug_1$1 = __importDefault$1(srcExports);
const agent_base_1$1 = dist$1;
const url_1$1 = require$$5$2;
const parse_proxy_response_1 = parseProxyResponse$1;
const debug$5 = (0, debug_1$1.default)("https-proxy-agent");
const setServernameFromNonIpHost = (options) => {
  if (options.servername === void 0 && options.host && !net$1.isIP(options.host)) {
    return {
      ...options,
      servername: options.host
    };
  }
  return options;
};
class HttpsProxyAgent extends agent_base_1$1.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.options = { path: void 0 };
    this.proxy = typeof proxy === "string" ? new url_1$1.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$5("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit$1(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req2, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug$5("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls$1.connect(setServernameFromNonIpHost(this.connectOpts));
    } else {
      debug$5("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$1.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net$1.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      payload += `${name2}: ${headers[name2]}\r
`;
    }
    const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
    socket.write(`${payload}\r
`);
    const { connect, buffered } = await proxyResponsePromise;
    req2.emit("proxyConnect", connect);
    this.emit("proxyConnect", connect, req2);
    if (connect.statusCode === 200) {
      req2.once("socket", resume);
      if (opts.secureEndpoint) {
        debug$5("Upgrading socket connection to TLS");
        return tls$1.connect({
          ...omit$1(setServernameFromNonIpHost(opts), "host", "path", "port"),
          socket
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net$1.Socket({ writable: false });
    fakeSocket.readable = true;
    req2.once("socket", (s) => {
      debug$5("Replaying proxy buffer for failed request");
      (0, assert_1.default)(s.listenerCount("data") > 0);
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent.protocols = ["http", "https"];
HttpsProxyAgent_1 = dist$2.HttpsProxyAgent = HttpsProxyAgent;
function resume(socket) {
  socket.resume();
}
function omit$1(obj2, ...keys3) {
  const ret = {};
  let key2;
  for (key2 in obj2) {
    if (!keys3.includes(key2)) {
      ret[key2] = obj2[key2];
    }
  }
  return ret;
}
var dist = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m, k);
  if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist, "__esModule", { value: true });
var HttpProxyAgent_1 = dist.HttpProxyAgent = void 0;
const net = __importStar(require$$0$6);
const tls = __importStar(require$$1$3);
const debug_1 = __importDefault(srcExports);
const events_1 = require$$0$3;
const agent_base_1 = dist$1;
const url_1 = require$$5$2;
const debug$4 = (0, debug_1.default)("http-proxy-agent");
class HttpProxyAgent extends agent_base_1.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$4("Creating new HttpProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  addRequest(req2, opts) {
    req2._header = null;
    this.setRequestProps(req2, opts);
    super.addRequest(req2, opts);
  }
  setRequestProps(req2, opts) {
    const { proxy } = this;
    const protocol = opts.secureEndpoint ? "https:" : "http:";
    const hostname = req2.getHeader("host") || "localhost";
    const base2 = `${protocol}//${hostname}`;
    const url = new url_1.URL(req2.path, base2);
    if (opts.port !== 80) {
      url.port = String(opts.port);
    }
    req2.path = String(url);
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      const value = headers[name2];
      if (value) {
        req2.setHeader(name2, value);
      }
    }
  }
  async connect(req2, opts) {
    req2._header = null;
    if (!req2.path.includes("://")) {
      this.setRequestProps(req2, opts);
    }
    let first;
    let endOfHeaders;
    debug$4("Regenerating stored HTTP header string for request");
    req2._implicitHeader();
    if (req2.outputData && req2.outputData.length > 0) {
      debug$4("Patching connection write() output buffer with updated header");
      first = req2.outputData[0].data;
      endOfHeaders = first.indexOf("\r\n\r\n") + 4;
      req2.outputData[0].data = req2._header + first.substring(endOfHeaders);
      debug$4("Output buffer: %o", req2.outputData[0].data);
    }
    let socket;
    if (this.proxy.protocol === "https:") {
      debug$4("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls.connect(this.connectOpts);
    } else {
      debug$4("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    await (0, events_1.once)(socket, "connect");
    return socket;
  }
}
HttpProxyAgent.protocols = ["http", "https"];
HttpProxyAgent_1 = dist.HttpProxyAgent = HttpProxyAgent;
function omit(obj2, ...keys3) {
  const ret = {};
  let key2;
  for (key2 in obj2) {
    if (!keys3.includes(key2)) {
      ret[key2] = obj2[key2];
    }
  }
  return ret;
}
const HTTPS_PROXY = "HTTPS_PROXY";
const HTTP_PROXY = "HTTP_PROXY";
const ALL_PROXY = "ALL_PROXY";
const NO_PROXY = "NO_PROXY";
const proxyPolicyName = "proxyPolicy";
const globalNoProxyList = [];
let noProxyListLoaded = false;
const globalBypassedMap = /* @__PURE__ */ new Map();
function getEnvironmentValue(name2) {
  if (process.env[name2]) {
    return process.env[name2];
  } else if (process.env[name2.toLowerCase()]) {
    return process.env[name2.toLowerCase()];
  }
  return void 0;
}
function loadEnvironmentProxyValue() {
  if (!process) {
    return void 0;
  }
  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
  const allProxy = getEnvironmentValue(ALL_PROXY);
  const httpProxy = getEnvironmentValue(HTTP_PROXY);
  return httpsProxy || allProxy || httpProxy;
}
function isBypassed(uri2, noProxyList, bypassedMap) {
  if (noProxyList.length === 0) {
    return false;
  }
  const host = new URL(uri2).hostname;
  if (bypassedMap == null ? void 0 : bypassedMap.has(host)) {
    return bypassedMap.get(host);
  }
  let isBypassedFlag = false;
  for (const pattern of noProxyList) {
    if (pattern[0] === ".") {
      if (host.endsWith(pattern)) {
        isBypassedFlag = true;
      } else {
        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
          isBypassedFlag = true;
        }
      }
    } else {
      if (host === pattern) {
        isBypassedFlag = true;
      }
    }
  }
  bypassedMap == null ? void 0 : bypassedMap.set(host, isBypassedFlag);
  return isBypassedFlag;
}
function loadNoProxy() {
  const noProxy = getEnvironmentValue(NO_PROXY);
  noProxyListLoaded = true;
  if (noProxy) {
    return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
  }
  return [];
}
function getDefaultProxySettingsInternal() {
  const envProxy = loadEnvironmentProxyValue();
  return envProxy ? new URL(envProxy) : void 0;
}
function getUrlFromProxySettings(settings) {
  let parsedProxyUrl;
  try {
    parsedProxyUrl = new URL(settings.host);
  } catch {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
  }
  parsedProxyUrl.port = String(settings.port);
  if (settings.username) {
    parsedProxyUrl.username = settings.username;
  }
  if (settings.password) {
    parsedProxyUrl.password = settings.password;
  }
  return parsedProxyUrl;
}
function setProxyAgentOnRequest(request2, cachedAgents, proxyUrl) {
  if (request2.agent) {
    return;
  }
  const url = new URL(request2.url);
  const isInsecure = url.protocol !== "https:";
  if (request2.tlsSettings) {
    logger$o.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
  }
  const headers = request2.headers.toJSON();
  if (isInsecure) {
    if (!cachedAgents.httpProxyAgent) {
      cachedAgents.httpProxyAgent = new HttpProxyAgent_1(proxyUrl, { headers });
    }
    request2.agent = cachedAgents.httpProxyAgent;
  } else {
    if (!cachedAgents.httpsProxyAgent) {
      cachedAgents.httpsProxyAgent = new HttpsProxyAgent_1(proxyUrl, { headers });
    }
    request2.agent = cachedAgents.httpsProxyAgent;
  }
}
function proxyPolicy$1(proxySettings, options) {
  if (!noProxyListLoaded) {
    globalNoProxyList.push(...loadNoProxy());
  }
  const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
  const cachedAgents = {};
  return {
    name: proxyPolicyName,
    async sendRequest(request2, next) {
      if (!request2.proxySettings && defaultProxy && !isBypassed(request2.url, globalNoProxyList, globalBypassedMap)) {
        setProxyAgentOnRequest(request2, cachedAgents, defaultProxy);
      } else if (request2.proxySettings) {
        setProxyAgentOnRequest(request2, cachedAgents, getUrlFromProxySettings(request2.proxySettings));
      }
      return next(request2);
    }
  };
}
const agentPolicyName = "agentPolicy";
function agentPolicy$1(agent) {
  return {
    name: agentPolicyName,
    sendRequest: async (req2, next) => {
      if (!req2.agent) {
        req2.agent = agent;
      }
      return next(req2);
    }
  };
}
const tlsPolicyName = "tlsPolicy";
function tlsPolicy$1(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req2, next) => {
      if (!req2.tlsSettings) {
        req2.tlsSettings = tlsSettings;
      }
      return next(req2);
    }
  };
}
function isBlob(x) {
  return typeof x.stream === "function";
}
async function* streamAsyncIterator() {
  const reader = this.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
function makeAsyncIterable(webStream) {
  if (!webStream[Symbol.asyncIterator]) {
    webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
  }
  if (!webStream.values) {
    webStream.values = streamAsyncIterator.bind(webStream);
  }
}
function ensureNodeStream(stream2) {
  if (stream2 instanceof ReadableStream) {
    makeAsyncIterable(stream2);
    return require$$0$4.Readable.fromWeb(stream2);
  } else {
    return stream2;
  }
}
function toStream(source) {
  if (source instanceof Uint8Array) {
    return require$$0$4.Readable.from(Buffer.from(source));
  } else if (isBlob(source)) {
    return ensureNodeStream(source.stream());
  } else {
    return ensureNodeStream(source);
  }
}
async function concat$1(sources) {
  return function() {
    const streams2 = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
    return require$$0$4.Readable.from(async function* () {
      for (const stream2 of streams2) {
        for await (const chunk of stream2) {
          yield chunk;
        }
      }
    }());
  };
}
function generateBoundary() {
  return `----AzSDKFormBoundary${randomUUID()}`;
}
function encodeHeaders(headers) {
  let result = "";
  for (const [key2, value] of headers) {
    result += `${key2}: ${value}\r
`;
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if (isBlob(source)) {
    return source.size === -1 ? void 0 : source.size;
  } else {
    return void 0;
  }
}
function getTotalLength(sources) {
  let total = 0;
  for (const source of sources) {
    const partLength = getLength(source);
    if (partLength === void 0) {
      return void 0;
    } else {
      total += partLength;
    }
  }
  return total;
}
async function buildRequestBody(request2, parts, boundary) {
  const sources = [
    stringToUint8Array(`--${boundary}`, "utf-8"),
    ...parts.flatMap((part) => [
      stringToUint8Array("\r\n", "utf-8"),
      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
      stringToUint8Array("\r\n", "utf-8"),
      part.body,
      stringToUint8Array(`\r
--${boundary}`, "utf-8")
    ]),
    stringToUint8Array("--\r\n\r\n", "utf-8")
  ];
  const contentLength = getTotalLength(sources);
  if (contentLength) {
    request2.headers.set("Content-Length", contentLength);
  }
  request2.body = await concat$1(sources);
}
const multipartPolicyName$1 = "multipartPolicy";
const maxBoundaryLength = 70;
const validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
  }
  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
}
function multipartPolicy$1() {
  return {
    name: multipartPolicyName$1,
    async sendRequest(request2, next) {
      if (!request2.multipartBody) {
        return next(request2);
      }
      if (request2.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      let boundary = request2.multipartBody.boundary;
      const contentTypeHeader = request2.headers.get("Content-Type") ?? "multipart/mixed";
      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
      }
      const [, contentType, parsedBoundary] = parsedHeader;
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
      }
      boundary ?? (boundary = parsedBoundary);
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request2.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
      await buildRequestBody(request2, request2.multipartBody.parts, boundary);
      request2.multipartBody = void 0;
      return next(request2);
    }
  };
}
function createEmptyPipeline() {
  return createEmptyPipeline$1();
}
const context = createLoggerContext({
  logLevelEnvVarName: "AZURE_LOG_LEVEL",
  namespace: "azure"
});
function createClientLogger(namespace) {
  return context.createClientLogger(namespace);
}
const logger$n = createClientLogger("core-rest-pipeline");
function logPolicy(options = {}) {
  return logPolicy$1({
    logger: logger$n.info,
    ...options
  });
}
function redirectPolicy(options = {}) {
  return redirectPolicy$1(options);
}
function getHeaderName() {
  return "User-Agent";
}
async function setPlatformSpecificData(map) {
  if (process$1 && process$1.versions) {
    const osInfo = `${os$1.type()} ${os$1.release()}; ${os$1.arch()}`;
    const versions2 = process$1.versions;
    if (versions2.bun) {
      map.set("Bun", `${versions2.bun} (${osInfo})`);
    } else if (versions2.deno) {
      map.set("Deno", `${versions2.deno} (${osInfo})`);
    } else if (versions2.node) {
      map.set("Node", `${versions2.node} (${osInfo})`);
    }
  }
}
const SDK_VERSION$1 = "1.22.2";
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key2, value] of telemetryInfo) {
    const token2 = value ? `${key2}/${value}` : key2;
    parts.push(token2);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
async function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION$1);
  await setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
const UserAgentHeaderName = getUserAgentHeaderName();
const userAgentPolicyName = "userAgentPolicy";
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request2, next) {
      if (!request2.headers.has(UserAgentHeaderName)) {
        request2.headers.set(UserAgentHeaderName, await userAgentValue);
      }
      return next(request2);
    }
  };
}
let AbortError$2 = class AbortError2 extends Error {
  constructor(message2) {
    super(message2);
    this.name = "AbortError";
  }
};
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options ?? {};
  return new Promise((resolve, reject) => {
    function rejectOnAbort() {
      reject(new AbortError$2(abortErrorMsg ?? "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal2 == null ? void 0 : abortSignal2.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort == null ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal2 == null ? void 0 : abortSignal2.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x) => {
        removeListeners();
        resolve(x);
      }, (x) => {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal2 == null ? void 0 : abortSignal2.addEventListener("abort", onAbort);
  });
}
const StandardAbortMessage = "The delay was aborted.";
function delay(timeInMs, options) {
  let token2;
  const { abortSignal: abortSignal2, abortErrorMsg } = {};
  return createAbortablePromise((resolve) => {
    token2 = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token2),
    abortSignal: abortSignal2,
    abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
  });
}
function getErrorMessage(e) {
  if (isError$1(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
function isError(e) {
  return isError$1(e);
}
const isNode = isNodeLike$1;
const isNodeLike = isNodeLike$1;
const rawContent = Symbol("rawContent");
function hasRawContent(x) {
  return typeof x[rawContent] === "function";
}
function getRawContent(blob) {
  if (hasRawContent(blob)) {
    return blob[rawContent]();
  } else {
    return blob;
  }
}
const multipartPolicyName = multipartPolicyName$1;
function multipartPolicy() {
  const tspPolicy = multipartPolicy$1();
  return {
    name: multipartPolicyName,
    sendRequest: async (request2, next) => {
      if (request2.multipartBody) {
        for (const part of request2.multipartBody.parts) {
          if (hasRawContent(part.body)) {
            part.body = getRawContent(part.body);
          }
        }
      }
      return tspPolicy.sendRequest(request2, next);
    }
  };
}
function decompressResponsePolicy() {
  return decompressResponsePolicy$1();
}
function defaultRetryPolicy(options = {}) {
  return defaultRetryPolicy$1(options);
}
function formDataPolicy() {
  return formDataPolicy$1();
}
function proxyPolicy(proxySettings, options) {
  return proxyPolicy$1(proxySettings);
}
const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request2, next) {
      if (!request2.headers.has(requestIdHeaderName)) {
        request2.headers.set(requestIdHeaderName, request2.requestId);
      }
      return next(request2);
    }
  };
}
function agentPolicy(agent) {
  return agentPolicy$1(agent);
}
function tlsPolicy(tlsSettings) {
  return tlsPolicy$1(tlsSettings);
}
const knownContextKeys = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
function createTracingContext(options = {}) {
  let context2 = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context2 = context2.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context2 = context2.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context2;
}
class TracingContextImpl {
  constructor(initialContext) {
    __publicField(this, "_contextMap");
    this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
  }
  setValue(key2, value) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.set(key2, value);
    return newContext;
  }
  getValue(key2) {
    return this._contextMap.get(key2);
  }
  deleteValue(key2) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.delete(key2);
    return newContext;
  }
}
var state$4 = {};
Object.defineProperty(state$4, "__esModule", { value: true });
var state_1$1 = state$4.state = void 0;
state_1$1 = state$4.state = {
  instrumenterImplementation: void 0
};
const state$3 = state_1$1;
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    },
    addEvent: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!state$3.instrumenterImplementation) {
    state$3.instrumenterImplementation = createDefaultInstrumenter();
  }
  return state$3.instrumenterImplementation;
}
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name2, operationOptions, spanOptions) {
    var _a2;
    const startSpanResult = getInstrumenter().startSpan(name2, {
      ...spanOptions,
      packageName,
      packageVersion,
      tracingContext: (_a2 = operationOptions == null ? void 0 : operationOptions.tracingOptions) == null ? void 0 : _a2.tracingContext
    });
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: { ...operationOptions == null ? void 0 : operationOptions.tracingOptions, tracingContext }
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name2, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name2, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context2, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context2, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
const RestError = RestError$1;
function isRestError(e) {
  return isRestError$1(e);
}
const tracingPolicyName = "tracingPolicy";
function tracingPolicy(options = {}) {
  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);
  const sanitizer = new Sanitizer({
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  const tracingClient2 = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request2, next) {
      if (!tracingClient2) {
        return next(request2);
      }
      const userAgent = await userAgentPromise;
      const spanAttributes = {
        "http.url": sanitizer.sanitizeUrl(request2.url),
        "http.method": request2.method,
        "http.user_agent": userAgent,
        requestId: request2.requestId
      };
      if (userAgent) {
        spanAttributes["http.user_agent"] = userAgent;
      }
      const { span, tracingContext } = tryCreateSpan(tracingClient2, request2, spanAttributes) ?? {};
      if (!span || !tracingContext) {
        return next(request2);
      }
      try {
        const response = await tracingClient2.withContext(tracingContext, next, request2);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION$1
    });
  } catch (e) {
    logger$n.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient2, request2, spanAttributes) {
  try {
    const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request2.method}`, { tracingOptions: request2.tracingOptions }, {
      spanKind: "client",
      spanAttributes
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    const headers = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key2, value] of Object.entries(headers)) {
      request2.headers.set(key2, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger$n.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error2) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error2) ? error2 : void 0
    });
    if (isRestError(error2) && error2.statusCode) {
      span.setAttribute("http.status_code", error2.statusCode);
    }
    span.end();
  } catch (e) {
    logger$n.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    if (response.status >= 400) {
      span.setStatus({
        status: "error"
      });
    }
    span.end();
  } catch (e) {
    logger$n.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function wrapAbortSignalLike(abortSignalLike) {
  if (abortSignalLike instanceof AbortSignal) {
    return { abortSignal: abortSignalLike };
  }
  if (abortSignalLike.aborted) {
    return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
  }
  const controller = new AbortController();
  let needsCleanup = true;
  function cleanup() {
    if (needsCleanup) {
      abortSignalLike.removeEventListener("abort", listener);
      needsCleanup = false;
    }
  }
  function listener() {
    controller.abort(abortSignalLike.reason);
    cleanup();
  }
  abortSignalLike.addEventListener("abort", listener);
  return { abortSignal: controller.signal, cleanup };
}
const wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
function wrapAbortSignalLikePolicy() {
  return {
    name: wrapAbortSignalLikePolicyName,
    sendRequest: async (request2, next) => {
      if (!request2.abortSignal) {
        return next(request2);
      }
      const { abortSignal: abortSignal2, cleanup } = wrapAbortSignalLike(request2.abortSignal);
      request2.abortSignal = abortSignal2;
      try {
        return await next(request2);
      } finally {
        cleanup == null ? void 0 : cleanup();
      }
    }
  };
}
function createPipelineFromOptions(options) {
  var _a2;
  const pipeline = createEmptyPipeline();
  if (isNodeLike) {
    if (options.agent) {
      pipeline.addPolicy(agentPolicy(options.agent));
    }
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(wrapAbortSignalLikePolicy());
  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a2 = options.telemetryOptions) == null ? void 0 : _a2.clientRequestIdHeaderName));
  pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy({ ...options.userAgentOptions, ...options.loggingOptions }), {
    afterPhase: "Retry"
  });
  if (isNodeLike) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
function createDefaultHttpClient() {
  const client = createDefaultHttpClient$1();
  return {
    async sendRequest(request2) {
      const { abortSignal: abortSignal2, cleanup } = request2.abortSignal ? wrapAbortSignalLike(request2.abortSignal) : {};
      try {
        request2.abortSignal = abortSignal2;
        return await client.sendRequest(request2);
      } finally {
        cleanup == null ? void 0 : cleanup();
      }
    }
  };
}
function createHttpHeaders(rawHeaders) {
  return createHttpHeaders$1(rawHeaders);
}
function createPipelineRequest(options) {
  return createPipelineRequest$1(options);
}
const DEFAULT_CYCLER_OPTIONS = {
  forcedRefreshWindowInMs: 1e3,
  // Force waiting for a refresh 1s before the token expires
  retryIntervalInMs: 3e3,
  // Allow refresh attempts every 3s
  refreshWindowInMs: 1e3 * 60 * 2
  // Start refreshing 2m before expiry
};
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token2 = await tryGetAccessToken();
  while (token2 === null) {
    await delay(retryIntervalInMs);
    token2 = await tryGetAccessToken();
  }
  return token2;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token2 = null;
  let tenantId;
  const options = {
    ...DEFAULT_CYCLER_OPTIONS,
    ...tokenCyclerOptions
  };
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      if (cycler.isRefreshing) {
        return false;
      }
      if ((token2 == null ? void 0 : token2.refreshAfterTimestamp) && token2.refreshAfterTimestamp < Date.now()) {
        return true;
      }
      return ((token2 == null ? void 0 : token2.expiresOnTimestamp) ?? 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token2 === null || token2.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (token2 == null ? void 0 : token2.expiresOnTimestamp) ?? Date.now()
      ).then((_token2) => {
        refreshWorker = null;
        token2 = _token2;
        tenantId = getTokenOptions.tenantId;
        return token2;
      }).catch((reason) => {
        refreshWorker = null;
        token2 = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const hasClaimChallenge = Boolean(tokenOptions.claims);
    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
    if (hasClaimChallenge) {
      token2 = null;
    }
    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
    if (mustRefresh) {
      return refresh(scopes, tokenOptions);
    }
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token2;
  };
}
const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
async function trySendRequest(request2, next) {
  try {
    return [await next(request2), void 0];
  } catch (e) {
    if (isRestError(e) && e.response) {
      return [e.response, e];
    } else {
      throw e;
    }
  }
}
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request: request2 } = options;
  const getTokenOptions = {
    abortSignal: request2.abortSignal,
    tracingOptions: request2.tracingOptions,
    enableCae: true
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function isChallengeResponse(response) {
  return response.status === 401 && response.headers.has("WWW-Authenticate");
}
async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
  const { scopes } = onChallengeOptions;
  const accessToken = await onChallengeOptions.getAccessToken(scopes, {
    enableCae: true,
    claims: caeClaims
  });
  if (!accessToken) {
    return false;
  }
  onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
  return true;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a2, _b2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger2 = options.logger || logger$n;
  const callbacks = {
    authorizeRequest: ((_a2 = challengeCallbacks == null ? void 0 : challengeCallbacks.authorizeRequest) == null ? void 0 : _a2.bind(challengeCallbacks)) ?? defaultAuthorizeRequest,
    authorizeRequestOnChallenge: (_b2 = challengeCallbacks == null ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) == null ? void 0 : _b2.bind(challengeCallbacks)
  };
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request2, next) {
      if (!request2.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request: request2,
        getAccessToken,
        logger: logger2
      });
      let response;
      let error2;
      let shouldSendRequest;
      [response, error2] = await trySendRequest(request2, next);
      if (isChallengeResponse(response)) {
        let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
        if (claims) {
          let parsedClaim;
          try {
            parsedClaim = atob(claims);
          } catch (e) {
            logger2.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
            return response;
          }
          shouldSendRequest = await authorizeRequestOnCaeChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            response,
            request: request2,
            getAccessToken,
            logger: logger2
          }, parsedClaim);
          if (shouldSendRequest) {
            [response, error2] = await trySendRequest(request2, next);
          }
        } else if (callbacks.authorizeRequestOnChallenge) {
          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request: request2,
            response,
            getAccessToken,
            logger: logger2
          });
          if (shouldSendRequest) {
            [response, error2] = await trySendRequest(request2, next);
          }
          if (isChallengeResponse(response)) {
            claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e) {
                logger2.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response,
                request: request2,
                getAccessToken,
                logger: logger2
              }, parsedClaim);
              if (shouldSendRequest) {
                [response, error2] = await trySendRequest(request2, next);
              }
            }
          }
        }
      }
      if (error2) {
        throw error2;
      } else {
        return response;
      }
    }
  };
}
function parseChallenges(challenges) {
  const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
  const paramRegex = /(\w+)="([^"]*)"/g;
  const parsedChallenges = [];
  let match;
  while ((match = challengeRegex.exec(challenges)) !== null) {
    const scheme = match[1];
    const paramsString = match[2];
    const params = {};
    let paramMatch;
    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
      params[paramMatch[1]] = paramMatch[2];
    }
    parsedChallenges.push({ scheme, params });
  }
  return parsedChallenges;
}
function getCaeChallengeClaims(challenges) {
  var _a2;
  if (!challenges) {
    return;
  }
  const parsedChallenges = parseChallenges(challenges);
  return (_a2 = parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")) == null ? void 0 : _a2.params.claims;
}
var state$2 = {};
Object.defineProperty(state$2, "__esModule", { value: true });
var state_1 = state$2.state = void 0;
state_1 = state$2.state = {
  operationRequestMap: /* @__PURE__ */ new WeakMap()
};
const state$1 = state_1;
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
const originalRequestSymbol = Symbol.for("@azure/core-client original request");
function hasOriginalRequest(request2) {
  return originalRequestSymbol in request2;
}
function getOperationRequestInfo(request2) {
  if (hasOriginalRequest(request2)) {
    return getOperationRequestInfo(request2[originalRequestSymbol]);
  }
  let info = state$1.operationRequestMap.get(request2);
  if (!info) {
    info = {};
    state$1.operationRequestMap.set(request2, info);
  }
  return info;
}
const defaultJsonContentTypes = ["application/json", "text/json"];
const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
const deserializationPolicyName = "deserializationPolicy";
function deserializationPolicy(options = {}) {
  var _a2, _b2;
  const jsonContentTypes = ((_a2 = options.expectedContentTypes) == null ? void 0 : _a2.json) ?? defaultJsonContentTypes;
  const xmlContentTypes = ((_b2 = options.expectedContentTypes) == null ? void 0 : _b2.xml) ?? defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (serializerOptions == null ? void 0 : serializerOptions.xml.rootName) ?? "",
      includeRoot: (serializerOptions == null ? void 0 : serializerOptions.xml.includeRoot) ?? false,
      xmlCharKey: (serializerOptions == null ? void 0 : serializerOptions.xml.xmlCharKey) ?? XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request2, next) {
      const response = await next(request2);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request2 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request2);
  const operationSpec = operationInfo == null ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo == null ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo == null ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request2 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request2);
  const shouldDeserialize = operationInfo == null ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo == null ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error: error2, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error2) {
    throw error2;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a2, _b2, _c, _d, _e;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
  const initialErrorMessage = ((_a2 = parsedResponse.request.streamResponseStatusCodes) == null ? void 0 : _a2.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error2 = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec && !(((_c = (_b2 = parsedResponse.parsedBody) == null ? void 0 : _b2.error) == null ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) == null ? void 0 : _d.error) == null ? void 0 : _e.message))) {
    throw error2;
  }
  const defaultBodyMapper = errorResponseSpec == null ? void 0 : errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec == null ? void 0 : errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error2.code = internalError.code;
      if (internalError.message) {
        error2.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error2.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error2.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error2.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error: error2, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a2;
  if (!((_a2 = operationResponse.request.streamResponseStatusCodes) == null ? void 0 : _a2.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text2 = operationResponse.bodyAsText;
    const contentType = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text2);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML(text2, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
const serializationPolicyName = "serializationPolicy";
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request2, next) {
      const operationInfo = getOperationRequestInfo(request2);
      const operationSpec = operationInfo == null ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo == null ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request2, operationArguments, operationSpec);
        serializeRequestBody(request2, operationArguments, operationSpec, stringifyXML);
      }
      return next(request2);
    }
  };
}
function serializeHeaders(request2, operationArguments, operationSpec) {
  var _a2, _b2;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key2 of Object.keys(headerValue)) {
            request2.headers.set(headerCollectionPrefix + key2, headerValue[key2]);
          }
        } else {
          request2.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b2 = (_a2 = operationArguments.options) == null ? void 0 : _a2.requestOptions) == null ? void 0 : _b2.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request2.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request2, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a2, _b2;
  const serializerOptions = (_a2 = operationArguments.options) == null ? void 0 : _a2.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (serializerOptions == null ? void 0 : serializerOptions.xml.rootName) ?? "",
      includeRoot: (serializerOptions == null ? void 0 : serializerOptions.xml.includeRoot) ?? false,
      xmlCharKey: (serializerOptions == null ? void 0 : serializerOptions.xml.xmlCharKey) ?? XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request2.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request2.body !== void 0 && request2.body !== null || nullable && request2.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request2.body = operationSpec.serializer.serialize(bodyMapper, request2.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request2.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request2.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request2.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_b2 = operationSpec.contentType) == null ? void 0 : _b2.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request2.body = JSON.stringify(request2.body);
        }
      }
    } catch (error2) {
      throw new Error(`Error "${error2.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request2.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request2.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj2, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj2)) {
    obj2 = [obj2];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj2 };
  }
  const result = { [elementName]: obj2 };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options ?? {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
let cachedHttpClient;
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}
const CollectionFormatToDelimiterMap = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "	",
  Pipes: "|"
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path2 = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path2.startsWith("/")) {
      path2 = path2.substring(1);
    }
    if (isAbsoluteUrl(path2)) {
      requestUrl = path2;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path2);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  if ((_a2 = operationSpec.urlParameters) == null ? void 0 : _a2.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path2 = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path2;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a2 = operationSpec.queryParameters) == null ? void 0 : _a2.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name2, value] = pair.split("=", 2);
    const existingValue = result.get(name2);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name2, [existingValue, value]);
      }
    } else {
      result.set(name2, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name2, value] of queryParams) {
    const existingValue = combinedParams.get(name2);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name2, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name2)) {
        combinedParams.set(name2, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name2, value);
      }
    } else {
      combinedParams.set(name2, value);
    }
  }
  const searchPieces = [];
  for (const [name2, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name2}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name2}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name2}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
const logger$m = createClientLogger("core-client");
class ServiceClient {
  /**
   * The ServiceClient constructor
   * @param options - The service client options that govern the behavior of the client.
   */
  constructor(options = {}) {
    /**
     * If specified, this is the base URI that requests will be made against for this ServiceClient.
     * If it is not specified, then all OperationSpecs must contain a baseUrl property.
     */
    __publicField(this, "_endpoint");
    /**
     * The default request content type for the service.
     * Used if no requestContentType is present on an OperationSpec.
     */
    __publicField(this, "_requestContentType");
    /**
     * Set to true if the request is sent over HTTP instead of HTTPS
     */
    __publicField(this, "_allowInsecureConnection");
    /**
     * The HTTP client that will be used to send requests.
     */
    __publicField(this, "_httpClient");
    /**
     * The pipeline used by this client to make requests
     */
    __publicField(this, "pipeline");
    var _a2;
    this._requestContentType = options.requestContentType;
    this._endpoint = options.endpoint ?? options.baseUri;
    if (options.baseUri) {
      logger$m.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
    }
    this._allowInsecureConnection = options.allowInsecureConnection;
    this._httpClient = options.httpClient || getCachedDefaultHttpClient();
    this.pipeline = options.pipeline || createDefaultPipeline(options);
    if ((_a2 = options.additionalPolicies) == null ? void 0 : _a2.length) {
      for (const { policy, position } of options.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : void 0;
        this.pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    }
  }
  /**
   * Send the provided httpRequest.
   */
  async sendRequest(request2) {
    return this.pipeline.sendRequest(this._httpClient, request2);
  }
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @typeParam T - The typed result of the request, based on the OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   */
  async sendOperationRequest(operationArguments, operationSpec) {
    const endpoint = operationSpec.baseUrl || this._endpoint;
    if (!endpoint) {
      throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
    }
    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
    const request2 = createPipelineRequest({
      url
    });
    request2.method = operationSpec.httpMethod;
    const operationInfo = getOperationRequestInfo(request2);
    operationInfo.operationSpec = operationSpec;
    operationInfo.operationArguments = operationArguments;
    const contentType = operationSpec.contentType || this._requestContentType;
    if (contentType && operationSpec.requestBody) {
      request2.headers.set("Content-Type", contentType);
    }
    const options = operationArguments.options;
    if (options) {
      const requestOptions = options.requestOptions;
      if (requestOptions) {
        if (requestOptions.timeout) {
          request2.timeout = requestOptions.timeout;
        }
        if (requestOptions.onUploadProgress) {
          request2.onUploadProgress = requestOptions.onUploadProgress;
        }
        if (requestOptions.onDownloadProgress) {
          request2.onDownloadProgress = requestOptions.onDownloadProgress;
        }
        if (requestOptions.shouldDeserialize !== void 0) {
          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
        }
        if (requestOptions.allowInsecureConnection) {
          request2.allowInsecureConnection = true;
        }
      }
      if (options.abortSignal) {
        request2.abortSignal = options.abortSignal;
      }
      if (options.tracingOptions) {
        request2.tracingOptions = options.tracingOptions;
      }
    }
    if (this._allowInsecureConnection) {
      request2.allowInsecureConnection = true;
    }
    if (request2.streamResponseStatusCodes === void 0) {
      request2.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
    }
    try {
      const rawResponse = await this.sendRequest(request2);
      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
      if (options == null ? void 0 : options.onResponse) {
        options.onResponse(rawResponse, flatResponse);
      }
      return flatResponse;
    } catch (error2) {
      if (typeof error2 === "object" && (error2 == null ? void 0 : error2.response)) {
        const rawResponse = error2.response;
        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error2.statusCode] || operationSpec.responses["default"]);
        error2.details = flatResponse;
        if (options == null ? void 0 : options.onResponse) {
          options.onResponse(rawResponse, flatResponse, error2);
        }
      }
      throw error2;
    }
  }
}
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline({
    ...options,
    credentialOptions
  });
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
const listenersMap = /* @__PURE__ */ new WeakMap();
const abortedMap = /* @__PURE__ */ new WeakMap();
let AbortSignal$2 = class AbortSignal2 {
  constructor() {
    this.onabort = null;
    listenersMap.set(this, []);
    abortedMap.set(this, false);
  }
  /**
   * Status of whether aborted or not.
   *
   * @readonly
   */
  get aborted() {
    if (!abortedMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    return abortedMap.get(this);
  }
  /**
   * Creates a new AbortSignal instance that will never be aborted.
   *
   * @readonly
   */
  static get none() {
    return new AbortSignal2();
  }
  /**
   * Added new "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be added
   */
  addEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    listeners.push(listener);
  }
  /**
   * Remove "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be removed
   */
  removeEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    const index = listeners.indexOf(listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
  /**
   * Dispatches a synthetic event to the AbortSignal.
   */
  dispatchEvent(_event) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  }
};
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
let AbortError$1 = class AbortError3 extends Error {
  constructor(message2) {
    super(message2);
    this.name = "AbortError";
  }
};
let AbortController$2 = class AbortController2 {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(parentSignals) {
    this._signal = new AbortSignal$2();
    if (!parentSignals) {
      return;
    }
    if (!Array.isArray(parentSignals)) {
      parentSignals = arguments;
    }
    for (const parentSignal of parentSignals) {
      if (parentSignal.aborted) {
        this.abort();
      } else {
        parentSignal.addEventListener("abort", () => {
          this.abort();
        });
      }
    }
  }
  /**
   * The AbortSignal associated with this controller that will signal aborted
   * when the abort method is called on this controller.
   *
   * @readonly
   */
  get signal() {
    return this._signal;
  }
  /**
   * Signal that any operations passed this controller's associated abort signal
   * to cancel any remaining work and throw an `AbortError`.
   */
  abort() {
    abortSignal(this._signal);
  }
  /**
   * Creates a new AbortSignal instance that will abort after the provided ms.
   * @param ms - Elapsed time in milliseconds to trigger an abort.
   */
  static timeout(ms2) {
    const signal = new AbortSignal$2();
    const timer = setTimeout(abortSignal, ms2, signal);
    if (typeof timer.unref === "function") {
      timer.unref();
    }
    return signal;
  }
};
function isErrorResponse(errorResponse) {
  return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
}
const CredentialUnavailableErrorName = "CredentialUnavailableError";
class CredentialUnavailableError extends Error {
  constructor(message2) {
    super(message2);
    this.name = CredentialUnavailableErrorName;
  }
}
const AuthenticationErrorName = "AuthenticationError";
class AuthenticationError extends Error {
  // eslint-disable-next-line @typescript-eslint/ban-types
  constructor(statusCode, errorBody) {
    let errorResponse = {
      error: "unknown",
      errorDescription: "An unknown error occurred and no additional details are available."
    };
    if (isErrorResponse(errorBody)) {
      errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
    } else if (typeof errorBody === "string") {
      try {
        const oauthErrorResponse = JSON.parse(errorBody);
        errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
      } catch (e) {
        if (statusCode === 400) {
          errorResponse = {
            error: "authority_not_found",
            errorDescription: "The specified authority URL was not found."
          };
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
          };
        }
      }
    } else {
      errorResponse = {
        error: "unknown_error",
        errorDescription: "An unknown error occurred and no additional details are available."
      };
    }
    super(`${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription}`);
    this.statusCode = statusCode;
    this.errorResponse = errorResponse;
    this.name = AuthenticationErrorName;
  }
}
const AggregateAuthenticationErrorName = "AggregateAuthenticationError";
class AggregateAuthenticationError extends Error {
  constructor(errors2, errorMessage) {
    const errorDetail = errors2.join("\n");
    super(`${errorMessage}
${errorDetail}`);
    this.errors = errors2;
    this.name = AggregateAuthenticationErrorName;
  }
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
  return {
    error: errorBody.error,
    errorDescription: errorBody.error_description,
    correlationId: errorBody.correlation_id,
    errorCodes: errorBody.error_codes,
    timestamp: errorBody.timestamp,
    traceId: errorBody.trace_id
  };
}
class AuthenticationRequiredError extends Error {
  constructor(options) {
    super(options.message);
    this.scopes = options.scopes;
    this.getTokenOptions = options.getTokenOptions;
    this.name = "AuthenticationRequiredError";
  }
}
function getIdentityTokenEndpointSuffix(tenantId) {
  if (tenantId === "adfs") {
    return "oauth2/token";
  } else {
    return "oauth2/v2.0/token";
  }
}
const SDK_VERSION = `2.1.0`;
const DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
const DefaultTenantId = "common";
var AzureAuthorityHosts;
(function(AzureAuthorityHosts2) {
  AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
  AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
  AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
  AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
})(AzureAuthorityHosts || (AzureAuthorityHosts = {}));
const DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
const tracingClient = createTracingClient({
  namespace: "Microsoft.AAD",
  packageName: "@azure/identity",
  packageVersion: SDK_VERSION
});
const logger$l = createClientLogger("identity");
function processEnvVars(supportedEnvVars) {
  return supportedEnvVars.reduce((acc, envVariable) => {
    if (process.env[envVariable]) {
      acc.assigned.push(envVariable);
    } else {
      acc.missing.push(envVariable);
    }
    return acc;
  }, { missing: [], assigned: [] });
}
function formatSuccess(scope) {
  return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
function formatError(scope, error2) {
  let message2 = "ERROR.";
  if (scope === null || scope === void 0 ? void 0 : scope.length) {
    message2 += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
  }
  return `${message2} Error message: ${typeof error2 === "string" ? error2 : error2.message}.`;
}
function credentialLoggerInstance(title, parent, log2 = logger$l) {
  const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
  function info(message2) {
    log2.info(`${fullTitle} =>`, message2);
  }
  function warning(message2) {
    log2.warning(`${fullTitle} =>`, message2);
  }
  return {
    title,
    fullTitle,
    info,
    warning
  };
}
function credentialLogger(title, log2 = logger$l) {
  const credLogger = credentialLoggerInstance(title, void 0, log2);
  return Object.assign(Object.assign({}, credLogger), { parent: log2, getToken: credentialLoggerInstance("=> getToken()", credLogger, log2) });
}
const noCorrelationId = "noCorrelationId";
function getIdentityClientAuthorityHost(options) {
  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
  if (isNode) {
    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
  }
  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
class IdentityClient extends ServiceClient {
  constructor(options) {
    var _a2, _b2;
    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;
    const userAgentPrefix = ((_a2 = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a2 === void 0 ? void 0 : _a2.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const baseUri = getIdentityClientAuthorityHost(options);
    if (!baseUri.startsWith("https:")) {
      throw new Error("The authorityHost address must use the 'https' protocol.");
    }
    super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
      maxRetries: 3
    } }, options), { userAgentOptions: {
      userAgentPrefix
    }, baseUri }));
    this.authorityHost = baseUri;
    this.abortControllers = /* @__PURE__ */ new Map();
    this.allowLoggingAccountIdentifiers = (_b2 = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b2 === void 0 ? void 0 : _b2.allowLoggingAccountIdentifiers;
  }
  async sendTokenRequest(request2, expiresOnParser2) {
    logger$l.info(`IdentityClient: sending token request to [${request2.url}]`);
    const response = await this.sendRequest(request2);
    expiresOnParser2 = expiresOnParser2 || ((responseBody) => {
      return Date.now() + responseBody.expires_in * 1e3;
    });
    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
      const parsedBody = JSON.parse(response.bodyAsText);
      if (!parsedBody.access_token) {
        return null;
      }
      this.logIdentifiers(response);
      const token2 = {
        accessToken: {
          token: parsedBody.access_token,
          expiresOnTimestamp: expiresOnParser2(parsedBody)
        },
        refreshToken: parsedBody.refresh_token
      };
      logger$l.info(`IdentityClient: [${request2.url}] token acquired, expires on ${token2.accessToken.expiresOnTimestamp}`);
      return token2;
    } else {
      const error2 = new AuthenticationError(response.status, response.bodyAsText);
      logger$l.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error2.errorResponse.errorDescription}`);
      throw error2;
    }
  }
  async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser2, options = {}) {
    if (refreshToken === void 0) {
      return null;
    }
    logger$l.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
    const refreshParams = {
      grant_type: "refresh_token",
      client_id: clientId,
      refresh_token: refreshToken,
      scope: scopes
    };
    if (clientSecret !== void 0) {
      refreshParams.client_secret = clientSecret;
    }
    const query = new URLSearchParams(refreshParams);
    return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
      try {
        const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
        const request2 = createPipelineRequest({
          url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
          method: "POST",
          body: query.toString(),
          abortSignal: options.abortSignal,
          headers: createHttpHeaders({
            Accept: "application/json",
            "Content-Type": "application/x-www-form-urlencoded"
          }),
          tracingOptions: updatedOptions.tracingOptions
        });
        const response = await this.sendTokenRequest(request2, expiresOnParser2);
        logger$l.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
        return response;
      } catch (err) {
        if (err.name === AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
          logger$l.info(`IdentityClient: interaction required for client ID: ${clientId}`);
          return null;
        } else {
          logger$l.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
          throw err;
        }
      }
    });
  }
  // Here is a custom layer that allows us to abort requests that go through MSAL,
  // since MSAL doesn't allow us to pass options all the way through.
  generateAbortSignal(correlationId) {
    const controller = new AbortController$2();
    const controllers = this.abortControllers.get(correlationId) || [];
    controllers.push(controller);
    this.abortControllers.set(correlationId, controllers);
    const existingOnAbort = controller.signal.onabort;
    controller.signal.onabort = (...params) => {
      this.abortControllers.set(correlationId, void 0);
      if (existingOnAbort) {
        existingOnAbort(...params);
      }
    };
    return controller.signal;
  }
  abortRequests(correlationId) {
    const key2 = correlationId || noCorrelationId;
    const controllers = [
      ...this.abortControllers.get(key2) || [],
      // MSAL passes no correlation ID to the get requests...
      ...this.abortControllers.get(noCorrelationId) || []
    ];
    if (!controllers.length) {
      return;
    }
    for (const controller of controllers) {
      controller.abort();
    }
    this.abortControllers.set(key2, void 0);
  }
  getCorrelationId(options) {
    var _a2;
    const parameter = (_a2 = options === null || options === void 0 ? void 0 : options.body) === null || _a2 === void 0 ? void 0 : _a2.split("&").map((part) => part.split("=")).find(([key2]) => key2 === "client-request-id");
    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
  }
  // The MSAL network module methods follow
  async sendGetRequestAsync(url, options) {
    const request2 = createPipelineRequest({
      url,
      method: "GET",
      body: options === null || options === void 0 ? void 0 : options.body,
      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
      abortSignal: this.generateAbortSignal(noCorrelationId)
    });
    const response = await this.sendRequest(request2);
    this.logIdentifiers(response);
    return {
      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
      headers: response.headers.toJSON(),
      status: response.status
    };
  }
  async sendPostRequestAsync(url, options) {
    const request2 = createPipelineRequest({
      url,
      method: "POST",
      body: options === null || options === void 0 ? void 0 : options.body,
      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
      // MSAL doesn't send the correlation ID on the get requests.
      abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
    });
    const response = await this.sendRequest(request2);
    this.logIdentifiers(response);
    return {
      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
      headers: response.headers.toJSON(),
      status: response.status
    };
  }
  /**
   * If allowLoggingAccountIdentifiers was set on the constructor options
   * we try to log the account identifiers by parsing the received access token.
   *
   * The account identifiers we try to log are:
   * - `appid`: The application or Client Identifier.
   * - `upn`: User Principal Name.
   *   - It might not be available in some authentication scenarios.
   *   - If it's not available, we put a placeholder: "No User Principal Name available".
   * - `tid`: Tenant Identifier.
   * - `oid`: Object Identifier of the authenticated user.
   */
  logIdentifiers(response) {
    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
      return;
    }
    const unavailableUpn = "No User Principal Name available";
    try {
      const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
      const accessToken = parsed.access_token;
      if (!accessToken) {
        return;
      }
      const base64Metadata = accessToken.split(".")[1];
      const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
      logger$l.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
    } catch (e) {
      logger$l.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
    }
  }
}
function checkTenantId(logger2, tenantId) {
  if (!tenantId.match(/^[0-9a-zA-Z-.:/]+$/)) {
    const error2 = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://docs.microsoft.com/partner-center/find-ids-and-domain-names.");
    logger2.info(formatError("", error2));
    throw error2;
  }
}
function resolveTenantId(logger2, tenantId, clientId) {
  if (tenantId) {
    checkTenantId(logger2, tenantId);
    return tenantId;
  }
  if (!clientId) {
    clientId = DeveloperSignOnClientId;
  }
  if (clientId !== DeveloperSignOnClientId) {
    return "common";
  }
  return "organizations";
}
/*! @azure/msal-common v7.6.0 2022-10-10 */
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
  LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
})(LogLevel || (LogLevel = {}));
const LatestAuthenticationRecordVersion = "1.0";
function ensureValidMsalToken(scopes, logger2, msalToken, getTokenOptions) {
  const error2 = (message2) => {
    logger2.getToken.info(message2);
    return new AuthenticationRequiredError({
      scopes: Array.isArray(scopes) ? scopes : [scopes],
      getTokenOptions,
      message: message2
    });
  };
  if (!msalToken) {
    throw error2("No response");
  }
  if (!msalToken.expiresOn) {
    throw error2(`Response had no "expiresOn" property.`);
  }
  if (!msalToken.accessToken) {
    throw error2(`Response had no "accessToken" property.`);
  }
}
function getAuthority(tenantId, host) {
  if (!host) {
    host = DefaultAuthorityHost;
  }
  if (new RegExp(`${tenantId}/?$`).test(host)) {
    return host;
  }
  if (host.endsWith("/")) {
    return host + tenantId;
  } else {
    return `${host}/${tenantId}`;
  }
}
function getKnownAuthorities(tenantId, authorityHost) {
  if (tenantId === "adfs" && authorityHost) {
    return [authorityHost];
  }
  return [];
}
const defaultLoggerCallback = (logger2, platform2 = isNode ? "Node" : "Browser") => (level, message2, containsPii) => {
  if (containsPii) {
    return;
  }
  switch (level) {
    case LogLevel.Error:
      logger2.info(`MSAL ${platform2} V2 error: ${message2}`);
      return;
    case LogLevel.Info:
      logger2.info(`MSAL ${platform2} V2 info message: ${message2}`);
      return;
    case LogLevel.Verbose:
      logger2.info(`MSAL ${platform2} V2 verbose message: ${message2}`);
      return;
    case LogLevel.Warning:
      logger2.info(`MSAL ${platform2} V2 warning: ${message2}`);
      return;
  }
};
class MsalBaseUtilities {
  constructor(options) {
    this.logger = options.logger;
    this.account = options.authenticationRecord;
  }
  /**
   * Generates a UUID
   */
  generateUuid() {
    return v4();
  }
  /**
   * Handles the MSAL authentication result.
   * If the result has an account, we update the local account reference.
   * If the token received is invalid, an error will be thrown depending on what's missing.
   */
  handleResult(scopes, clientId, result, getTokenOptions) {
    if (result === null || result === void 0 ? void 0 : result.account) {
      this.account = msalToPublic(clientId, result.account);
    }
    ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);
    this.logger.getToken.info(formatSuccess(scopes));
    return {
      token: result.accessToken,
      expiresOnTimestamp: result.expiresOn.getTime()
    };
  }
  /**
   * Handles MSAL errors.
   */
  handleError(scopes, error2, getTokenOptions) {
    if (error2.name === "AuthError" || error2.name === "ClientAuthError" || error2.name === "BrowserAuthError") {
      const msalError = error2;
      switch (msalError.errorCode) {
        case "endpoints_resolution_error":
          this.logger.info(formatError(scopes, error2.message));
          return new CredentialUnavailableError(error2.message);
        case "device_code_polling_cancelled":
          return new AbortError$1("The authentication has been aborted by the caller.");
        case "consent_required":
        case "interaction_required":
        case "login_required":
          this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
          break;
        default:
          this.logger.info(formatError(scopes, `Failed to acquire token: ${error2.message}`));
          break;
      }
    }
    if (error2.name === "ClientConfigurationError" || error2.name === "BrowserConfigurationAuthError" || error2.name === "AbortError") {
      return error2;
    }
    return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error2.message });
  }
}
function publicToMsal(account) {
  const [environment] = account.authority.match(/([a-z]*\.[a-z]*\.[a-z]*)/) || [];
  return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });
}
function msalToPublic(clientId, account) {
  const record = {
    authority: getAuthority(account.tenantId, account.environment),
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId || DefaultTenantId,
    username: account.username,
    clientId,
    version: LatestAuthenticationRecordVersion
  };
  return record;
}
function serializeAuthenticationRecord(record) {
  return JSON.stringify(record);
}
function deserializeAuthenticationRecord(serializedRecord) {
  const parsed = JSON.parse(serializedRecord);
  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
    throw Error("Unsupported AuthenticationRecord version");
  }
  return parsed;
}
const multiTenantDisabledErrorMessage = "A getToken request was attempted with a tenant different than the tenant configured at the initialization of the credential, but multi-tenant authentication has been disabled by the environment variable AZURE_IDENTITY_DISABLE_MULTITENANTAUTH.";
const multiTenantADFSErrorMessage = "A new tenant Id can't be assigned through the GetTokenOptions when a credential has been originally configured to use the tenant `adfs`.";
function processMultiTenantRequest(tenantId, getTokenOptions) {
  if (!(getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId)) {
    return tenantId;
  }
  if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
    throw new Error(multiTenantDisabledErrorMessage);
  }
  if (tenantId === "adfs") {
    throw new Error(multiTenantADFSErrorMessage);
  }
  return getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId;
}
var RegionalAuthority;
(function(RegionalAuthority2) {
  RegionalAuthority2["AutoDiscoverRegion"] = "AutoDiscoverRegion";
  RegionalAuthority2["USWest"] = "westus";
  RegionalAuthority2["USWest2"] = "westus2";
  RegionalAuthority2["USCentral"] = "centralus";
  RegionalAuthority2["USEast"] = "eastus";
  RegionalAuthority2["USEast2"] = "eastus2";
  RegionalAuthority2["USNorthCentral"] = "northcentralus";
  RegionalAuthority2["USSouthCentral"] = "southcentralus";
  RegionalAuthority2["USWestCentral"] = "westcentralus";
  RegionalAuthority2["CanadaCentral"] = "canadacentral";
  RegionalAuthority2["CanadaEast"] = "canadaeast";
  RegionalAuthority2["BrazilSouth"] = "brazilsouth";
  RegionalAuthority2["EuropeNorth"] = "northeurope";
  RegionalAuthority2["EuropeWest"] = "westeurope";
  RegionalAuthority2["UKSouth"] = "uksouth";
  RegionalAuthority2["UKWest"] = "ukwest";
  RegionalAuthority2["FranceCentral"] = "francecentral";
  RegionalAuthority2["FranceSouth"] = "francesouth";
  RegionalAuthority2["SwitzerlandNorth"] = "switzerlandnorth";
  RegionalAuthority2["SwitzerlandWest"] = "switzerlandwest";
  RegionalAuthority2["GermanyNorth"] = "germanynorth";
  RegionalAuthority2["GermanyWestCentral"] = "germanywestcentral";
  RegionalAuthority2["NorwayWest"] = "norwaywest";
  RegionalAuthority2["NorwayEast"] = "norwayeast";
  RegionalAuthority2["AsiaEast"] = "eastasia";
  RegionalAuthority2["AsiaSouthEast"] = "southeastasia";
  RegionalAuthority2["JapanEast"] = "japaneast";
  RegionalAuthority2["JapanWest"] = "japanwest";
  RegionalAuthority2["AustraliaEast"] = "australiaeast";
  RegionalAuthority2["AustraliaSouthEast"] = "australiasoutheast";
  RegionalAuthority2["AustraliaCentral"] = "australiacentral";
  RegionalAuthority2["AustraliaCentral2"] = "australiacentral2";
  RegionalAuthority2["IndiaCentral"] = "centralindia";
  RegionalAuthority2["IndiaSouth"] = "southindia";
  RegionalAuthority2["IndiaWest"] = "westindia";
  RegionalAuthority2["KoreaSouth"] = "koreasouth";
  RegionalAuthority2["KoreaCentral"] = "koreacentral";
  RegionalAuthority2["UAECentral"] = "uaecentral";
  RegionalAuthority2["UAENorth"] = "uaenorth";
  RegionalAuthority2["SouthAfricaNorth"] = "southafricanorth";
  RegionalAuthority2["SouthAfricaWest"] = "southafricawest";
  RegionalAuthority2["ChinaNorth"] = "chinanorth";
  RegionalAuthority2["ChinaEast"] = "chinaeast";
  RegionalAuthority2["ChinaNorth2"] = "chinanorth2";
  RegionalAuthority2["ChinaEast2"] = "chinaeast2";
  RegionalAuthority2["GermanyCentral"] = "germanycentral";
  RegionalAuthority2["GermanyNorthEast"] = "germanynortheast";
  RegionalAuthority2["GovernmentUSVirginia"] = "usgovvirginia";
  RegionalAuthority2["GovernmentUSIowa"] = "usgoviowa";
  RegionalAuthority2["GovernmentUSArizona"] = "usgovarizona";
  RegionalAuthority2["GovernmentUSTexas"] = "usgovtexas";
  RegionalAuthority2["GovernmentUSDodEast"] = "usdodeast";
  RegionalAuthority2["GovernmentUSDodCentral"] = "usdodcentral";
})(RegionalAuthority || (RegionalAuthority = {}));
let persistenceProvider = void 0;
const msalNodeFlowCacheControl = {
  setPersistence(pluginProvider) {
    persistenceProvider = pluginProvider;
  }
};
class MsalNode extends MsalBaseUtilities {
  constructor(options) {
    var _a2, _b2, _c;
    super(options);
    this.requiresConfidential = false;
    this.msalConfig = this.defaultNodeMsalConfig(options);
    this.tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
    this.clientId = this.msalConfig.auth.clientId;
    if (options === null || options === void 0 ? void 0 : options.getAssertion) {
      this.getAssertion = options.getAssertion;
    }
    if (persistenceProvider !== void 0 && ((_a2 = options.tokenCachePersistenceOptions) === null || _a2 === void 0 ? void 0 : _a2.enabled)) {
      this.createCachePlugin = () => persistenceProvider(options.tokenCachePersistenceOptions);
    } else if ((_b2 = options.tokenCachePersistenceOptions) === null || _b2 === void 0 ? void 0 : _b2.enabled) {
      throw new Error([
        "Persistent token caching was requested, but no persistence provider was configured.",
        "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
        "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`."
      ].join(" "));
    }
    this.azureRegion = (_c = options.regionalAuthority) !== null && _c !== void 0 ? _c : process.env.AZURE_REGIONAL_AUTHORITY_NAME;
    if (this.azureRegion === RegionalAuthority.AutoDiscoverRegion) {
      this.azureRegion = "AUTO_DISCOVER";
    }
  }
  /**
   * Generates a MSAL configuration that generally works for Node.js
   */
  defaultNodeMsalConfig(options) {
    const clientId = options.clientId || DeveloperSignOnClientId;
    const tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
    this.authorityHost = options.authorityHost || process.env.AZURE_AUTHORITY_HOST;
    const authority = getAuthority(tenantId, this.authorityHost);
    this.identityClient = new IdentityClient(Object.assign(Object.assign({}, options.tokenCredentialOptions), { authorityHost: authority, loggingOptions: options.loggingOptions }));
    let clientCapabilities = ["cp1"];
    if (process.env.AZURE_IDENTITY_DISABLE_CP1) {
      clientCapabilities = [];
    }
    return {
      auth: {
        clientId,
        authority,
        knownAuthorities: getKnownAuthorities(tenantId, authority),
        clientCapabilities
      },
      // Cache is defined in this.prepare();
      system: {
        networkClient: this.identityClient,
        loggerOptions: {
          loggerCallback: defaultLoggerCallback(options.logger)
        }
      }
    };
  }
  /**
   * Prepares the MSAL applications.
   */
  async init(options) {
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.identityClient.abortRequests(options.correlationId);
      });
    }
    if (this.publicApp || this.confidentialApp) {
      return;
    }
    if (this.createCachePlugin !== void 0) {
      this.msalConfig.cache = {
        cachePlugin: await this.createCachePlugin()
      };
    }
    this.publicApp = new PublicClientApplication(this.msalConfig);
    if (this.getAssertion) {
      this.msalConfig.auth.clientAssertion = await this.getAssertion();
    }
    if (this.msalConfig.auth.clientSecret || this.msalConfig.auth.clientAssertion || this.msalConfig.auth.clientCertificate) {
      this.confidentialApp = new ConfidentialClientApplication(this.msalConfig);
    } else {
      if (this.requiresConfidential) {
        throw new Error("Unable to generate the MSAL confidential client. Missing either the client's secret, certificate or assertion.");
      }
    }
  }
  /**
   * Allows the cancellation of a MSAL request.
   */
  withCancellation(promise, abortSignal2, onCancel) {
    return new Promise((resolve, reject) => {
      promise.then((msalToken) => {
        return resolve(msalToken);
      }).catch(reject);
      if (abortSignal2) {
        abortSignal2.addEventListener("abort", () => {
          onCancel === null || onCancel === void 0 ? void 0 : onCancel();
        });
      }
    });
  }
  /**
   * Returns the existing account, attempts to load the account from MSAL.
   */
  async getActiveAccount() {
    var _a2, _b2, _c;
    if (this.account) {
      return this.account;
    }
    const cache = (_b2 = (_a2 = this.confidentialApp) === null || _a2 === void 0 ? void 0 : _a2.getTokenCache()) !== null && _b2 !== void 0 ? _b2 : (_c = this.publicApp) === null || _c === void 0 ? void 0 : _c.getTokenCache();
    const accountsByTenant = await (cache === null || cache === void 0 ? void 0 : cache.getAllAccounts());
    if (!accountsByTenant) {
      return;
    }
    if (accountsByTenant.length === 1) {
      this.account = msalToPublic(this.clientId, accountsByTenant[0]);
    } else {
      this.logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.
However, no "authenticationRecord" has been provided for this credential,
therefore we're unable to pick between these accounts.
A new login attempt will be requested, to ensure the correct account is picked.
To work with multiple accounts for the same Client ID and Tenant ID, please provide an "authenticationRecord" when initializing a credential to prevent this from happening.`);
      return;
    }
    return this.account;
  }
  /**
   * Attempts to retrieve a token from cache.
   */
  async getTokenSilent(scopes, options) {
    var _a2, _b2;
    await this.getActiveAccount();
    if (!this.account) {
      throw new AuthenticationRequiredError({
        scopes,
        getTokenOptions: options,
        message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
      });
    }
    const silentRequest = {
      // To be able to re-use the account, the Token Cache must also have been provided.
      account: publicToMsal(this.account),
      correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
      scopes,
      authority: options === null || options === void 0 ? void 0 : options.authority,
      claims: options === null || options === void 0 ? void 0 : options.claims
    };
    try {
      this.logger.info("Attempting to acquire token silently");
      const response = (_b2 = await ((_a2 = this.confidentialApp) === null || _a2 === void 0 ? void 0 : _a2.acquireTokenSilent(silentRequest))) !== null && _b2 !== void 0 ? _b2 : await this.publicApp.acquireTokenSilent(silentRequest);
      return this.handleResult(scopes, this.clientId, response || void 0);
    } catch (err) {
      throw this.handleError(scopes, err, options);
    }
  }
  /**
   * Wrapper around each MSAL flow get token operation: doGetToken.
   * If disableAutomaticAuthentication is sent through the constructor, it will prevent MSAL from requesting the user input.
   */
  async getToken(scopes, options = {}) {
    const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
    options.authority = getAuthority(tenantId, this.authorityHost);
    options.correlationId = (options === null || options === void 0 ? void 0 : options.correlationId) || this.generateUuid();
    await this.init(options);
    try {
      const optionsClaims = options.claims;
      if (optionsClaims) {
        this.cachedClaims = optionsClaims;
      }
      if (this.cachedClaims && !optionsClaims) {
        options.claims = this.cachedClaims;
      }
      return await this.getTokenSilent(scopes, options);
    } catch (err) {
      if (err.name !== "AuthenticationRequiredError") {
        throw err;
      }
      if (options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication) {
        throw new AuthenticationRequiredError({
          scopes,
          getTokenOptions: options,
          message: "Automatic authentication has been disabled. You may call the authentication() method."
        });
      }
      this.logger.info(`Silent authentication failed, falling back to interactive method.`);
      return this.doGetToken(scopes, options);
    }
  }
}
const CommonTenantId = "common";
const AzureAccountClientId = "aebc6443-996d-45c2-90f0-388ff96faa56";
const logger$k = credentialLogger("VisualStudioCodeCredential");
let findCredentials = void 0;
const vsCodeCredentialControl = {
  setVsCodeCredentialFinder(finder) {
    findCredentials = finder;
  }
};
const unsupportedTenantIds = {
  adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants."
};
function checkUnsupportedTenant(tenantId) {
  const unsupportedTenantError = unsupportedTenantIds[tenantId];
  if (unsupportedTenantError) {
    throw new CredentialUnavailableError(unsupportedTenantError);
  }
}
const mapVSCodeAuthorityHosts = {
  AzureCloud: AzureAuthorityHosts.AzurePublicCloud,
  AzureChina: AzureAuthorityHosts.AzureChina,
  AzureGermanCloud: AzureAuthorityHosts.AzureGermany,
  AzureUSGovernment: AzureAuthorityHosts.AzureGovernment
};
function getPropertyFromVSCode(property) {
  const settingsPath = ["User", "settings.json"];
  const vsCodeFolder = "Code";
  const homedir = require$$0$2.homedir();
  function loadProperty(...pathSegments) {
    const fullPath = path$1.join(...pathSegments, vsCodeFolder, ...settingsPath);
    const settings = JSON.parse(fs$3.readFileSync(fullPath, { encoding: "utf8" }));
    return settings[property];
  }
  try {
    let appData;
    switch (process.platform) {
      case "win32":
        appData = process.env.APPDATA;
        return appData ? loadProperty(appData) : void 0;
      case "darwin":
        return loadProperty(homedir, "Library", "Application Support");
      case "linux":
        return loadProperty(homedir, ".config");
      default:
        return;
    }
  } catch (e) {
    logger$k.info(`Failed to load the Visual Studio Code configuration file. Error: ${e.message}`);
    return;
  }
}
class VisualStudioCodeCredential {
  /**
   * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
   *
   * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
   * `@azure/identity-vscode`. If this package is not installed and registered
   * using the plugin API (`useIdentityPlugin`), then authentication using
   * `VisualStudioCodeCredential` will not be available.
   *
   * @param options - Options for configuring the client which makes the authentication request.
   */
  constructor(options) {
    this.cloudName = getPropertyFromVSCode("azure.cloud") || "AzureCloud";
    const authorityHost = mapVSCodeAuthorityHosts[this.cloudName];
    this.identityClient = new IdentityClient(Object.assign({ authorityHost }, options));
    if (options && options.tenantId) {
      checkTenantId(logger$k, options.tenantId);
      this.tenantId = options.tenantId;
    } else {
      this.tenantId = CommonTenantId;
    }
    checkUnsupportedTenant(this.tenantId);
  }
  /**
   * Runs preparations for any further getToken request.
   */
  async prepare() {
    const settingsTenant = getPropertyFromVSCode("azure.tenant");
    if (settingsTenant) {
      this.tenantId = settingsTenant;
    }
    checkUnsupportedTenant(this.tenantId);
  }
  /**
   * Runs preparations for any further getToken, but only once.
   */
  prepareOnce() {
    if (!this.preparePromise) {
      this.preparePromise = this.prepare();
    }
    return this.preparePromise;
  }
  /**
   * Returns the token found by searching VSCode's authentication cache or
   * returns null if no token could be found.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                `TokenCredential` implementation might make.
   */
  async getToken(scopes, options) {
    var _a2, _b2;
    await this.prepareOnce();
    const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
    if (findCredentials === void 0) {
      throw new CredentialUnavailableError([
        "No implementation of `VisualStudioCodeCredential` is available.",
        "You must install the identity-vscode plugin package (`npm install --save-dev @azure/identity-vscode`)",
        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
        "`useIdentityPlugin(vsCodePlugin)` before creating a `VisualStudioCodeCredential`."
      ].join(" "));
    }
    let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
    if (!scopeString.match(/^[0-9a-zA-Z-.:/]+$/)) {
      const error2 = new Error("Invalid scope was specified by the user or calling client");
      logger$k.getToken.info(formatError(scopes, error2));
      throw error2;
    }
    if (scopeString.indexOf("offline_access") < 0) {
      scopeString += " offline_access";
    }
    const credentials = await findCredentials();
    const { password: refreshToken } = (_b2 = (_a2 = credentials.find(({ account }) => account === this.cloudName)) !== null && _a2 !== void 0 ? _a2 : credentials[0]) !== null && _b2 !== void 0 ? _b2 : {};
    if (refreshToken) {
      const tokenResponse = await this.identityClient.refreshAccessToken(tenantId, AzureAccountClientId, scopeString, refreshToken, void 0);
      if (tokenResponse) {
        logger$k.getToken.info(formatSuccess(scopes));
        return tokenResponse.accessToken;
      } else {
        const error2 = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Have you connected using the 'Azure Account' extension recently? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
        logger$k.getToken.info(formatError(scopes, error2));
        throw error2;
      }
    } else {
      const error2 = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Did you connect using the 'Azure Account' extension? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
      logger$k.getToken.info(formatError(scopes, error2));
      throw error2;
    }
  }
}
const pluginContext = {
  cachePluginControl: msalNodeFlowCacheControl,
  vsCodeCredentialControl
};
function useIdentityPlugin(plugin) {
  plugin(pluginContext);
}
const logger$j = credentialLogger("ChainedTokenCredential");
class ChainedTokenCredential {
  /**
   * Creates an instance of ChainedTokenCredential using the given credentials.
   *
   * @param sources - `TokenCredential` implementations to be tried in order.
   *
   * Example usage:
   * ```javascript
   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
   * ```
   */
  constructor(...sources) {
    this.UnavailableMessage = "ChainedTokenCredential => failed to retrieve a token from the included credentials";
    this._sources = [];
    this._sources = sources;
  }
  /**
   * Returns the first access token returned by one of the chained
   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
   * when one or more credentials throws an {@link AuthenticationError} and
   * no credentials have returned an access token.
   *
   * This method is called automatically by Azure SDK client libraries. You may call this method
   * directly, but you must also handle token caching and token refreshing.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                `TokenCredential` implementation might make.
   */
  async getToken(scopes, options = {}) {
    let token2 = null;
    let successfulCredentialName = "";
    const errors2 = [];
    return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
      for (let i = 0; i < this._sources.length && token2 === null; i++) {
        try {
          token2 = await this._sources[i].getToken(scopes, updatedOptions);
          successfulCredentialName = this._sources[i].constructor.name;
        } catch (err) {
          if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
            errors2.push(err);
          } else {
            logger$j.getToken.info(formatError(scopes, err));
            throw err;
          }
        }
      }
      if (!token2 && errors2.length > 0) {
        const err = new AggregateAuthenticationError(errors2, "ChainedTokenCredential authentication failed.");
        logger$j.getToken.info(formatError(scopes, err));
        throw err;
      }
      logger$j.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);
      if (token2 === null) {
        throw new CredentialUnavailableError("Failed to retrieve a valid token");
      }
      return token2;
    });
  }
}
function ensureValidScope(scope, logger2) {
  if (!scope.match(/^[0-9a-zA-Z-.:/]+$/)) {
    const error2 = new Error("Invalid scope was specified by the user or calling client");
    logger2.getToken.info(formatError(scope, error2));
    throw error2;
  }
}
function getScopeResource(scope) {
  return scope.replace(/\/.default$/, "");
}
const cliCredentialInternals = {
  /**
   * @internal
   */
  getSafeWorkingDir() {
    if (process.platform === "win32") {
      if (!process.env.SystemRoot) {
        throw new Error("Azure CLI credential expects a 'SystemRoot' environment variable");
      }
      return process.env.SystemRoot;
    } else {
      return "/bin";
    }
  },
  /**
   * Gets the access token from Azure CLI
   * @param resource - The resource to use when getting the token
   * @internal
   */
  async getAzureCliAccessToken(resource, tenantId) {
    let tenantSection = [];
    if (tenantId) {
      tenantSection = ["--tenant", tenantId];
    }
    return new Promise((resolve, reject) => {
      try {
        child_process.execFile("az", [
          "account",
          "get-access-token",
          "--output",
          "json",
          "--resource",
          resource,
          ...tenantSection
        ], { cwd: cliCredentialInternals.getSafeWorkingDir(), shell: true }, (error2, stdout, stderr) => {
          resolve({ stdout, stderr, error: error2 });
        });
      } catch (err) {
        reject(err);
      }
    });
  }
};
const logger$i = credentialLogger("AzureCliCredential");
class AzureCliCredential {
  /**
   * Creates an instance of the {@link AzureCliCredential}.
   *
   * To use this credential, ensure that you have already logged
   * in via the 'az' tool using the command "az login" from the commandline.
   *
   * @param options - Options, to optionally allow multi-tenant requests.
   */
  constructor(options) {
    this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    const tenantId = processMultiTenantRequest(this.tenantId, options);
    if (tenantId) {
      checkTenantId(logger$i, tenantId);
    }
    const scope = typeof scopes === "string" ? scopes : scopes[0];
    logger$i.getToken.info(`Using the scope ${scope}`);
    ensureValidScope(scope, logger$i);
    const resource = getScopeResource(scope);
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
      var _a2, _b2, _c, _d;
      try {
        const obj2 = await cliCredentialInternals.getAzureCliAccessToken(resource, tenantId);
        const specificScope = (_a2 = obj2.stderr) === null || _a2 === void 0 ? void 0 : _a2.match("(.*)az login --scope(.*)");
        const isLoginError2 = ((_b2 = obj2.stderr) === null || _b2 === void 0 ? void 0 : _b2.match("(.*)az login(.*)")) && !specificScope;
        const isNotInstallError = ((_c = obj2.stderr) === null || _c === void 0 ? void 0 : _c.match("az:(.*)not found")) || ((_d = obj2.stderr) === null || _d === void 0 ? void 0 : _d.startsWith("'az' is not recognized"));
        if (isNotInstallError) {
          const error2 = new CredentialUnavailableError("Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.");
          logger$i.getToken.info(formatError(scopes, error2));
          throw error2;
        }
        if (isLoginError2) {
          const error2 = new CredentialUnavailableError("Please run 'az login' from a command prompt to authenticate before using this credential.");
          logger$i.getToken.info(formatError(scopes, error2));
          throw error2;
        }
        try {
          const responseData = obj2.stdout;
          const response = JSON.parse(responseData);
          logger$i.getToken.info(formatSuccess(scopes));
          const returnValue = {
            token: response.accessToken,
            expiresOnTimestamp: new Date(response.expiresOn).getTime()
          };
          return returnValue;
        } catch (e) {
          if (obj2.stderr) {
            throw new CredentialUnavailableError(obj2.stderr);
          }
          throw e;
        }
      } catch (err) {
        const error2 = err.name === "CredentialUnavailableError" ? err : new CredentialUnavailableError(err.message || "Unknown error while trying to retrieve the access token");
        logger$i.getToken.info(formatError(scopes, error2));
        throw error2;
      }
    });
  }
}
const processUtils = {
  /**
   * Promisifying childProcess.execFile
   * @internal
   */
  execFile(file, params, options) {
    return new Promise((resolve, reject) => {
      child_process__namespace.execFile(file, params, options, (error2, stdout, stderr) => {
        if (Buffer.isBuffer(stdout)) {
          stdout = stdout.toString("utf8");
        }
        if (Buffer.isBuffer(stderr)) {
          stderr = stderr.toString("utf8");
        }
        if (stderr || error2) {
          reject(stderr ? new Error(stderr) : error2);
        } else {
          resolve(stdout);
        }
      });
    });
  }
};
const logger$h = credentialLogger("AzurePowerShellCredential");
const isWindows = process.platform === "win32";
function formatCommand(commandName) {
  if (isWindows) {
    return `${commandName}.exe`;
  } else {
    return commandName;
  }
}
async function runCommands(commands) {
  const results = [];
  for (const command of commands) {
    const [file, ...parameters] = command;
    const result = await processUtils.execFile(file, parameters, { encoding: "utf8" });
    results.push(result);
  }
  return results;
}
const powerShellErrors = {
  login: "Run Connect-AzAccount to login",
  installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory"
};
const powerShellPublicErrorMessages = {
  login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
  installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
  troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`
};
const isLoginError = (err) => err.message.match(`(.*)${powerShellErrors.login}(.*)`);
const isNotInstalledError = (err) => err.message.match(powerShellErrors.installed);
const commandStack = [formatCommand("pwsh")];
if (isWindows) {
  commandStack.push(formatCommand("powershell"));
}
class AzurePowerShellCredential {
  /**
   * Creates an instance of the {@link AzurePowerShellCredential}.
   *
   * To use this credential:
   * - Install the Azure Az PowerShell module with:
   *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
   * - You have already logged in to Azure PowerShell using the command
   * `Connect-AzAccount` from the command line.
   *
   * @param options - Options, to optionally allow multi-tenant requests.
   */
  constructor(options) {
    this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
  }
  /**
   * Gets the access token from Azure PowerShell
   * @param resource - The resource to use when getting the token
   */
  async getAzurePowerShellAccessToken(resource, tenantId) {
    for (const powerShellCommand of [...commandStack]) {
      try {
        await runCommands([[powerShellCommand, "/?"]]);
      } catch (e) {
        commandStack.shift();
        continue;
      }
      let tenantSection = "";
      if (tenantId) {
        tenantSection = `-TenantId "${tenantId}"`;
      }
      const results = await runCommands([
        [
          powerShellCommand,
          "-Command",
          "Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru"
        ],
        [
          powerShellCommand,
          "-Command",
          `Get-AzAccessToken ${tenantSection} -ResourceUrl "${resource}" | ConvertTo-Json`
        ]
      ]);
      const result = results[1];
      try {
        return JSON.parse(result);
      } catch (e) {
        throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
      }
    }
    throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
      const tenantId = processMultiTenantRequest(this.tenantId, options);
      if (tenantId) {
        checkTenantId(logger$h, tenantId);
      }
      const scope = typeof scopes === "string" ? scopes : scopes[0];
      ensureValidScope(scope, logger$h);
      logger$h.getToken.info(`Using the scope ${scope}`);
      const resource = getScopeResource(scope);
      try {
        const response = await this.getAzurePowerShellAccessToken(resource, tenantId);
        logger$h.getToken.info(formatSuccess(scopes));
        return {
          token: response.Token,
          expiresOnTimestamp: new Date(response.ExpiresOn).getTime()
        };
      } catch (err) {
        if (isNotInstalledError(err)) {
          const error3 = new CredentialUnavailableError(powerShellPublicErrorMessages.installed);
          logger$h.getToken.info(formatError(scope, error3));
          throw error3;
        } else if (isLoginError(err)) {
          const error3 = new CredentialUnavailableError(powerShellPublicErrorMessages.login);
          logger$h.getToken.info(formatError(scope, error3));
          throw error3;
        }
        const error2 = new CredentialUnavailableError(`${err}. ${powerShellPublicErrorMessages.troubleshoot}`);
        logger$h.getToken.info(formatError(scope, error2));
        throw error2;
      }
    });
  }
}
class MsalClientSecret extends MsalNode {
  constructor(options) {
    super(options);
    this.requiresConfidential = true;
    this.msalConfig.auth.clientSecret = options.clientSecret;
  }
  async doGetToken(scopes, options = {}) {
    try {
      const result = await this.confidentialApp.acquireTokenByClientCredential({
        scopes,
        correlationId: options.correlationId,
        azureRegion: this.azureRegion,
        authority: options.authority,
        claims: options.claims
      });
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (err) {
      throw this.handleError(scopes, err, options);
    }
  }
}
const logger$g = credentialLogger("ClientSecretCredential");
class ClientSecretCredential {
  /**
   * Creates an instance of the ClientSecretCredential with the details
   * needed to authenticate against Azure Active Directory with a client
   * secret.
   *
   * @param tenantId - The Azure Active Directory tenant (directory) ID.
   * @param clientId - The client (application) ID of an App Registration in the tenant.
   * @param clientSecret - A client secret that was generated for the App Registration.
   * @param options - Options for configuring the client which makes the authentication request.
   */
  constructor(tenantId, clientId, clientSecret, options = {}) {
    if (!tenantId || !clientId || !clientSecret) {
      throw new Error("ClientSecretCredential: tenantId, clientId, and clientSecret are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
    }
    this.msalFlow = new MsalClientSecret(Object.assign(Object.assign({}, options), {
      logger: logger$g,
      clientId,
      tenantId,
      clientSecret,
      tokenCredentialOptions: options
    }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, newOptions);
    });
  }
}
const readFileAsync$2 = require$$1$2.promisify(fs$3.readFile);
async function parseCertificate(configuration, sendCertificateChain) {
  const certificateParts = {};
  const certificate = configuration.certificate;
  const certificatePath = configuration.certificatePath;
  certificateParts.certificateContents = certificate || await readFileAsync$2(certificatePath, "utf8");
  if (sendCertificateChain) {
    certificateParts.x5c = certificateParts.certificateContents;
  }
  const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
  const publicKeys = [];
  let match;
  do {
    match = certificatePattern.exec(certificateParts.certificateContents);
    if (match) {
      publicKeys.push(match[3]);
    }
  } while (match);
  if (publicKeys.length === 0) {
    throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
  }
  certificateParts.thumbprint = crypto$2.createHash("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
  return certificateParts;
}
class MsalClientCertificate extends MsalNode {
  constructor(options) {
    super(options);
    this.requiresConfidential = true;
    this.configuration = options.configuration;
    this.sendCertificateChain = options.sendCertificateChain;
  }
  // Changing the MSAL configuration asynchronously
  async init(options) {
    try {
      const parts = await parseCertificate(this.configuration, this.sendCertificateChain);
      this.msalConfig.auth.clientCertificate = {
        thumbprint: parts.thumbprint,
        privateKey: parts.certificateContents,
        x5c: parts.x5c
      };
    } catch (error2) {
      this.logger.info(formatError("", error2));
      throw error2;
    }
    return super.init(options);
  }
  async doGetToken(scopes, options = {}) {
    try {
      const clientCredReq = {
        scopes,
        correlationId: options.correlationId,
        azureRegion: this.azureRegion,
        authority: options.authority,
        claims: options.claims
      };
      const result = await this.confidentialApp.acquireTokenByClientCredential(clientCredReq);
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (err) {
      throw this.handleError(scopes, err, options);
    }
  }
}
const credentialName$2 = "ClientCertificateCredential";
const logger$f = credentialLogger(credentialName$2);
class ClientCertificateCredential {
  constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
    if (!tenantId || !clientId) {
      throw new Error(`${credentialName$2}: tenantId and clientId are required parameters.`);
    }
    const configuration = Object.assign({}, typeof certificatePathOrConfiguration === "string" ? {
      certificatePath: certificatePathOrConfiguration
    } : certificatePathOrConfiguration);
    const certificate = configuration.certificate;
    const certificatePath = configuration.certificatePath;
    if (!configuration || !(certificate || certificatePath)) {
      throw new Error(`${credentialName$2}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
    }
    if (certificate && certificatePath) {
      throw new Error(`${credentialName$2}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
    }
    this.msalFlow = new MsalClientCertificate(Object.assign(Object.assign({}, options), {
      configuration,
      logger: logger$f,
      clientId,
      tenantId,
      sendCertificateChain: options.sendCertificateChain,
      tokenCredentialOptions: options
    }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${credentialName$2}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, newOptions);
    });
  }
}
class MsalUsernamePassword extends MsalNode {
  constructor(options) {
    super(options);
    this.username = options.username;
    this.password = options.password;
  }
  async doGetToken(scopes, options) {
    try {
      const requestOptions = {
        scopes,
        username: this.username,
        password: this.password,
        correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
        authority: options === null || options === void 0 ? void 0 : options.authority,
        claims: options === null || options === void 0 ? void 0 : options.claims
      };
      const result = await this.publicApp.acquireTokenByUsernamePassword(requestOptions);
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (error2) {
      throw this.handleError(scopes, error2, options);
    }
  }
}
const logger$e = credentialLogger("UsernamePasswordCredential");
class UsernamePasswordCredential {
  /**
   * Creates an instance of the UsernamePasswordCredential with the details
   * needed to authenticate against Azure Active Directory with a username
   * and password.
   *
   * @param tenantId - The Azure Active Directory tenant (directory).
   * @param clientId - The client (application) ID of an App Registration in the tenant.
   * @param username - The user account's e-mail address (user name).
   * @param password - The user account's account password
   * @param options - Options for configuring the client which makes the authentication request.
   */
  constructor(tenantId, clientId, username, password, options = {}) {
    if (!tenantId || !clientId || !username || !password) {
      throw new Error("UsernamePasswordCredential: tenantId, clientId, username and password are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
    }
    this.msalFlow = new MsalUsernamePassword(Object.assign(Object.assign({}, options), {
      logger: logger$e,
      clientId,
      tenantId,
      username,
      password,
      tokenCredentialOptions: options || {}
    }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * If the user provided the option `disableAutomaticAuthentication`,
   * once the token can't be retrieved silently,
   * this method won't attempt to request user interaction to retrieve the token.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, newOptions);
    });
  }
}
const AllSupportedEnvironmentVariables = [
  "AZURE_TENANT_ID",
  "AZURE_CLIENT_ID",
  "AZURE_CLIENT_SECRET",
  "AZURE_CLIENT_CERTIFICATE_PATH",
  "AZURE_USERNAME",
  "AZURE_PASSWORD"
];
const credentialName$1 = "EnvironmentCredential";
const logger$d = credentialLogger(credentialName$1);
class EnvironmentCredential {
  /**
   * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
   *
   * Required environment variables:
   * - `AZURE_TENANT_ID`: The Azure Active Directory tenant (directory) ID.
   * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
   *
   * Environment variables used for client credential authentication:
   * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
   * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
   *
   * Alternatively, users can provide environment variables for username and password authentication:
   * - `AZURE_USERNAME`: Username to authenticate with.
   * - `AZURE_PASSWORD`: Password to authenticate with.
   *
   * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
   * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
   *
   * @param options - Options for configuring the client which makes the authentication request.
   */
  constructor(options) {
    this._credential = void 0;
    const assigned = processEnvVars(AllSupportedEnvironmentVariables).assigned.join(", ");
    logger$d.info(`Found the following environment variables: ${assigned}`);
    const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
    if (tenantId) {
      checkTenantId(logger$d, tenantId);
    }
    if (tenantId && clientId && clientSecret) {
      logger$d.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
      this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);
      return;
    }
    const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
    if (tenantId && clientId && certificatePath) {
      logger$d.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
      this._credential = new ClientCertificateCredential(tenantId, clientId, { certificatePath }, options);
      return;
    }
    const username = process.env.AZURE_USERNAME;
    const password = process.env.AZURE_PASSWORD;
    if (tenantId && clientId && username && password) {
      logger$d.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
      this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, options);
    }
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - Optional parameters. See {@link GetTokenOptions}.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${credentialName$1}.getToken`, options, async (newOptions) => {
      if (this._credential) {
        try {
          const result = await this._credential.getToken(scopes, newOptions);
          logger$d.getToken.info(formatSuccess(scopes));
          return result;
        } catch (err) {
          const authenticationError = new AuthenticationError(400, {
            error: `${credentialName$1} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
            error_description: err.message.toString().split("More details:").join("")
          });
          logger$d.getToken.info(formatError(scopes, authenticationError));
          throw authenticationError;
        }
      }
      throw new CredentialUnavailableError(`${credentialName$1} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
    });
  }
}
const DefaultScopeSuffix = "/.default";
const imdsHost = "http://169.254.169.254";
const imdsEndpointPath = "/metadata/identity/oauth2/token";
const imdsApiVersion = "2018-02-01";
const azureArcAPIVersion = "2019-11-01";
const azureFabricVersion = "2019-07-01-preview";
function mapScopesToResource(scopes) {
  let scope = "";
  if (Array.isArray(scopes)) {
    if (scopes.length !== 1) {
      return;
    }
    scope = scopes[0];
  } else if (typeof scopes === "string") {
    scope = scopes;
  }
  if (!scope.endsWith(DefaultScopeSuffix)) {
    return scope;
  }
  return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
}
const msiName$6 = "ManagedIdentityCredential - AppServiceMSI 2017";
const logger$c = credentialLogger(msiName$6);
function expiresOnParser$3(requestBody) {
  return Date.parse(requestBody.expires_on);
}
function prepareRequestOptions$6(scopes, clientId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName$6}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": "2017-09-01"
  };
  if (clientId) {
    queryParameters.clientid = clientId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.MSI_ENDPOINT) {
    throw new Error(`${msiName$6}: Missing environment variable: MSI_ENDPOINT`);
  }
  if (!process.env.MSI_SECRET) {
    throw new Error(`${msiName$6}: Missing environment variable: MSI_SECRET`);
  }
  return {
    url: `${process.env.MSI_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      secret: process.env.MSI_SECRET
    })
  };
}
const appServiceMsi2017 = {
  async isAvailable({ scopes }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$c.info(`${msiName$6}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    const env = process.env;
    const result = Boolean(env.MSI_ENDPOINT && env.MSI_SECRET);
    if (!result) {
      logger$c.info(`${msiName$6}: Unavailable. The environment variables needed are: MSI_ENDPOINT and MSI_SECRET.`);
    }
    return result;
  },
  async getToken(configuration, getTokenOptions = {}) {
    const { identityClient, scopes, clientId, resourceId } = configuration;
    if (resourceId) {
      logger$c.warning(`${msiName$6}: managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
    }
    logger$c.info(`${msiName$6}: Using the endpoint and the secret coming form the environment variables: MSI_ENDPOINT=${process.env.MSI_ENDPOINT} and MSI_SECRET=[REDACTED].`);
    const request2 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$6(scopes, clientId)), {
      // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
      allowInsecureConnection: true
    }));
    const tokenResponse = await identityClient.sendTokenRequest(request2, expiresOnParser$3);
    return tokenResponse && tokenResponse.accessToken || null;
  }
};
const msiName$5 = "ManagedIdentityCredential - CloudShellMSI";
const logger$b = credentialLogger(msiName$5);
function prepareRequestOptions$5(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName$5}: Multiple scopes are not supported.`);
  }
  const body = {
    resource
  };
  if (clientId) {
    body.client_id = clientId;
  }
  if (resourceId) {
    body.msi_res_id = resourceId;
  }
  if (!process.env.MSI_ENDPOINT) {
    throw new Error(`${msiName$5}: Missing environment variable: MSI_ENDPOINT`);
  }
  const params = new URLSearchParams(body);
  return {
    url: process.env.MSI_ENDPOINT,
    method: "POST",
    body: params.toString(),
    headers: createHttpHeaders({
      Accept: "application/json",
      Metadata: "true",
      "Content-Type": "application/x-www-form-urlencoded"
    })
  };
}
const cloudShellMsi = {
  async isAvailable({ scopes }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$b.info(`${msiName$5}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    const result = Boolean(process.env.MSI_ENDPOINT);
    if (!result) {
      logger$b.info(`${msiName$5}: Unavailable. The environment variable MSI_ENDPOINT is needed.`);
    }
    return result;
  },
  async getToken(configuration, getTokenOptions = {}) {
    const { identityClient, scopes, clientId, resourceId } = configuration;
    if (clientId) {
      logger$b.warning(`${msiName$5}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
    }
    if (resourceId) {
      logger$b.warning(`${msiName$5}: user defined managed Identity by resource Id not supported. The argument resourceId might be ignored by the service.`);
    }
    logger$b.info(`${msiName$5}: Using the endpoint coming form the environment variable MSI_ENDPOINT = ${process.env.MSI_ENDPOINT}.`);
    const request2 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$5(scopes, clientId, resourceId)), {
      // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
      allowInsecureConnection: true
    }));
    const tokenResponse = await identityClient.sendTokenRequest(request2);
    return tokenResponse && tokenResponse.accessToken || null;
  }
};
const msiName$4 = "ManagedIdentityCredential - IMDS";
const logger$a = credentialLogger(msiName$4);
function expiresOnParser$2(requestBody) {
  if (requestBody.expires_on) {
    const expires = +requestBody.expires_on * 1e3;
    logger$a.info(`${msiName$4}: Using expires_on: ${expires} (original value: ${requestBody.expires_on})`);
    return expires;
  } else {
    const expires = Date.now() + requestBody.expires_in * 1e3;
    logger$a.info(`${msiName$4}: IMDS using expires_in: ${expires} (original value: ${requestBody.expires_in})`);
    return expires;
  }
}
function prepareRequestOptions$4(scopes, clientId, resourceId, options) {
  var _a2;
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName$4}: Multiple scopes are not supported.`);
  }
  const { skipQuery, skipMetadataHeader } = options || {};
  let query = "";
  if (!skipQuery) {
    const queryParameters = {
      resource,
      "api-version": imdsApiVersion
    };
    if (clientId) {
      queryParameters.client_id = clientId;
    }
    if (resourceId) {
      queryParameters.msi_res_id = resourceId;
    }
    const params = new URLSearchParams(queryParameters);
    query = `?${params.toString()}`;
  }
  const url = new URL(imdsEndpointPath, (_a2 = process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) !== null && _a2 !== void 0 ? _a2 : imdsHost);
  const rawHeaders = {
    Accept: "application/json",
    Metadata: "true"
  };
  if (skipMetadataHeader) {
    delete rawHeaders.Metadata;
  }
  return {
    // In this case, the `?` should be added in the "query" variable `skipQuery` is not set.
    url: `${url}${query}`,
    method: "GET",
    headers: createHttpHeaders(rawHeaders)
  };
}
const imdsMsiRetryConfig = {
  maxRetries: 3,
  startDelayInMs: 800,
  intervalIncrement: 2
};
const imdsMsi = {
  async isAvailable({ scopes, identityClient, clientId, resourceId, getTokenOptions = {} }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$a.info(`${msiName$4}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
      return true;
    }
    if (!identityClient) {
      throw new Error("Missing IdentityClient");
    }
    const requestOptions = prepareRequestOptions$4(resource, clientId, resourceId, {
      skipMetadataHeader: true,
      skipQuery: true
    });
    return tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions, async (options) => {
      var _a2, _b2;
      requestOptions.tracingOptions = options.tracingOptions;
      try {
        const request2 = createPipelineRequest(requestOptions);
        request2.timeout = (_b2 = (_a2 = options.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.timeout) !== null && _b2 !== void 0 ? _b2 : 300;
        request2.allowInsecureConnection = true;
        try {
          logger$a.info(`${msiName$4}: Pinging the Azure IMDS endpoint`);
          await identityClient.sendRequest(request2);
        } catch (err) {
          if (err.name === "RestError" && err.code === RestError.REQUEST_SEND_ERROR || err.name === "AbortError" || err.code === "ENETUNREACH" || // Network unreachable
          err.code === "ECONNREFUSED" || // connection refused
          err.code === "EHOSTDOWN") {
            logger$a.info(`${msiName$4}: The Azure IMDS endpoint is unavailable`);
            return false;
          }
        }
        logger$a.info(`${msiName$4}: The Azure IMDS endpoint is available`);
        return true;
      } catch (err) {
        logger$a.info(`${msiName$4}: Error when creating the WebResource for the Azure IMDS endpoint: ${err.message}`);
        throw err;
      }
    });
  },
  async getToken(configuration, getTokenOptions = {}) {
    const { identityClient, scopes, clientId, resourceId } = configuration;
    logger$a.info(`${msiName$4}: Using the Azure IMDS endpoint coming from the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`);
    let nextDelayInMs = imdsMsiRetryConfig.startDelayInMs;
    for (let retries = 0; retries < imdsMsiRetryConfig.maxRetries; retries++) {
      try {
        const request2 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$4(scopes, clientId, resourceId)), { allowInsecureConnection: true }));
        const tokenResponse = await identityClient.sendTokenRequest(request2, expiresOnParser$2);
        return tokenResponse && tokenResponse.accessToken || null;
      } catch (error2) {
        if (error2.statusCode === 404) {
          await delay(nextDelayInMs);
          nextDelayInMs *= imdsMsiRetryConfig.intervalIncrement;
          continue;
        }
        throw error2;
      }
    }
    throw new AuthenticationError(404, `${msiName$4}: Failed to retrieve IMDS token after ${imdsMsiRetryConfig.maxRetries} retries.`);
  }
};
const msiName$3 = "ManagedIdentityCredential - Azure Arc MSI";
const logger$9 = credentialLogger(msiName$3);
function prepareRequestOptions$3(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName$3}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": azureArcAPIVersion
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.msi_res_id = resourceId;
  }
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error(`${msiName$3}: Missing environment variable: IDENTITY_ENDPOINT`);
  }
  const query = new URLSearchParams(queryParameters);
  return createPipelineRequest({
    // Should be similar to: http://localhost:40342/metadata/identity/oauth2/token
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      Metadata: "true"
    })
  });
}
function readFileAsync$1(path2, options) {
  return new Promise((resolve, reject) => fs$3.readFile(path2, options, (err, data) => {
    if (err) {
      reject(err);
    }
    resolve(data);
  }));
}
async function filePathRequest(identityClient, requestPrepareOptions) {
  const response = await identityClient.sendRequest(createPipelineRequest(requestPrepareOptions));
  if (response.status !== 401) {
    let message2 = "";
    if (response.bodyAsText) {
      message2 = ` Response: ${response.bodyAsText}`;
    }
    throw new AuthenticationError(response.status, `${msiName$3}: To authenticate with Azure Arc MSI, status code 401 is expected on the first request. ${message2}`);
  }
  const authHeader = response.headers.get("www-authenticate") || "";
  try {
    return authHeader.split("=").slice(1)[0];
  } catch (e) {
    throw Error(`Invalid www-authenticate header format: ${authHeader}`);
  }
}
const arcMsi = {
  async isAvailable({ scopes }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$9.info(`${msiName$3}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    const result = Boolean(process.env.IMDS_ENDPOINT && process.env.IDENTITY_ENDPOINT);
    if (!result) {
      logger$9.info(`${msiName$3}: The environment variables needed are: IMDS_ENDPOINT and IDENTITY_ENDPOINT`);
    }
    return result;
  },
  async getToken(configuration, getTokenOptions = {}) {
    var _a2;
    const { identityClient, scopes, clientId, resourceId } = configuration;
    if (clientId) {
      logger$9.warning(`${msiName$3}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
    }
    if (resourceId) {
      logger$9.warning(`${msiName$3}: user defined managed Identity by resource Id is not supported. Argument resourceId will be ignored.`);
    }
    logger$9.info(`${msiName$3}: Authenticating.`);
    const requestOptions = Object.assign(Object.assign({ disableJsonStringifyOnBody: true, deserializationMapper: void 0, abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$3(scopes, clientId, resourceId)), { allowInsecureConnection: true });
    const filePath = await filePathRequest(identityClient, requestOptions);
    if (!filePath) {
      throw new Error(`${msiName$3}: Failed to find the token file.`);
    }
    const key2 = await readFileAsync$1(filePath, { encoding: "utf-8" });
    (_a2 = requestOptions.headers) === null || _a2 === void 0 ? void 0 : _a2.set("Authorization", `Basic ${key2}`);
    const request2 = createPipelineRequest(Object.assign(Object.assign({}, requestOptions), {
      // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
      allowInsecureConnection: true
    }));
    const tokenResponse = await identityClient.sendTokenRequest(request2);
    return tokenResponse && tokenResponse.accessToken || null;
  }
};
const msiName$2 = "ManagedIdentityCredential - Token Exchange";
const logger$8 = credentialLogger(msiName$2);
const readFileAsync = require$$1$2.promisify(fs$3.readFile);
function prepareRequestOptions$2(scopes, clientAssertion, clientId) {
  var _a2;
  const bodyParams = {
    scope: Array.isArray(scopes) ? scopes.join(" ") : scopes,
    client_assertion: clientAssertion,
    client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
    client_id: clientId,
    grant_type: "client_credentials"
  };
  const urlParams = new URLSearchParams(bodyParams);
  const url = new URL(`${process.env.AZURE_TENANT_ID}/oauth2/v2.0/token`, (_a2 = process.env.AZURE_AUTHORITY_HOST) !== null && _a2 !== void 0 ? _a2 : DefaultAuthorityHost);
  return {
    url: url.toString(),
    method: "POST",
    body: urlParams.toString(),
    headers: createHttpHeaders({
      Accept: "application/json"
    })
  };
}
function tokenExchangeMsi() {
  const azureFederatedTokenFilePath = process.env.AZURE_FEDERATED_TOKEN_FILE;
  let azureFederatedTokenFileContent = void 0;
  let cacheDate = void 0;
  async function readAssertion() {
    if (cacheDate !== void 0 && Date.now() - cacheDate >= 1e3 * 60 * 5) {
      azureFederatedTokenFileContent = void 0;
    }
    if (!azureFederatedTokenFileContent) {
      const file = await readFileAsync(azureFederatedTokenFilePath, "utf8");
      const value = file.trim();
      if (!value) {
        throw new Error(`No content on the file ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
      } else {
        azureFederatedTokenFileContent = value;
        cacheDate = Date.now();
      }
    }
    return azureFederatedTokenFileContent;
  }
  return {
    async isAvailable({ clientId }) {
      const env = process.env;
      const result = Boolean((clientId || env.AZURE_CLIENT_ID) && env.AZURE_TENANT_ID && azureFederatedTokenFilePath);
      if (!result) {
        logger$8.info(`${msiName$2}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
      }
      return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
      const { identityClient, scopes, clientId } = configuration;
      logger$8.info(`${msiName$2}: Using the client assertion coming from environment variables.`);
      let assertion;
      try {
        assertion = await readAssertion();
      } catch (err) {
        throw new Error(`${msiName$2}: Failed to read ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
      }
      const request2 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$2(scopes, assertion, clientId || process.env.AZURE_CLIENT_ID)), {
        // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
        allowInsecureConnection: true
      }));
      const tokenResponse = await identityClient.sendTokenRequest(request2);
      return tokenResponse && tokenResponse.accessToken || null;
    }
  };
}
const msiName$1 = "ManagedIdentityCredential - Fabric MSI";
const logger$7 = credentialLogger(msiName$1);
function expiresOnParser$1(requestBody) {
  return Number(requestBody.expires_on);
}
function prepareRequestOptions$1(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName$1}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": azureFabricVersion
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.msi_res_id = resourceId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error("Missing environment variable: IDENTITY_ENDPOINT");
  }
  if (!process.env.IDENTITY_HEADER) {
    throw new Error("Missing environment variable: IDENTITY_HEADER");
  }
  return {
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      secret: process.env.IDENTITY_HEADER
    })
  };
}
const fabricMsi = {
  async isAvailable({ scopes }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$7.info(`${msiName$1}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    const env = process.env;
    const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER && env.IDENTITY_SERVER_THUMBPRINT);
    if (!result) {
      logger$7.info(`${msiName$1}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT, IDENTITY_HEADER and IDENTITY_SERVER_THUMBPRINT`);
    }
    return result;
  },
  async getToken(configuration, getTokenOptions = {}) {
    const { scopes, identityClient, clientId, resourceId } = configuration;
    if (resourceId) {
      logger$7.warning(`${msiName$1}: user defined managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
    }
    logger$7.info([
      `${msiName$1}:`,
      "Using the endpoint and the secret coming from the environment variables:",
      `IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT},`,
      "IDENTITY_HEADER=[REDACTED] and",
      "IDENTITY_SERVER_THUMBPRINT=[REDACTED]."
    ].join(" "));
    const request2 = createPipelineRequest(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions$1(scopes, clientId, resourceId)));
    request2.agent = new https$2.Agent({
      // This is necessary because Service Fabric provides a self-signed certificate.
      // The alternative path is to verify the certificate using the IDENTITY_SERVER_THUMBPRINT env variable.
      rejectUnauthorized: false
    });
    const tokenResponse = await identityClient.sendTokenRequest(request2, expiresOnParser$1);
    return tokenResponse && tokenResponse.accessToken || null;
  }
};
const msiName = "ManagedIdentityCredential - AppServiceMSI 2019";
const logger$6 = credentialLogger(msiName);
function expiresOnParser(requestBody) {
  return Date.parse(requestBody.expires_on);
}
function prepareRequestOptions(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": "2019-08-01"
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.mi_res_id = resourceId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error(`${msiName}: Missing environment variable: IDENTITY_ENDPOINT`);
  }
  if (!process.env.IDENTITY_HEADER) {
    throw new Error(`${msiName}: Missing environment variable: IDENTITY_HEADER`);
  }
  return {
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      "X-IDENTITY-HEADER": process.env.IDENTITY_HEADER
    })
  };
}
const appServiceMsi2019 = {
  async isAvailable({ scopes }) {
    const resource = mapScopesToResource(scopes);
    if (!resource) {
      logger$6.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
      return false;
    }
    const env = process.env;
    const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER);
    if (!result) {
      logger$6.info(`${msiName}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT and IDENTITY_HEADER.`);
    }
    return result;
  },
  async getToken(configuration, getTokenOptions = {}) {
    const { identityClient, scopes, clientId, resourceId } = configuration;
    logger$6.info(`${msiName}: Using the endpoint and the secret coming form the environment variables: IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT} and IDENTITY_HEADER=[REDACTED].`);
    const request2 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions(scopes, clientId, resourceId)), {
      // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
      allowInsecureConnection: true
    }));
    const tokenResponse = await identityClient.sendTokenRequest(request2, expiresOnParser);
    return tokenResponse && tokenResponse.accessToken || null;
  }
};
const logger$5 = credentialLogger("ManagedIdentityCredential");
class ManagedIdentityCredential {
  /**
   * @internal
   * @hidden
   */
  constructor(clientIdOrOptions, options) {
    this.isEndpointUnavailable = null;
    let _options;
    if (typeof clientIdOrOptions === "string") {
      this.clientId = clientIdOrOptions;
      _options = options;
    } else {
      this.clientId = clientIdOrOptions === null || clientIdOrOptions === void 0 ? void 0 : clientIdOrOptions.clientId;
      _options = clientIdOrOptions;
    }
    this.resourceId = _options === null || _options === void 0 ? void 0 : _options.resourceId;
    if (this.clientId && this.resourceId) {
      throw new Error(`${ManagedIdentityCredential.name} - Client Id and Resource Id can't be provided at the same time.`);
    }
    this.identityClient = new IdentityClient(_options);
    this.isAvailableIdentityClient = new IdentityClient(Object.assign(Object.assign({}, _options), { retryOptions: {
      maxRetries: 0
    } }));
  }
  async cachedAvailableMSI(scopes, getTokenOptions) {
    if (this.cachedMSI) {
      return this.cachedMSI;
    }
    const MSIs = [
      arcMsi,
      fabricMsi,
      appServiceMsi2019,
      appServiceMsi2017,
      cloudShellMsi,
      tokenExchangeMsi(),
      imdsMsi
    ];
    for (const msi of MSIs) {
      if (await msi.isAvailable({
        scopes,
        identityClient: this.isAvailableIdentityClient,
        clientId: this.clientId,
        resourceId: this.resourceId,
        getTokenOptions
      })) {
        this.cachedMSI = msi;
        return msi;
      }
    }
    throw new CredentialUnavailableError(`${ManagedIdentityCredential.name} - No MSI credential available`);
  }
  async authenticateManagedIdentity(scopes, getTokenOptions) {
    const { span, updatedOptions } = tracingClient.startSpan(`${ManagedIdentityCredential.name}.authenticateManagedIdentity`, getTokenOptions);
    try {
      const availableMSI = await this.cachedAvailableMSI(scopes, updatedOptions);
      return availableMSI.getToken({
        identityClient: this.identityClient,
        scopes,
        clientId: this.clientId,
        resourceId: this.resourceId
      }, updatedOptions);
    } catch (err) {
      span.setStatus({
        status: "error",
        error: err
      });
      throw err;
    } finally {
      span.end();
    }
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options) {
    let result = null;
    const { span, updatedOptions } = tracingClient.startSpan(`${ManagedIdentityCredential.name}.getToken`, options);
    try {
      if (this.isEndpointUnavailable !== true) {
        result = await this.authenticateManagedIdentity(scopes, updatedOptions);
        if (result === null) {
          this.isEndpointUnavailable = true;
          const error2 = new CredentialUnavailableError("The managed identity endpoint was reached, yet no tokens were received.");
          logger$5.getToken.info(formatError(scopes, error2));
          throw error2;
        }
        this.isEndpointUnavailable = false;
      } else {
        const error2 = new CredentialUnavailableError("The managed identity endpoint is not currently available");
        logger$5.getToken.info(formatError(scopes, error2));
        throw error2;
      }
      logger$5.getToken.info(formatSuccess(scopes));
      return result;
    } catch (err) {
      if (err.name === "AuthenticationRequiredError") {
        throw err;
      }
      span.setStatus({
        status: "error",
        error: err
      });
      if (err.code === "ENETUNREACH") {
        const error2 = new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Unavailable. Network unreachable. Message: ${err.message}`);
        logger$5.getToken.info(formatError(scopes, error2));
        throw error2;
      }
      if (err.code === "EHOSTUNREACH") {
        const error2 = new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Unavailable. No managed identity endpoint found. Message: ${err.message}`);
        logger$5.getToken.info(formatError(scopes, error2));
        throw error2;
      }
      if (err.statusCode === 400) {
        throw new CredentialUnavailableError(`${ManagedIdentityCredential.name}: The managed identity endpoint is indicating there's no available identity. Message: ${err.message}`);
      }
      if (err.statusCode === void 0) {
        throw new CredentialUnavailableError(`${ManagedIdentityCredential.name}: Authentication failed. Message ${err.message}`);
      }
      throw new AuthenticationError(err.statusCode, {
        error: `${ManagedIdentityCredential.name} authentication failed.`,
        error_description: err.message
      });
    } finally {
      span.end();
    }
  }
}
class DefaultManagedIdentityCredential extends ManagedIdentityCredential {
  // Constructor overload with just the other default options
  // Last constructor overload with Union of all options not required since the above two constructor overloads have optional properties
  constructor(options) {
    var _a2;
    const managedIdentityClientId = (_a2 = options === null || options === void 0 ? void 0 : options.managedIdentityClientId) !== null && _a2 !== void 0 ? _a2 : process.env.AZURE_CLIENT_ID;
    const managedResourceId = options === null || options === void 0 ? void 0 : options.managedIdentityResourceId;
    if (managedResourceId) {
      const managedIdentityResourceIdOptions = Object.assign(Object.assign({}, options), { resourceId: managedResourceId });
      super(managedIdentityResourceIdOptions);
    } else if (managedIdentityClientId) {
      const managedIdentityClientOptions = Object.assign(Object.assign({}, options), { clientId: managedIdentityClientId });
      super(managedIdentityClientOptions);
    } else {
      super(options);
    }
  }
}
const defaultCredentials = [
  EnvironmentCredential,
  DefaultManagedIdentityCredential,
  VisualStudioCodeCredential,
  AzureCliCredential,
  AzurePowerShellCredential
];
class DefaultAzureCredential extends ChainedTokenCredential {
  constructor(options) {
    super(...defaultCredentials.map((ctor) => new ctor(options)));
    this.UnavailableMessage = "DefaultAzureCredential => failed to retrieve a token from the included credentials. To troubleshoot, visit https://aka.ms/azsdk/js/identity/defaultazurecredential/troubleshoot.";
  }
}
class MsalClientAssertion extends MsalNode {
  constructor(options) {
    super(options);
    this.requiresConfidential = true;
    this.getAssertion = options.getAssertion;
  }
  async doGetToken(scopes, options = {}) {
    try {
      const assertion = await this.getAssertion();
      const result = await this.confidentialApp.acquireTokenByClientCredential({
        scopes,
        correlationId: options.correlationId,
        azureRegion: this.azureRegion,
        authority: options.authority,
        claims: options.claims,
        clientAssertion: assertion
      });
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (err) {
      let err2 = err;
      if (err === null || err === void 0) {
        err2 = new Error(JSON.stringify(err));
      } else {
        err2 = isError(err) ? err : new Error(String(err));
      }
      throw this.handleError(scopes, err2, options);
    }
  }
}
const logger$4 = credentialLogger("ClientAssertionCredential");
class ClientAssertionCredential {
  /**
   * Creates an instance of the ClientAssertionCredential with the details
   * needed to authenticate against Azure Active Directory with a client
   * assertion provided by the developer through the `getAssertion` function parameter.
   *
   * @param tenantId - The Azure Active Directory tenant (directory) ID.
   * @param clientId - The client (application) ID of an App Registration in the tenant.
   * @param getAssertion - A function that retrieves the assertion for the credential to use.
   * @param options - Options for configuring the client which makes the authentication request.
   */
  constructor(tenantId, clientId, getAssertion, options = {}) {
    if (!tenantId || !clientId || !getAssertion) {
      throw new Error("ClientAssertionCredential: tenantId, clientId, and clientAssertion are required parameters.");
    }
    this.tenantId = tenantId;
    this.clientId = clientId;
    this.options = options;
    this.msalFlow = new MsalClientAssertion(Object.assign(Object.assign({}, options), { logger: logger$4, clientId: this.clientId, tenantId: this.tenantId, tokenCredentialOptions: this.options, getAssertion }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, newOptions);
    });
  }
}
var isWsl$2 = { exports: {} };
const fs$2 = fs$3;
let isDocker$2;
function hasDockerEnv() {
  try {
    fs$2.statSync("/.dockerenv");
    return true;
  } catch (_2) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_2) {
    return false;
  }
}
var isDocker_1 = () => {
  if (isDocker$2 === void 0) {
    isDocker$2 = hasDockerEnv() || hasDockerCGroup();
  }
  return isDocker$2;
};
const os = require$$0$2;
const fs$1 = fs$3;
const isDocker$1 = isDocker_1;
const isWsl$1 = () => {
  if (process.platform !== "linux") {
    return false;
  }
  if (os.release().toLowerCase().includes("microsoft")) {
    if (isDocker$1()) {
      return false;
    }
    return true;
  }
  try {
    return fs$1.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
  } catch (_2) {
    return false;
  }
};
if (process.env.__IS_WSL_TEST__) {
  isWsl$2.exports = isWsl$1;
} else {
  isWsl$2.exports = isWsl$1();
}
var isWslExports = isWsl$2.exports;
var defineLazyProp = (object, propertyName, fn) => {
  const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = fn();
      define2(result);
      return result;
    },
    set(value) {
      define2(value);
    }
  });
  return object;
};
const path = path$1;
const childProcess = child_process;
const { promises: fs, constants: fsConstants } = fs$3;
const isWsl = isWslExports;
const isDocker = isDocker_1;
const defineLazyProperty = defineLazyProp;
const localXdgOpenPath = path.join(__dirname, "xdg-open");
const { platform, arch } = process;
const hasContainerEnv = () => {
  try {
    fs.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
let cachedResult;
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}
const getWslDrivesMountPoint = /* @__PURE__ */ (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs.access(configFilePath, fsConstants.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = new RegExp("(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)", "g").exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
const pTryEach = async (array, mapper) => {
  let latestError;
  for (const item of array) {
    try {
      return await mapper(item);
    } catch (error2) {
      latestError = error2;
    }
  }
  throw latestError;
};
const baseOpen = async (options) => {
  options = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options
  };
  if (Array.isArray(options.app)) {
    return pTryEach(options.app, (singleApp) => baseOpen({
      ...options,
      app: singleApp
    }));
  }
  let { name: app, arguments: appArguments = [] } = options.app || {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return pTryEach(app, (appName) => baseOpen({
      ...options,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  if (platform === "darwin") {
    command = "open";
    if (options.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options.background) {
      cliArguments.push("--background");
    }
    if (options.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || isWsl && !isInsideContainer() && !app) {
    const mountPoint = await getWslDrivesMountPoint();
    command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
    cliArguments.push(
      "-NoProfile",
      "-NonInteractive",
      "ExecutionPolicy",
      "Bypass",
      "-EncodedCommand"
    );
    if (!isWsl) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    const encodedArguments = ["Start"];
    if (options.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
      if (options.target) {
        appArguments.unshift(options.target);
      }
    } else if (options.target) {
      encodedArguments.push(`"${options.target}"`);
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
      encodedArguments.push(appArguments.join(","));
    }
    options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname || __dirname === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs.access(localXdgOpenPath, fsConstants.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (options.target) {
    cliArguments.push(options.target);
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
  if (options.wait) {
    return new Promise((resolve, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (!options.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve(subprocess);
      });
    });
  }
  subprocess.unref();
  return subprocess;
};
const open = (target, options) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options,
    target
  });
};
const openApp = (name2, options) => {
  if (typeof name2 !== "string") {
    throw new TypeError("Expected a `name`");
  }
  const { arguments: appArguments = [] } = options || {};
  if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
    throw new TypeError("Expected `appArguments` as Array type");
  }
  return baseOpen({
    ...options,
    app: {
      name: name2,
      arguments: appArguments
    }
  });
};
function detectArchBinary(binary2) {
  if (typeof binary2 === "string" || Array.isArray(binary2)) {
    return binary2;
  }
  const { [arch]: archBinary } = binary2;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
open.apps = apps;
open.openApp = openApp;
var open_1 = open;
const open$1 = /* @__PURE__ */ getDefaultExportFromCjs(open_1);
const https = https$2;
var stoppable = (server, grace) => {
  grace = typeof grace === "undefined" ? Infinity : grace;
  const reqsPerSocket = /* @__PURE__ */ new Map();
  let stopped = false;
  let gracefully = true;
  if (server instanceof https.Server) {
    server.on("secureConnection", onConnection);
  } else {
    server.on("connection", onConnection);
  }
  server.on("request", onRequest);
  server.stop = stop;
  server._pendingSockets = reqsPerSocket;
  return server;
  function onConnection(socket) {
    reqsPerSocket.set(socket, 0);
    socket.once("close", () => reqsPerSocket.delete(socket));
  }
  function onRequest(req2, res) {
    reqsPerSocket.set(req2.socket, reqsPerSocket.get(req2.socket) + 1);
    res.once("finish", () => {
      const pending = reqsPerSocket.get(req2.socket) - 1;
      reqsPerSocket.set(req2.socket, pending);
      if (stopped && pending === 0) {
        req2.socket.end();
      }
    });
  }
  function stop(callback) {
    setImmediate(() => {
      stopped = true;
      if (grace < Infinity) {
        setTimeout(destroyAll, grace).unref();
      }
      server.close((e) => {
        if (callback) {
          callback(e, gracefully);
        }
      });
      reqsPerSocket.forEach(endIfIdle);
    });
  }
  function endIfIdle(requests, socket) {
    if (requests === 0) socket.end();
  }
  function destroyAll() {
    gracefully = false;
    reqsPerSocket.forEach((reqs, socket) => socket.end());
    setImmediate(() => {
      reqsPerSocket.forEach((reqs, socket) => socket.destroy());
    });
  }
};
const stoppable$1 = /* @__PURE__ */ getDefaultExportFromCjs(stoppable);
const interactiveBrowserMockable = {
  open: open$1
};
class MsalOpenBrowser extends MsalNode {
  constructor(options) {
    super(options);
    this.logger = credentialLogger("Node.js MSAL Open Browser");
    this.redirectUri = options.redirectUri;
    this.loginHint = options.loginHint;
    const url = new URL(this.redirectUri);
    this.port = parseInt(url.port);
    if (isNaN(this.port)) {
      this.port = 80;
    }
    this.hostname = url.hostname;
  }
  async acquireTokenByCode(request2) {
    return this.publicApp.acquireTokenByCode(request2);
  }
  doGetToken(scopes, options) {
    return new Promise((resolve, reject) => {
      const socketToDestroy = [];
      const requestListener = (req2, res) => {
        var _a2;
        if (!req2.url) {
          reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
          return;
        }
        let url;
        try {
          url = new URL(req2.url, this.redirectUri);
        } catch (e) {
          reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
          return;
        }
        const tokenRequest = {
          code: url.searchParams.get("code"),
          redirectUri: this.redirectUri,
          scopes,
          authority: options === null || options === void 0 ? void 0 : options.authority,
          codeVerifier: (_a2 = this.pkceCodes) === null || _a2 === void 0 ? void 0 : _a2.verifier
        };
        this.acquireTokenByCode(tokenRequest).then((authResponse) => {
          if (authResponse === null || authResponse === void 0 ? void 0 : authResponse.account) {
            this.account = msalToPublic(this.clientId, authResponse.account);
          }
          const successMessage = `Authentication Complete. You can close the browser and return to the application.`;
          if (authResponse && authResponse.expiresOn) {
            const expiresOnTimestamp = authResponse === null || authResponse === void 0 ? void 0 : authResponse.expiresOn.valueOf();
            res.writeHead(200);
            res.end(successMessage);
            this.logger.getToken.info(formatSuccess(scopes));
            resolve({
              expiresOnTimestamp,
              token: authResponse.accessToken
            });
          } else {
            const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
            res.writeHead(500);
            res.end(errorMessage);
            this.logger.getToken.info(errorMessage);
            reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
          }
          cleanup();
          return;
        }).catch(() => {
          const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
          res.writeHead(500);
          res.end(errorMessage);
          this.logger.getToken.info(errorMessage);
          reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
          cleanup();
        });
      };
      const app = http$1.createServer(requestListener);
      const server = stoppable$1(app);
      const listen = app.listen(this.port, this.hostname, () => this.logger.info(`InteractiveBrowserCredential listening on port ${this.port}!`));
      function cleanup() {
        if (listen) {
          listen.close();
        }
        for (const socket of socketToDestroy) {
          socket.destroy();
        }
        if (server) {
          server.close();
          server.stop();
        }
      }
      app.on("connection", (socket) => socketToDestroy.push(socket));
      app.on("error", (err) => {
        cleanup();
        const code = err.code;
        if (code === "EACCES" || code === "EADDRINUSE") {
          reject(new CredentialUnavailableError([
            `InteractiveBrowserCredential: Access denied to port ${this.port}.`,
            `Try sending a redirect URI with a different port, as follows:`,
            '`new InteractiveBrowserCredential({ redirectUri: "http://localhost:1337" })`'
          ].join(" ")));
        } else {
          reject(new CredentialUnavailableError(`InteractiveBrowserCredential: Failed to start the necessary web server. Error: ${err.message}`));
        }
      });
      app.on("listening", () => {
        const openPromise = this.openAuthCodeUrl(scopes, options);
        const abortSignal2 = options === null || options === void 0 ? void 0 : options.abortSignal;
        if (abortSignal2) {
          abortSignal2.addEventListener("abort", () => {
            cleanup();
            reject(new Error("Aborted"));
          });
        }
        openPromise.then().catch((e) => {
          cleanup();
          reject(e);
        });
      });
    });
  }
  async openAuthCodeUrl(scopeArray, options) {
    const cryptoProvider = new CryptoProvider();
    this.pkceCodes = await cryptoProvider.generatePkceCodes();
    const authCodeUrlParameters = {
      scopes: scopeArray,
      correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
      redirectUri: this.redirectUri,
      authority: options === null || options === void 0 ? void 0 : options.authority,
      claims: options === null || options === void 0 ? void 0 : options.claims,
      loginHint: this.loginHint,
      codeChallenge: this.pkceCodes.challenge,
      codeChallengeMethod: "S256"
      // Use SHA256 Algorithm
    };
    const response = await this.publicApp.getAuthCodeUrl(authCodeUrlParameters);
    try {
      await interactiveBrowserMockable.open(response, { wait: true, newInstance: true });
    } catch (e) {
      throw new CredentialUnavailableError(`InteractiveBrowserCredential: Could not open a browser window. Error: ${e.message}`);
    }
  }
}
const logger$3 = credentialLogger("InteractiveBrowserCredential");
class InteractiveBrowserCredential {
  /**
   * Creates an instance of InteractiveBrowserCredential with the details needed.
   *
   * This credential uses the [Authorization Code Flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).
   * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
   * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
   *
   * For Node.js, if a `clientId` is provided, the Azure Active Directory application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
   * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://docs.microsoft.com/azure/active-directory/develop/scenario-desktop-app-registration#redirect-uris).
   *
   * @param options - Options for configuring the client which makes the authentication requests.
   */
  constructor(options = {}) {
    const redirectUri = typeof options.redirectUri === "function" ? options.redirectUri() : options.redirectUri || "http://localhost";
    this.msalFlow = new MsalOpenBrowser(Object.assign(Object.assign({}, options), {
      tokenCredentialOptions: options,
      logger: logger$3,
      redirectUri
    }));
    this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * If the user provided the option `disableAutomaticAuthentication`,
   * once the token can't be retrieved silently,
   * this method won't attempt to request user interaction to retrieve the token.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
    });
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
   *
   * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
   * PKCE is a security feature that mitigates authentication code interception attacks.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                  TokenCredential implementation might make.
   */
  async authenticate(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      await this.msalFlow.getToken(arrayScopes, newOptions);
      return this.msalFlow.getActiveAccount();
    });
  }
}
class MsalDeviceCode extends MsalNode {
  constructor(options) {
    super(options);
    this.userPromptCallback = options.userPromptCallback;
  }
  async doGetToken(scopes, options) {
    try {
      const requestOptions = {
        deviceCodeCallback: this.userPromptCallback,
        scopes,
        cancel: false,
        correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
        authority: options === null || options === void 0 ? void 0 : options.authority,
        claims: options === null || options === void 0 ? void 0 : options.claims
      };
      const promise = this.publicApp.acquireTokenByDeviceCode(requestOptions);
      const deviceResponse = await this.withCancellation(promise, options === null || options === void 0 ? void 0 : options.abortSignal, () => {
        requestOptions.cancel = true;
      });
      return this.handleResult(scopes, this.clientId, deviceResponse || void 0);
    } catch (error2) {
      throw this.handleError(scopes, error2, options);
    }
  }
}
const logger$2 = credentialLogger("DeviceCodeCredential");
function defaultDeviceCodePromptCallback(deviceCodeInfo) {
  console.log(deviceCodeInfo.message);
}
class DeviceCodeCredential {
  /**
   * Creates an instance of DeviceCodeCredential with the details needed
   * to initiate the device code authorization flow with Azure Active Directory.
   *
   * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
   *
   * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
   *
   * ```js
   * const credential = new DeviceCodeCredential({
   *   tenantId: env.AZURE_TENANT_ID,
   *   clientId: env.AZURE_CLIENT_ID,
   *   userPromptCallback: (info) => {
   *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
   *   }
   * });
   * ```
   *
   * @param options - Options for configuring the client which makes the authentication requests.
   */
  constructor(options) {
    this.msalFlow = new MsalDeviceCode(Object.assign(Object.assign({}, options), { logger: logger$2, userPromptCallback: (options === null || options === void 0 ? void 0 : options.userPromptCallback) || defaultDeviceCodePromptCallback, tokenCredentialOptions: options || {} }));
    this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * If the user provided the option `disableAutomaticAuthentication`,
   * once the token can't be retrieved silently,
   * this method won't attempt to request user interaction to retrieve the token.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
    });
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                  TokenCredential implementation might make.
   */
  async authenticate(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      await this.msalFlow.getToken(arrayScopes, newOptions);
      return this.msalFlow.getActiveAccount();
    });
  }
}
class MsalAuthorizationCode extends MsalNode {
  constructor(options) {
    super(options);
    this.logger = credentialLogger("Node.js MSAL Authorization Code");
    this.redirectUri = options.redirectUri;
    this.authorizationCode = options.authorizationCode;
    if (options.clientSecret) {
      this.msalConfig.auth.clientSecret = options.clientSecret;
    }
  }
  async getAuthCodeUrl(options) {
    await this.init();
    return (this.confidentialApp || this.publicApp).getAuthCodeUrl(options);
  }
  async doGetToken(scopes, options) {
    var _a2;
    try {
      const result = await ((_a2 = this.confidentialApp || this.publicApp) === null || _a2 === void 0 ? void 0 : _a2.acquireTokenByCode({
        scopes,
        redirectUri: this.redirectUri,
        code: this.authorizationCode,
        correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
        authority: options === null || options === void 0 ? void 0 : options.authority,
        claims: options === null || options === void 0 ? void 0 : options.claims
      }));
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (err) {
      throw this.handleError(scopes, err, options);
    }
  }
}
const logger$1 = credentialLogger("AuthorizationCodeCredential");
class AuthorizationCodeCredential {
  /**
   * @hidden
   * @internal
   */
  constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
    checkTenantId(logger$1, tenantId);
    let clientSecret = clientSecretOrAuthorizationCode;
    if (typeof redirectUriOrOptions === "string") {
      this.authorizationCode = authorizationCodeOrRedirectUri;
      this.redirectUri = redirectUriOrOptions;
    } else {
      this.authorizationCode = clientSecretOrAuthorizationCode;
      this.redirectUri = authorizationCodeOrRedirectUri;
      clientSecret = void 0;
      options = redirectUriOrOptions;
    }
    this.msalFlow = new MsalAuthorizationCode(Object.assign(Object.assign({}, options), {
      clientSecret,
      clientId,
      tenantId,
      tokenCredentialOptions: options || {},
      logger: logger$1,
      redirectUri: this.redirectUri,
      authorizationCode: this.authorizationCode
    }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure any requests this
   *                TokenCredential implementation might make.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
    });
  }
}
class MsalOnBehalfOf extends MsalNode {
  constructor(options) {
    super(options);
    this.logger.info("Initialized MSAL's On-Behalf-Of flow");
    this.requiresConfidential = true;
    this.userAssertionToken = options.userAssertionToken;
    this.certificatePath = options.certificatePath;
    this.sendCertificateChain = options.sendCertificateChain;
    this.clientSecret = options.clientSecret;
  }
  // Changing the MSAL configuration asynchronously
  async init(options) {
    if (this.certificatePath) {
      try {
        const parts = await parseCertificate({ certificatePath: this.certificatePath }, this.sendCertificateChain);
        this.msalConfig.auth.clientCertificate = {
          thumbprint: parts.thumbprint,
          privateKey: parts.certificateContents,
          x5c: parts.x5c
        };
      } catch (error2) {
        this.logger.info(formatError("", error2));
        throw error2;
      }
    } else {
      this.msalConfig.auth.clientSecret = this.clientSecret;
    }
    return super.init(options);
  }
  async doGetToken(scopes, options = {}) {
    try {
      const result = await this.confidentialApp.acquireTokenOnBehalfOf({
        scopes,
        correlationId: options.correlationId,
        authority: options.authority,
        claims: options.claims,
        oboAssertion: this.userAssertionToken
      });
      return this.handleResult(scopes, this.clientId, result || void 0);
    } catch (err) {
      throw this.handleError(scopes, err, options);
    }
  }
}
const credentialName = "OnBehalfOfCredential";
const logger = credentialLogger(credentialName);
class OnBehalfOfCredential {
  constructor(options) {
    this.options = options;
    const { clientSecret } = options;
    const { certificatePath } = options;
    const { tenantId, clientId, userAssertionToken } = options;
    if (!tenantId || !clientId || !(clientSecret || certificatePath) || !userAssertionToken) {
      throw new Error(`${credentialName}: tenantId, clientId, clientSecret (or certificatePath) and userAssertionToken are required parameters.`);
    }
    this.msalFlow = new MsalOnBehalfOf(Object.assign(Object.assign({}, this.options), { logger, tokenCredentialOptions: this.options }));
  }
  /**
   * Authenticates with Azure Active Directory and returns an access token if successful.
   * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
   *
   * @param scopes - The list of scopes for which the token will have access.
   * @param options - The options used to configure the underlying network requests.
   */
  async getToken(scopes, options = {}) {
    return tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
      return this.msalFlow.getToken(arrayScopes, newOptions);
    });
  }
}
function getDefaultAzureCredential() {
  return new DefaultAzureCredential();
}
const src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AggregateAuthenticationError,
  AggregateAuthenticationErrorName,
  AuthenticationError,
  AuthenticationErrorName,
  AuthenticationRequiredError,
  AuthorizationCodeCredential,
  get AzureAuthorityHosts() {
    return AzureAuthorityHosts;
  },
  AzureCliCredential,
  AzurePowerShellCredential,
  ChainedTokenCredential,
  ClientAssertionCredential,
  ClientCertificateCredential,
  ClientSecretCredential,
  CredentialUnavailableError,
  CredentialUnavailableErrorName,
  DefaultAzureCredential,
  DeviceCodeCredential,
  EnvironmentCredential,
  InteractiveBrowserCredential,
  ManagedIdentityCredential,
  OnBehalfOfCredential,
  UsernamePasswordCredential,
  VisualStudioCodeCredential,
  deserializeAuthenticationRecord,
  getDefaultAzureCredential,
  logger: logger$l,
  serializeAuthenticationRecord,
  useIdentityPlugin
}, Symbol.toStringTag, { value: "Module" }));
const require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(src);
var debug$3 = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _events2 = require$$0$3;
  var util = _interopRequireWildcard2(require$$1$2);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj2, nodeInterop) {
    if (obj2 && obj2.__esModule) {
      return obj2;
    }
    if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
      return { default: obj2 };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj2)) {
      return cache.get(obj2);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj2) {
      if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj2, key2)) {
        var desc2 = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key2) : null;
        if (desc2 && (desc2.get || desc2.set)) {
          Object.defineProperty(newObj, key2, desc2);
        } else {
          newObj[key2] = obj2[key2];
        }
      }
    }
    newObj.default = obj2;
    if (cache) {
      cache.set(obj2, newObj);
    }
    return newObj;
  }
  class Debug extends _events2.EventEmitter {
    /*
      @options    Which debug details should be sent.
                  data    - dump of packet data
                  payload - details of decoded payload
    */
    constructor({
      data = false,
      payload = false,
      packet: packet2 = false,
      token: token2 = false
    } = {}) {
      super();
      this.options = void 0;
      this.indent = void 0;
      this.options = {
        data,
        payload,
        packet: packet2,
        token: token2
      };
      this.indent = "  ";
    }
    packet(direction, packet2) {
      if (this.haveListeners() && this.options.packet) {
        this.log("");
        this.log(direction);
        this.log(packet2.headerToString(this.indent));
      }
    }
    data(packet2) {
      if (this.haveListeners() && this.options.data) {
        this.log(packet2.dataToString(this.indent));
      }
    }
    payload(generatePayloadText) {
      if (this.haveListeners() && this.options.payload) {
        this.log(generatePayloadText());
      }
    }
    token(token2) {
      if (this.haveListeners() && this.options.token) {
        this.log(util.inspect(token2, {
          showHidden: false,
          depth: 5,
          colors: true
        }));
      }
    }
    haveListeners() {
      return this.listeners("debug").length > 0;
    }
    log(text2) {
      this.emit("debug", text2);
    }
  }
  var _default2 = Debug;
  exports$1.default = _default2;
  module2.exports = Debug;
})(debug$3, debug$3.exports);
var debugExports = debug$3.exports;
var instanceLookup$1 = {};
var abortError = {};
Object.defineProperty(abortError, "__esModule", {
  value: true
});
abortError.default = void 0;
class AbortError4 extends Error {
  constructor() {
    super("The operation was aborted");
    this.code = void 0;
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
}
abortError.default = AbortError4;
var sender = {};
Object.defineProperty(sender, "__esModule", {
  value: true
});
sender.sendInParallel = sendInParallel;
sender.sendMessage = sendMessage;
var _dgram = _interopRequireDefault$7(require$$0$7);
var _net$1 = _interopRequireDefault$7(require$$0$6);
var punycode$1 = _interopRequireWildcard$1(require$$2$2);
var _abortError$2 = _interopRequireDefault$7(abortError);
function _getRequireWildcardCache$1(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$1 = function(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard$1(obj2, nodeInterop) {
  if (obj2 && obj2.__esModule) {
    return obj2;
  }
  if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
    return { default: obj2 };
  }
  var cache = _getRequireWildcardCache$1(nodeInterop);
  if (cache && cache.has(obj2)) {
    return cache.get(obj2);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key2 in obj2) {
    if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj2, key2)) {
      var desc2 = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key2) : null;
      if (desc2 && (desc2.get || desc2.set)) {
        Object.defineProperty(newObj, key2, desc2);
      } else {
        newObj[key2] = obj2[key2];
      }
    }
  }
  newObj.default = obj2;
  if (cache) {
    cache.set(obj2, newObj);
  }
  return newObj;
}
function _interopRequireDefault$7(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
async function sendInParallel(addresses, port, request2, signal) {
  if (signal.aborted) {
    throw new _abortError$2.default();
  }
  return await new Promise((resolve, reject) => {
    const sockets = [];
    let errorCount = 0;
    const onError = (err) => {
      errorCount++;
      if (errorCount === addresses.length) {
        signal.removeEventListener("abort", onAbort);
        clearSockets();
        reject(err);
      }
    };
    const onMessage = (message2) => {
      signal.removeEventListener("abort", onAbort);
      clearSockets();
      resolve(message2);
    };
    const onAbort = () => {
      clearSockets();
      reject(new _abortError$2.default());
    };
    const clearSockets = () => {
      for (const socket of sockets) {
        socket.removeListener("error", onError);
        socket.removeListener("message", onMessage);
        socket.close();
      }
    };
    signal.addEventListener("abort", onAbort, {
      once: true
    });
    for (let j = 0; j < addresses.length; j++) {
      const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
      const socket = _dgram.default.createSocket(udpType);
      sockets.push(socket);
      socket.on("error", onError);
      socket.on("message", onMessage);
      socket.send(request2, 0, request2.length, port, addresses[j].address);
    }
  });
}
async function sendMessage(host, port, lookup, signal, request2) {
  if (signal.aborted) {
    throw new _abortError$2.default();
  }
  let addresses;
  if (_net$1.default.isIP(host)) {
    addresses = [{
      address: host,
      family: _net$1.default.isIPv6(host) ? 6 : 4
    }];
  } else {
    addresses = await new Promise((resolve, reject) => {
      const onAbort = () => {
        reject(new _abortError$2.default());
      };
      signal.addEventListener("abort", onAbort);
      lookup(punycode$1.toASCII(host), {
        all: true
      }, (err, addresses2) => {
        signal.removeEventListener("abort", onAbort);
        err ? reject(err) : resolve(addresses2);
      });
    });
  }
  return await sendInParallel(addresses, port, request2, signal);
}
var withTimeout$1 = {};
const { EventEmitter } = require$$0$3;
let AbortSignal$1 = class AbortSignal3 {
  constructor() {
    this.eventEmitter = new EventEmitter();
    this.onabort = null;
    this.aborted = false;
    this.reason = void 0;
  }
  toString() {
    return "[object AbortSignal]";
  }
  get [Symbol.toStringTag]() {
    return "AbortSignal";
  }
  removeEventListener(name2, handler2) {
    this.eventEmitter.removeListener(name2, handler2);
  }
  addEventListener(name2, handler2) {
    this.eventEmitter.on(name2, handler2);
  }
  dispatchEvent(type2) {
    const event = { type: type2, target: this };
    const handlerName = `on${type2}`;
    if (typeof this[handlerName] === "function") this[handlerName](event);
    this.eventEmitter.emit(type2, event);
  }
  throwIfAborted() {
    if (this.aborted) {
      throw this.reason;
    }
  }
  static abort(reason) {
    const controller = new AbortController$1();
    controller.abort();
    return controller.signal;
  }
  static timeout(time2) {
    const controller = new AbortController$1();
    setTimeout(() => controller.abort(new Error("TimeoutError")), time2);
    return controller.signal;
  }
};
let AbortController$1 = class AbortController3 {
  constructor() {
    this.signal = new AbortSignal$1();
  }
  abort(reason) {
    if (this.signal.aborted) return;
    this.signal.aborted = true;
    if (reason) this.signal.reason = reason;
    else this.signal.reason = new Error("AbortError");
    this.signal.dispatchEvent("abort");
  }
  toString() {
    return "[object AbortController]";
  }
  get [Symbol.toStringTag]() {
    return "AbortController";
  }
};
var nodeAbortController = { AbortController: AbortController$1 };
var timeoutError = {};
Object.defineProperty(timeoutError, "__esModule", {
  value: true
});
timeoutError.default = void 0;
class TimeoutError2 extends Error {
  constructor() {
    super("The operation was aborted due to timeout");
    this.code = void 0;
    this.code = "TIMEOUT_ERR";
    this.name = "TimeoutError";
  }
}
timeoutError.default = TimeoutError2;
Object.defineProperty(withTimeout$1, "__esModule", {
  value: true
});
withTimeout$1.withTimeout = withTimeout;
var _nodeAbortController = nodeAbortController;
var _timeoutError = _interopRequireDefault$6(timeoutError);
function _interopRequireDefault$6(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
async function withTimeout(timeout2, func, signal) {
  const timeoutController = new _nodeAbortController.AbortController();
  const abortCurrentAttempt = () => {
    timeoutController.abort();
  };
  const timer = setTimeout(abortCurrentAttempt, timeout2);
  signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", abortCurrentAttempt, {
    once: true
  });
  try {
    return await func(timeoutController.signal);
  } catch (err) {
    if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
      throw new _timeoutError.default();
    }
    throw err;
  } finally {
    signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", abortCurrentAttempt);
    clearTimeout(timer);
  }
}
Object.defineProperty(instanceLookup$1, "__esModule", {
  value: true
});
instanceLookup$1.instanceLookup = instanceLookup;
instanceLookup$1.parseBrowserResponse = parseBrowserResponse;
var _dns = _interopRequireDefault$5(require$$0$8);
var _abortError$1 = _interopRequireDefault$5(abortError);
var _sender = sender;
var _withTimeout = withTimeout$1;
function _interopRequireDefault$5(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
const SQL_SERVER_BROWSER_PORT = 1434;
const TIMEOUT = 2 * 1e3;
const RETRIES = 3;
const MYSTERY_HEADER_LENGTH = 3;
async function instanceLookup(options) {
  const server = options.server;
  if (typeof server !== "string") {
    throw new TypeError('Invalid arguments: "server" must be a string');
  }
  const instanceName = options.instanceName;
  if (typeof instanceName !== "string") {
    throw new TypeError('Invalid arguments: "instanceName" must be a string');
  }
  const timeout2 = options.timeout === void 0 ? TIMEOUT : options.timeout;
  if (typeof timeout2 !== "number") {
    throw new TypeError('Invalid arguments: "timeout" must be a number');
  }
  const retries = options.retries === void 0 ? RETRIES : options.retries;
  if (typeof retries !== "number") {
    throw new TypeError('Invalid arguments: "retries" must be a number');
  }
  if (options.lookup !== void 0 && typeof options.lookup !== "function") {
    throw new TypeError('Invalid arguments: "lookup" must be a function');
  }
  const lookup = options.lookup ?? _dns.default.lookup;
  if (options.port !== void 0 && typeof options.port !== "number") {
    throw new TypeError('Invalid arguments: "port" must be a number');
  }
  const port = options.port ?? SQL_SERVER_BROWSER_PORT;
  const signal = options.signal;
  if (signal.aborted) {
    throw new _abortError$1.default();
  }
  let response;
  for (let i = 0; i <= retries; i++) {
    try {
      response = await (0, _withTimeout.withTimeout)(timeout2, async (signal2) => {
        const request2 = Buffer.from([2]);
        return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request2);
      }, signal);
    } catch (err) {
      if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
        continue;
      }
      throw err;
    }
  }
  if (!response) {
    throw new Error("Failed to get response from SQL Server Browser on " + server);
  }
  const message2 = response.toString("ascii", MYSTERY_HEADER_LENGTH);
  const foundPort = parseBrowserResponse(message2, instanceName);
  if (!foundPort) {
    throw new Error("Port for " + instanceName + " not found in " + options.server);
  }
  return foundPort;
}
function parseBrowserResponse(response, instanceName) {
  let getPort;
  const instances = response.split(";;");
  for (let i = 0, len = instances.length; i < len; i++) {
    const instance = instances[i];
    const parts = instance.split(";");
    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
      const name2 = parts[p];
      const value = parts[p + 1];
      if (name2 === "tcp" && getPort) {
        const port = parseInt(value, 10);
        return port;
      }
      if (name2 === "InstanceName") {
        if (value.toUpperCase() === instanceName.toUpperCase()) {
          getPort = true;
        } else {
          getPort = false;
        }
      }
    }
  }
}
var transientErrorLookup = {};
Object.defineProperty(transientErrorLookup, "__esModule", {
  value: true
});
transientErrorLookup.TransientErrorLookup = void 0;
class TransientErrorLookup {
  isTransientError(error2) {
    const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
    return transientErrors.indexOf(error2) !== -1;
  }
}
transientErrorLookup.TransientErrorLookup = TransientErrorLookup;
var packet = {};
var sprintf = {};
(function(exports$1) {
  !function() {
    var re2 = {
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key2) {
      return sprintf_format(sprintf_parse(key2), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign4;
      for (i = 0; i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph.keys.length; k++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re2.not_type.test(ph.type) && re2.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re2.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re2.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re2.json.test(ph.type)) {
            output += arg;
          } else {
            if (re2.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign4 = is_positive ? "+" : "-";
              arg = arg.toString().replace(re2.sign, "");
            } else {
              sign4 = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign4 + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign4 + arg + pad : pad_character === "0" ? sign4 + pad + arg : pad + sign4 + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = re2.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re2.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match = re2.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = re2.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re2.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re2.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match[0],
              param_no: match[1],
              keys: match[2],
              sign: match[3],
              pad_char: match[4],
              align: match[5],
              width: match[6],
              precision: match[7],
              type: match[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports$1["sprintf"] = sprintf2;
      exports$1["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
Object.defineProperty(packet, "__esModule", {
  value: true
});
packet.TYPE = packet.Packet = packet.OFFSET = packet.HEADER_LENGTH = void 0;
packet.isPacketComplete = isPacketComplete;
packet.packetLength = packetLength;
var _sprintfJs = sprintf;
const HEADER_LENGTH = 8;
packet.HEADER_LENGTH = HEADER_LENGTH;
const TYPE$2 = {
  SQL_BATCH: 1,
  RPC_REQUEST: 3,
  TABULAR_RESULT: 4,
  ATTENTION: 6,
  BULK_LOAD: 7,
  TRANSACTION_MANAGER: 14,
  LOGIN7: 16,
  NTLMAUTH_PKT: 17,
  PRELOGIN: 18,
  FEDAUTH_TOKEN: 8
};
packet.TYPE = TYPE$2;
const typeByValue = {};
for (const name2 in TYPE$2) {
  typeByValue[TYPE$2[name2]] = name2;
}
const STATUS$1 = {
  NORMAL: 0,
  EOM: 1,
  IGNORE: 2,
  RESETCONNECTION: 8,
  RESETCONNECTIONSKIPTRAN: 16
};
const OFFSET = {
  Type: 0,
  Status: 1,
  Length: 2,
  SPID: 4,
  PacketID: 6,
  Window: 7
};
packet.OFFSET = OFFSET;
const DEFAULT_SPID = 0;
const DEFAULT_PACKETID = 1;
const DEFAULT_WINDOW = 0;
const NL = "\n";
class Packet {
  constructor(typeOrBuffer) {
    this.buffer = void 0;
    if (typeOrBuffer instanceof Buffer) {
      this.buffer = typeOrBuffer;
    } else {
      const type2 = typeOrBuffer;
      this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
      this.buffer.writeUInt8(type2, OFFSET.Type);
      this.buffer.writeUInt8(STATUS$1.NORMAL, OFFSET.Status);
      this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
      this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
      this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
      this.setLength();
    }
  }
  setLength() {
    this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
  }
  length() {
    return this.buffer.readUInt16BE(OFFSET.Length);
  }
  resetConnection(reset) {
    let status = this.buffer.readUInt8(OFFSET.Status);
    if (reset) {
      status |= STATUS$1.RESETCONNECTION;
    } else {
      status &= 255 - STATUS$1.RESETCONNECTION;
    }
    this.buffer.writeUInt8(status, OFFSET.Status);
  }
  last(last) {
    let status = this.buffer.readUInt8(OFFSET.Status);
    if (arguments.length > 0) {
      if (last) {
        status |= STATUS$1.EOM;
      } else {
        status &= 255 - STATUS$1.EOM;
      }
      this.buffer.writeUInt8(status, OFFSET.Status);
    }
    return this.isLast();
  }
  ignore(last) {
    let status = this.buffer.readUInt8(OFFSET.Status);
    if (last) {
      status |= STATUS$1.IGNORE;
    } else {
      status &= 255 - STATUS$1.IGNORE;
    }
    this.buffer.writeUInt8(status, OFFSET.Status);
  }
  isLast() {
    return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS$1.EOM);
  }
  packetId(packetId) {
    if (packetId) {
      this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
    }
    return this.buffer.readUInt8(OFFSET.PacketID);
  }
  addData(data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    this.setLength();
    return this;
  }
  data() {
    return this.buffer.slice(HEADER_LENGTH);
  }
  type() {
    return this.buffer.readUInt8(OFFSET.Type);
  }
  statusAsString() {
    const status = this.buffer.readUInt8(OFFSET.Status);
    const statuses = [];
    for (const name2 in STATUS$1) {
      const value = STATUS$1[name2];
      if (status & value) {
        statuses.push(name2);
      } else {
        statuses.push(void 0);
      }
    }
    return statuses.join(" ").trim();
  }
  headerToString(indent = "") {
    const text2 = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
    return indent + text2;
  }
  dataToString(indent = "") {
    const BYTES_PER_GROUP = 4;
    const CHARS_PER_GROUP = 8;
    const BYTES_PER_LINE = 32;
    const data = this.data();
    let dataDump = "";
    let chars = "";
    for (let offset = 0; offset < data.length; offset++) {
      if (offset % BYTES_PER_LINE === 0) {
        dataDump += indent;
        dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
      }
      if (data[offset] < 32 || data[offset] > 126) {
        chars += ".";
        if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
          chars += " ";
        }
      } else {
        chars += String.fromCharCode(data[offset]);
      }
      if (data[offset] != null) {
        dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
      }
      if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
        dataDump += " ";
      }
      if ((offset + 1) % BYTES_PER_LINE === 0) {
        dataDump += "  " + chars;
        chars = "";
        if (offset < data.length - 1) {
          dataDump += NL;
        }
      }
    }
    if (chars.length) {
      dataDump += "  " + chars;
    }
    return dataDump;
  }
  toString(indent = "") {
    return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
  }
  payloadString() {
    return "";
  }
}
packet.Packet = Packet;
function isPacketComplete(potentialPacketBuffer) {
  if (potentialPacketBuffer.length < HEADER_LENGTH) {
    return false;
  } else {
    return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
  }
}
function packetLength(potentialPacketBuffer) {
  return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
}
var preloginPayload = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _sprintfJs2 = sprintf;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const optionBufferSize = 20;
  const TOKEN = {
    VERSION: 0,
    ENCRYPTION: 1,
    INSTOPT: 2,
    THREADID: 3,
    MARS: 4,
    FEDAUTHREQUIRED: 6,
    TERMINATOR: 255
  };
  const ENCRYPT = {
    OFF: 0,
    ON: 1,
    NOT_SUP: 2,
    REQ: 3
  };
  const encryptByValue = {};
  for (const name2 in ENCRYPT) {
    const value = ENCRYPT[name2];
    encryptByValue[value] = name2;
  }
  const MARS = {
    OFF: 0,
    ON: 1
  };
  const marsByValue = {};
  for (const name2 in MARS) {
    const value = MARS[name2];
    marsByValue[value] = name2;
  }
  class PreloginPayload {
    constructor(bufferOrOptions = {
      encrypt: false,
      version: {
        major: 0,
        minor: 0,
        build: 0,
        subbuild: 0
      }
    }) {
      this.data = void 0;
      this.options = void 0;
      this.version = void 0;
      this.encryption = void 0;
      this.encryptionString = void 0;
      this.instance = void 0;
      this.threadId = void 0;
      this.mars = void 0;
      this.marsString = void 0;
      this.fedAuthRequired = void 0;
      if (bufferOrOptions instanceof Buffer) {
        this.data = bufferOrOptions;
        this.options = {
          encrypt: false,
          version: {
            major: 0,
            minor: 0,
            build: 0,
            subbuild: 0
          }
        };
      } else {
        this.options = bufferOrOptions;
        this.createOptions();
      }
      this.extractOptions();
    }
    createOptions() {
      const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
      let length = 0;
      for (let i = 0, len = options.length; i < len; i++) {
        const option = options[i];
        length += 5 + option.data.length;
      }
      length++;
      this.data = Buffer.alloc(length, 0);
      let optionOffset = 0;
      let optionDataOffset = 5 * options.length + 1;
      for (let j = 0, len = options.length; j < len; j++) {
        const option = options[j];
        this.data.writeUInt8(option.token, optionOffset + 0);
        this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
        this.data.writeUInt16BE(option.data.length, optionOffset + 3);
        optionOffset += 5;
        option.data.copy(this.data, optionDataOffset);
        optionDataOffset += option.data.length;
      }
      this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
    }
    createVersionOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      buffer2.writeUInt8(this.options.version.major);
      buffer2.writeUInt8(this.options.version.minor);
      buffer2.writeUInt16BE(this.options.version.build);
      buffer2.writeUInt16BE(this.options.version.subbuild);
      return {
        token: TOKEN.VERSION,
        data: buffer2.data
      };
    }
    createEncryptionOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      if (this.options.encrypt) {
        buffer2.writeUInt8(ENCRYPT.ON);
      } else {
        buffer2.writeUInt8(ENCRYPT.NOT_SUP);
      }
      return {
        token: TOKEN.ENCRYPTION,
        data: buffer2.data
      };
    }
    createInstanceOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      buffer2.writeUInt8(0);
      return {
        token: TOKEN.INSTOPT,
        data: buffer2.data
      };
    }
    createThreadIdOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      buffer2.writeUInt32BE(0);
      return {
        token: TOKEN.THREADID,
        data: buffer2.data
      };
    }
    createMarsOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      buffer2.writeUInt8(MARS.OFF);
      return {
        token: TOKEN.MARS,
        data: buffer2.data
      };
    }
    createFedAuthOption() {
      const buffer2 = new _writableTrackingBuffer2.default(optionBufferSize);
      buffer2.writeUInt8(1);
      return {
        token: TOKEN.FEDAUTHREQUIRED,
        data: buffer2.data
      };
    }
    extractOptions() {
      let offset = 0;
      while (this.data[offset] !== TOKEN.TERMINATOR) {
        let dataOffset = this.data.readUInt16BE(offset + 1);
        const dataLength = this.data.readUInt16BE(offset + 3);
        switch (this.data[offset]) {
          case TOKEN.VERSION:
            this.extractVersion(dataOffset);
            break;
          case TOKEN.ENCRYPTION:
            this.extractEncryption(dataOffset);
            break;
          case TOKEN.INSTOPT:
            this.extractInstance(dataOffset);
            break;
          case TOKEN.THREADID:
            if (dataLength > 0) {
              this.extractThreadId(dataOffset);
            }
            break;
          case TOKEN.MARS:
            this.extractMars(dataOffset);
            break;
          case TOKEN.FEDAUTHREQUIRED:
            this.extractFedAuth(dataOffset);
            break;
        }
        offset += 5;
        dataOffset += dataLength;
      }
    }
    extractVersion(offset) {
      this.version = {
        major: this.data.readUInt8(offset + 0),
        minor: this.data.readUInt8(offset + 1),
        build: this.data.readUInt16BE(offset + 2),
        subbuild: this.data.readUInt16BE(offset + 4)
      };
    }
    extractEncryption(offset) {
      this.encryption = this.data.readUInt8(offset);
      this.encryptionString = encryptByValue[this.encryption];
    }
    extractInstance(offset) {
      this.instance = this.data.readUInt8(offset);
    }
    extractThreadId(offset) {
      this.threadId = this.data.readUInt32BE(offset);
    }
    extractMars(offset) {
      this.mars = this.data.readUInt8(offset);
      this.marsString = marsByValue[this.mars];
    }
    extractFedAuth(offset) {
      this.fedAuthRequired = this.data.readUInt8(offset);
    }
    toString(indent = "") {
      return indent + "PreLogin - " + (0, _sprintfJs2.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
    }
  }
  var _default2 = PreloginPayload;
  exports$1.default = _default2;
  module2.exports = PreloginPayload;
})(preloginPayload, preloginPayload.exports);
var preloginPayloadExports = preloginPayload.exports;
var login7Payload = { exports: {} };
var tdsVersions = {};
Object.defineProperty(tdsVersions, "__esModule", {
  value: true
});
tdsVersions.versionsByValue = tdsVersions.versions = void 0;
const versions = {
  "7_1": 1895825409,
  "7_2": 1913192450,
  "7_3_A": 1930035203,
  "7_3_B": 1930100739,
  "7_4": 1946157060
};
tdsVersions.versions = versions;
const versionsByValue = {};
tdsVersions.versionsByValue = versionsByValue;
for (const name2 in versions) {
  versionsByValue[versions[name2]] = name2;
}
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _sprintfJs2 = sprintf;
  var _tdsVersions = tdsVersions;
  const FLAGS_1 = {
    ENDIAN_LITTLE: 0,
    CHARSET_ASCII: 0,
    FLOAT_IEEE_754: 0,
    BCP_DUMPLOAD_OFF: 16,
    USE_DB_OFF: 32,
    INIT_DB_WARN: 0,
    INIT_DB_FATAL: 64,
    SET_LANG_WARN_ON: 128
  };
  const FLAGS_2 = {
    INIT_LANG_WARN: 0,
    ODBC_OFF: 0,
    USER_NORMAL: 0,
    INTEGRATED_SECURITY_OFF: 0,
    INTEGRATED_SECURITY_ON: 128
  };
  const TYPE_FLAGS = {
    SQL_DFLT: 0,
    OLEDB_OFF: 0,
    READ_WRITE_INTENT: 0,
    READ_ONLY_INTENT: 32
  };
  const FLAGS_3 = {
    CHANGE_PASSWORD_NO: 0,
    UNKNOWN_COLLATION_HANDLING: 8,
    EXTENSION_USED: 16
  };
  const FEDAUTH_OPTIONS = {
    FEATURE_ID: 2,
    LIBRARY_SECURITYTOKEN: 1,
    LIBRARY_ADAL: 2,
    FEDAUTH_YES_ECHO: 1,
    FEDAUTH_NO_ECHO: 0,
    ADAL_WORKFLOW_USER_PASS: 1
  };
  const FEATURE_EXT_TERMINATOR = 255;
  class Login7Payload {
    constructor({
      tdsVersion,
      packetSize,
      clientProgVer,
      clientPid,
      connectionId,
      clientTimeZone,
      clientLcid
    }) {
      this.tdsVersion = void 0;
      this.packetSize = void 0;
      this.clientProgVer = void 0;
      this.clientPid = void 0;
      this.connectionId = void 0;
      this.clientTimeZone = void 0;
      this.clientLcid = void 0;
      this.readOnlyIntent = void 0;
      this.initDbFatal = void 0;
      this.userName = void 0;
      this.password = void 0;
      this.serverName = void 0;
      this.appName = void 0;
      this.hostname = void 0;
      this.libraryName = void 0;
      this.language = void 0;
      this.database = void 0;
      this.clientId = void 0;
      this.sspi = void 0;
      this.attachDbFile = void 0;
      this.changePassword = void 0;
      this.fedAuth = void 0;
      this.tdsVersion = tdsVersion;
      this.packetSize = packetSize;
      this.clientProgVer = clientProgVer;
      this.clientPid = clientPid;
      this.connectionId = connectionId;
      this.clientTimeZone = clientTimeZone;
      this.clientLcid = clientLcid;
      this.readOnlyIntent = false;
      this.initDbFatal = false;
      this.fedAuth = void 0;
      this.userName = void 0;
      this.password = void 0;
      this.serverName = void 0;
      this.appName = void 0;
      this.hostname = void 0;
      this.libraryName = void 0;
      this.language = void 0;
      this.database = void 0;
      this.clientId = void 0;
      this.sspi = void 0;
      this.attachDbFile = void 0;
      this.changePassword = void 0;
    }
    toBuffer() {
      const fixedData = Buffer.alloc(94);
      const buffers = [fixedData];
      let offset = 0;
      let dataOffset = fixedData.length;
      offset = fixedData.writeUInt32LE(0, offset);
      offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
      offset = fixedData.writeUInt32LE(this.packetSize, offset);
      offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
      offset = fixedData.writeUInt32LE(this.clientPid, offset);
      offset = fixedData.writeUInt32LE(this.connectionId, offset);
      offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
      offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
      offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
      offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
      offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
      offset = fixedData.writeUInt32LE(this.clientLcid, offset);
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.hostname) {
        const buffer2 = Buffer.from(this.hostname, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(dataOffset, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.userName) {
        const buffer2 = Buffer.from(this.userName, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.password) {
        const buffer2 = Buffer.from(this.password, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(this.scramblePassword(buffer2));
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.appName) {
        const buffer2 = Buffer.from(this.appName, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.serverName) {
        const buffer2 = Buffer.from(this.serverName, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      const extensions = this.buildFeatureExt();
      offset = fixedData.writeUInt16LE(4, offset);
      const extensionOffset = Buffer.alloc(4);
      extensionOffset.writeUInt32LE(dataOffset += 4, 0);
      dataOffset += extensions.length;
      buffers.push(extensionOffset, extensions);
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.libraryName) {
        const buffer2 = Buffer.from(this.libraryName, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.language) {
        const buffer2 = Buffer.from(this.language, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.database) {
        const buffer2 = Buffer.from(this.database, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      if (this.clientId) {
        this.clientId.copy(fixedData, offset, 0, 6);
      }
      offset += 6;
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.sspi) {
        if (this.sspi.length > 65535) {
          offset = fixedData.writeUInt16LE(65535, offset);
        } else {
          offset = fixedData.writeUInt16LE(this.sspi.length, offset);
        }
        buffers.push(this.sspi);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.attachDbFile) {
        const buffer2 = Buffer.from(this.attachDbFile, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      offset = fixedData.writeUInt16LE(dataOffset, offset);
      if (this.changePassword) {
        const buffer2 = Buffer.from(this.changePassword, "ucs2");
        offset = fixedData.writeUInt16LE(buffer2.length / 2, offset);
        dataOffset += buffer2.length;
        buffers.push(buffer2);
      } else {
        offset = fixedData.writeUInt16LE(0, offset);
      }
      if (this.sspi && this.sspi.length > 65535) {
        fixedData.writeUInt32LE(this.sspi.length, offset);
      } else {
        fixedData.writeUInt32LE(0, offset);
      }
      const data = Buffer.concat(buffers);
      data.writeUInt32LE(data.length, 0);
      return data;
    }
    buildOptionFlags1() {
      let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
      if (this.initDbFatal) {
        flags1 |= FLAGS_1.INIT_DB_FATAL;
      } else {
        flags1 |= FLAGS_1.INIT_DB_WARN;
      }
      return flags1;
    }
    buildFeatureExt() {
      const buffers = [];
      const fedAuth = this.fedAuth;
      if (fedAuth) {
        switch (fedAuth.type) {
          case "ADAL":
            const buffer2 = Buffer.alloc(7);
            buffer2.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
            buffer2.writeUInt32LE(2, 1);
            buffer2.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
            buffer2.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
            buffers.push(buffer2);
            break;
          case "SECURITYTOKEN":
            const token2 = Buffer.from(fedAuth.fedAuthToken, "ucs2");
            const buf = Buffer.alloc(10);
            let offset = 0;
            offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
            offset = buf.writeUInt32LE(token2.length + 4 + 1, offset);
            offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
            buf.writeInt32LE(token2.length, offset);
            buffers.push(buf);
            buffers.push(token2);
            break;
        }
      }
      if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
        const UTF8_SUPPORT_FEATURE_ID = 10;
        const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
        const buf = Buffer.alloc(6);
        buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
        buf.writeUInt32LE(1, 1);
        buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
        buffers.push(buf);
      }
      buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
      return Buffer.concat(buffers);
    }
    buildOptionFlags2() {
      let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
      if (this.sspi) {
        flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
      } else {
        flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
      }
      return flags2;
    }
    buildTypeFlags() {
      let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
      if (this.readOnlyIntent) {
        typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
      } else {
        typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
      }
      return typeFlags;
    }
    buildOptionFlags3() {
      return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
    }
    scramblePassword(password) {
      for (let b = 0, len = password.length; b < len; b++) {
        let byte = password[b];
        const lowNibble = byte & 15;
        const highNibble = byte >> 4;
        byte = lowNibble << 4 | highNibble;
        byte = byte ^ 165;
        password[b] = byte;
      }
      return password;
    }
    toString(indent = "") {
      return indent + "Login7 - " + (0, _sprintfJs2.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs2.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs2.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs2.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
    }
  }
  var _default2 = Login7Payload;
  exports$1.default = _default2;
  module2.exports = Login7Payload;
})(login7Payload, login7Payload.exports);
var login7PayloadExports = login7Payload.exports;
var ntlmPayload = { exports: {} };
var md4 = { exports: {} };
/**
 * [js-md4]{@link https://github.com/emn178/js-md4}
 *
 * @namespace md4
 * @version 0.3.2
 * @author Yi-Cyuan Chen [emn178@gmail.com]
 * @copyright Yi-Cyuan Chen 2015-2027
 * @license MIT
 */
(function(module2) {
  (function() {
    var root = typeof window === "object" ? window : {};
    var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    }
    var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [128, 32768, 8388608, -2147483648];
    var SHIFT = [0, 8, 16, 24];
    var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
    var blocks = [], buffer8;
    if (ARRAY_BUFFER) {
      var buffer2 = new ArrayBuffer(68);
      buffer8 = new Uint8Array(buffer2);
      blocks = new Uint32Array(buffer2);
    }
    var createOutputMethod = function(outputType) {
      return function(message2) {
        return new Md4(true).update(message2)[outputType]();
      };
    };
    var createMethod = function() {
      var method = createOutputMethod("hex");
      if (NODE_JS) {
        method = nodeWrap(method);
      }
      method.create = function() {
        return new Md4();
      };
      method.update = function(message2) {
        return method.create().update(message2);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type2 = OUTPUT_TYPES[i];
        method[type2] = createOutputMethod(type2);
      }
      return method;
    };
    var nodeWrap = function(method) {
      var crypto2 = crypto$2;
      var Buffer2 = require$$0$5.Buffer;
      var nodeMethod = function(message2) {
        if (typeof message2 === "string") {
          return crypto2.createHash("md4").update(message2, "utf8").digest("hex");
        } else if (ARRAY_BUFFER && message2 instanceof ArrayBuffer) {
          message2 = new Uint8Array(message2);
        } else if (message2.length === void 0) {
          return method(message2);
        }
        return crypto2.createHash("md4").update(new Buffer2(message2)).digest("hex");
      };
      return nodeMethod;
    };
    function Md4(sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
        this.buffer8 = buffer8;
      } else {
        if (ARRAY_BUFFER) {
          var buffer3 = new ArrayBuffer(68);
          this.buffer8 = new Uint8Array(buffer3);
          this.blocks = new Uint32Array(buffer3);
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
      }
      this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
    }
    Md4.prototype.update = function(message2) {
      if (this.finalized) {
        return;
      }
      var notString = typeof message2 !== "string";
      if (notString && ARRAY_BUFFER && message2 instanceof ArrayBuffer) {
        message2 = new Uint8Array(message2);
      }
      var code, index = 0, i, length = message2.length || 0, blocks2 = this.blocks;
      var buffer82 = this.buffer8;
      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              buffer82[i++] = message2[index];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message2[index] << SHIFT[i++ & 3];
            }
          }
        } else {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message2.charCodeAt(index);
              if (code < 128) {
                buffer82[i++] = code;
              } else if (code < 2048) {
                buffer82[i++] = 192 | code >> 6;
                buffer82[i++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                buffer82[i++] = 224 | code >> 12;
                buffer82[i++] = 128 | code >> 6 & 63;
                buffer82[i++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                buffer82[i++] = 240 | code >> 18;
                buffer82[i++] = 128 | code >> 12 & 63;
                buffer82[i++] = 128 | code >> 6 & 63;
                buffer82[i++] = 128 | code & 63;
              }
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message2.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      return this;
    };
    Md4.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[i >> 2] |= EXTRA[i & 3];
      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = blocks2[16];
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.bytes << 3;
      this.hash();
    };
    Md4.prototype.hash = function() {
      var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
      if (this.first) {
        a = blocks2[0] - 1;
        a = a << 3 | a >>> 29;
        d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
        d = d << 7 | d >>> 25;
        c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
        c = c << 11 | c >>> 21;
        b = (c & d | ~c & a) + blocks2[3] - 271733879;
        b = b << 19 | b >>> 13;
      } else {
        a = this.h0;
        b = this.h1;
        c = this.h2;
        d = this.h3;
        a += (b & c | ~b & d) + blocks2[0];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[1];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[2];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[3];
        b = b << 19 | b >>> 13;
      }
      a += (b & c | ~b & d) + blocks2[4];
      a = a << 3 | a >>> 29;
      d += (a & b | ~a & c) + blocks2[5];
      d = d << 7 | d >>> 25;
      c += (d & a | ~d & b) + blocks2[6];
      c = c << 11 | c >>> 21;
      b += (c & d | ~c & a) + blocks2[7];
      b = b << 19 | b >>> 13;
      a += (b & c | ~b & d) + blocks2[8];
      a = a << 3 | a >>> 29;
      d += (a & b | ~a & c) + blocks2[9];
      d = d << 7 | d >>> 25;
      c += (d & a | ~d & b) + blocks2[10];
      c = c << 11 | c >>> 21;
      b += (c & d | ~c & a) + blocks2[11];
      b = b << 19 | b >>> 13;
      a += (b & c | ~b & d) + blocks2[12];
      a = a << 3 | a >>> 29;
      d += (a & b | ~a & c) + blocks2[13];
      d = d << 7 | d >>> 25;
      c += (d & a | ~d & b) + blocks2[14];
      c = c << 11 | c >>> 21;
      b += (c & d | ~c & a) + blocks2[15];
      b = b << 19 | b >>> 13;
      bc = b & c;
      a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
      a = a << 3 | a >>> 29;
      ab = a & b;
      d += (ab | a & c | bc) + blocks2[4] + 1518500249;
      d = d << 5 | d >>> 27;
      da = d & a;
      c += (da | d & b | ab) + blocks2[8] + 1518500249;
      c = c << 9 | c >>> 23;
      cd = c & d;
      b += (cd | c & a | da) + blocks2[12] + 1518500249;
      b = b << 13 | b >>> 19;
      bc = b & c;
      a += (bc | b & d | cd) + blocks2[1] + 1518500249;
      a = a << 3 | a >>> 29;
      ab = a & b;
      d += (ab | a & c | bc) + blocks2[5] + 1518500249;
      d = d << 5 | d >>> 27;
      da = d & a;
      c += (da | d & b | ab) + blocks2[9] + 1518500249;
      c = c << 9 | c >>> 23;
      cd = c & d;
      b += (cd | c & a | da) + blocks2[13] + 1518500249;
      b = b << 13 | b >>> 19;
      bc = b & c;
      a += (bc | b & d | cd) + blocks2[2] + 1518500249;
      a = a << 3 | a >>> 29;
      ab = a & b;
      d += (ab | a & c | bc) + blocks2[6] + 1518500249;
      d = d << 5 | d >>> 27;
      da = d & a;
      c += (da | d & b | ab) + blocks2[10] + 1518500249;
      c = c << 9 | c >>> 23;
      cd = c & d;
      b += (cd | c & a | da) + blocks2[14] + 1518500249;
      b = b << 13 | b >>> 19;
      bc = b & c;
      a += (bc | b & d | cd) + blocks2[3] + 1518500249;
      a = a << 3 | a >>> 29;
      ab = a & b;
      d += (ab | a & c | bc) + blocks2[7] + 1518500249;
      d = d << 5 | d >>> 27;
      da = d & a;
      c += (da | d & b | ab) + blocks2[11] + 1518500249;
      c = c << 9 | c >>> 23;
      b += (c & d | c & a | da) + blocks2[15] + 1518500249;
      b = b << 13 | b >>> 19;
      bc = b ^ c;
      a += (bc ^ d) + blocks2[0] + 1859775393;
      a = a << 3 | a >>> 29;
      d += (bc ^ a) + blocks2[8] + 1859775393;
      d = d << 9 | d >>> 23;
      da = d ^ a;
      c += (da ^ b) + blocks2[4] + 1859775393;
      c = c << 11 | c >>> 21;
      b += (da ^ c) + blocks2[12] + 1859775393;
      b = b << 15 | b >>> 17;
      bc = b ^ c;
      a += (bc ^ d) + blocks2[2] + 1859775393;
      a = a << 3 | a >>> 29;
      d += (bc ^ a) + blocks2[10] + 1859775393;
      d = d << 9 | d >>> 23;
      da = d ^ a;
      c += (da ^ b) + blocks2[6] + 1859775393;
      c = c << 11 | c >>> 21;
      b += (da ^ c) + blocks2[14] + 1859775393;
      b = b << 15 | b >>> 17;
      bc = b ^ c;
      a += (bc ^ d) + blocks2[1] + 1859775393;
      a = a << 3 | a >>> 29;
      d += (bc ^ a) + blocks2[9] + 1859775393;
      d = d << 9 | d >>> 23;
      da = d ^ a;
      c += (da ^ b) + blocks2[5] + 1859775393;
      c = c << 11 | c >>> 21;
      b += (da ^ c) + blocks2[13] + 1859775393;
      b = b << 15 | b >>> 17;
      bc = b ^ c;
      a += (bc ^ d) + blocks2[3] + 1859775393;
      a = a << 3 | a >>> 29;
      d += (bc ^ a) + blocks2[11] + 1859775393;
      d = d << 9 | d >>> 23;
      da = d ^ a;
      c += (da ^ b) + blocks2[7] + 1859775393;
      c = c << 11 | c >>> 21;
      b += (da ^ c) + blocks2[15] + 1859775393;
      b = b << 15 | b >>> 17;
      if (this.first) {
        this.h0 = a + 1732584193 << 0;
        this.h1 = b - 271733879 << 0;
        this.h2 = c - 1732584194 << 0;
        this.h3 = d + 271733878 << 0;
        this.first = false;
      } else {
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
      }
    };
    Md4.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
      return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
    };
    Md4.prototype.toString = Md4.prototype.hex;
    Md4.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
      return [
        h0 & 255,
        h0 >> 8 & 255,
        h0 >> 16 & 255,
        h0 >> 24 & 255,
        h1 & 255,
        h1 >> 8 & 255,
        h1 >> 16 & 255,
        h1 >> 24 & 255,
        h2 & 255,
        h2 >> 8 & 255,
        h2 >> 16 & 255,
        h2 >> 24 & 255,
        h3 & 255,
        h3 >> 8 & 255,
        h3 >> 16 & 255,
        h3 >> 24 & 255
      ];
    };
    Md4.prototype.array = Md4.prototype.digest;
    Md4.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer3 = new ArrayBuffer(16);
      var blocks2 = new Uint32Array(buffer3);
      blocks2[0] = this.h0;
      blocks2[1] = this.h1;
      blocks2[2] = this.h2;
      blocks2[3] = this.h3;
      return buffer3;
    };
    Md4.prototype.buffer = Md4.prototype.arrayBuffer;
    var exports$1 = createMethod();
    if (COMMON_JS) {
      module2.exports = exports$1;
    } else {
      root.md4 = exports$1;
    }
  })();
})(md4);
var md4Exports = md4.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  var crypto2 = _interopRequireWildcard2(crypto$2);
  var _jsMd = _interopRequireDefault2(md4Exports);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj2, nodeInterop) {
    if (obj2 && obj2.__esModule) {
      return obj2;
    }
    if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
      return { default: obj2 };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj2)) {
      return cache.get(obj2);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj2) {
      if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj2, key2)) {
        var desc2 = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key2) : null;
        if (desc2 && (desc2.get || desc2.set)) {
          Object.defineProperty(newObj, key2, desc2);
        } else {
          newObj[key2] = obj2[key2];
        }
      }
    }
    newObj.default = obj2;
    if (cache) {
      cache.set(obj2, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  class NTLMResponsePayload {
    constructor(loginData) {
      this.data = void 0;
      this.data = this.createResponse(loginData);
    }
    toString(indent = "") {
      return indent + "NTLM Auth";
    }
    createResponse(challenge) {
      const client_nonce = this.createClientNonce();
      const lmv2len = 24;
      const ntlmv2len = 16;
      const domain = challenge.domain;
      const username = challenge.userName;
      const password = challenge.password;
      const ntlmData = challenge.ntlmpacket;
      const server_data = ntlmData.target;
      const server_nonce = ntlmData.nonce;
      const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
      const data = new _writableTrackingBuffer2.default(bufferLength);
      data.position = 0;
      data.writeString("NTLMSSP\0", "utf8");
      data.writeUInt32LE(3);
      const baseIdx = 64;
      const dnIdx = baseIdx;
      const unIdx = dnIdx + domain.length * 2;
      const l2Idx = unIdx + username.length * 2;
      const ntIdx = l2Idx + lmv2len;
      data.writeUInt16LE(lmv2len);
      data.writeUInt16LE(lmv2len);
      data.writeUInt32LE(l2Idx);
      data.writeUInt16LE(ntlmv2len);
      data.writeUInt16LE(ntlmv2len);
      data.writeUInt32LE(ntIdx);
      data.writeUInt16LE(domain.length * 2);
      data.writeUInt16LE(domain.length * 2);
      data.writeUInt32LE(dnIdx);
      data.writeUInt16LE(username.length * 2);
      data.writeUInt16LE(username.length * 2);
      data.writeUInt32LE(unIdx);
      data.writeUInt16LE(0);
      data.writeUInt16LE(0);
      data.writeUInt32LE(baseIdx);
      data.writeUInt16LE(0);
      data.writeUInt16LE(0);
      data.writeUInt32LE(baseIdx);
      data.writeUInt16LE(33281);
      data.writeUInt16LE(8);
      data.writeString(domain, "ucs2");
      data.writeString(username, "ucs2");
      const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
      data.copyFrom(lmv2Data);
      const genTime = (/* @__PURE__ */ new Date()).getTime();
      const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
      data.copyFrom(ntlmDataBuffer);
      data.writeUInt32LE(257);
      data.writeUInt32LE(0);
      const timestamp = this.createTimestamp(genTime);
      data.copyFrom(timestamp);
      data.copyFrom(client_nonce);
      data.writeUInt32LE(0);
      data.copyFrom(server_data);
      data.writeUInt32LE(0);
      return data.data;
    }
    createClientNonce() {
      const client_nonce = Buffer.alloc(8, 0);
      let nidx = 0;
      while (nidx < 8) {
        client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
        nidx++;
      }
      return client_nonce;
    }
    ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
      const timestamp = this.createTimestamp(mytime);
      const hash = this.ntv2Hash(domain, user, password);
      const dataLength = 40 + targetInfo.length;
      const data = Buffer.alloc(dataLength, 0);
      serverNonce.copy(data, 0, 0, 8);
      data.writeUInt32LE(257, 8);
      data.writeUInt32LE(0, 12);
      timestamp.copy(data, 16, 0, 8);
      clientNonce.copy(data, 24, 0, 8);
      data.writeUInt32LE(0, 32);
      targetInfo.copy(data, 36, 0, targetInfo.length);
      data.writeUInt32LE(0, 36 + targetInfo.length);
      return this.hmacMD5(data, hash);
    }
    createTimestamp(time2) {
      const tenthsOfAMicrosecond = (BigInt(time2) + BigInt(11644473600)) * BigInt(1e7);
      const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
      const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
      const result = Buffer.alloc(8);
      result.writeUInt32LE(lo, 0);
      result.writeUInt32LE(hi, 4);
      return result;
    }
    lmv2Response(domain, user, password, serverNonce, clientNonce) {
      const hash = this.ntv2Hash(domain, user, password);
      const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
      serverNonce.copy(data);
      clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
      const newhash = this.hmacMD5(data, hash);
      const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
      newhash.copy(response);
      clientNonce.copy(response, newhash.length, 0, clientNonce.length);
      return response;
    }
    ntv2Hash(domain, user, password) {
      const hash = this.ntHash(password);
      const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
      return this.hmacMD5(identity, hash);
    }
    ntHash(text2) {
      const unicodeString = Buffer.from(text2, "ucs2");
      return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
    }
    hmacMD5(data, key2) {
      return crypto2.createHmac("MD5", key2).update(data).digest();
    }
  }
  var _default2 = NTLMResponsePayload;
  exports$1.default = _default2;
  module2.exports = NTLMResponsePayload;
})(ntlmPayload, ntlmPayload.exports);
var ntlmPayloadExports = ntlmPayload.exports;
var request$1 = { exports: {} };
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", {
  value: true
});
errors$1.RequestError = errors$1.ConnectionError = void 0;
let ConnectionError$1 = class ConnectionError2 extends Error {
  constructor(message2, code) {
    super(message2);
    this.code = void 0;
    this.isTransient = void 0;
    this.code = code;
  }
};
errors$1.ConnectionError = ConnectionError$1;
let RequestError$1 = class RequestError2 extends Error {
  constructor(message2, code) {
    super(message2);
    this.code = void 0;
    this.number = void 0;
    this.state = void 0;
    this.class = void 0;
    this.serverName = void 0;
    this.procName = void 0;
    this.lineNumber = void 0;
    this.code = code;
  }
};
errors$1.RequestError = RequestError$1;
var types = {};
Object.defineProperty(types, "__esModule", {
  value: true
});
types.SQLServerStatementColumnEncryptionSetting = types.SQLServerEncryptionType = types.DescribeParameterEncryptionResultSet2 = types.DescribeParameterEncryptionResultSet1 = void 0;
let SQLServerEncryptionType;
types.SQLServerEncryptionType = SQLServerEncryptionType;
(function(SQLServerEncryptionType2) {
  SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
  SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
  SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
})(SQLServerEncryptionType || (types.SQLServerEncryptionType = SQLServerEncryptionType = {}));
let DescribeParameterEncryptionResultSet1;
types.DescribeParameterEncryptionResultSet1 = DescribeParameterEncryptionResultSet1;
(function(DescribeParameterEncryptionResultSet12) {
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
  DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
})(DescribeParameterEncryptionResultSet1 || (types.DescribeParameterEncryptionResultSet1 = DescribeParameterEncryptionResultSet1 = {}));
let DescribeParameterEncryptionResultSet2;
types.DescribeParameterEncryptionResultSet2 = DescribeParameterEncryptionResultSet2;
(function(DescribeParameterEncryptionResultSet22) {
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
  DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
})(DescribeParameterEncryptionResultSet2 || (types.DescribeParameterEncryptionResultSet2 = DescribeParameterEncryptionResultSet2 = {}));
let SQLServerStatementColumnEncryptionSetting;
types.SQLServerStatementColumnEncryptionSetting = SQLServerStatementColumnEncryptionSetting;
(function(SQLServerStatementColumnEncryptionSetting2) {
  SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
  SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
  SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
  SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
})(SQLServerStatementColumnEncryptionSetting || (types.SQLServerStatementColumnEncryptionSetting = SQLServerStatementColumnEncryptionSetting = {}));
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _events2 = require$$0$3;
  var _errors2 = errors$1;
  var _types = types;
  class Request3 extends _events2.EventEmitter {
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * This event, describing result set columns, will be emitted before row
     * events are emitted. This event may be emited multiple times when more
     * than one recordset is produced by the statement.
     *
     * An array like object, where the columns can be accessed either by index
     * or name. Columns with a name that is an integer are not accessible by name,
     * as it would be interpreted as an array index.
     */
    /**
     * The request has been prepared and can be used in subsequent calls to execute and unprepare.
     */
    /**
     * The request encountered an error and has not been prepared.
     */
    /**
     * A row resulting from execution of the SQL statement.
     */
    /**
     * All rows from a result set have been provided (through `row` events).
     *
     * This token is used to indicate the completion of a SQL statement.
     * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
     * An `done` event is emited for each SQL statement in the SQL batch except variable declarations.
     * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
     *
     * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
     * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
     */
    /**
     * `request.on('doneInProc', function (rowCount, more, rows) { });`
     *
     * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
     * in a stored procedure have been provided (through `row` events).
     *
     * This event may also occur when executing multiple calls with the same query using [[execSql]].
     */
    /**
     * Indicates the completion status of a stored procedure. This is also generated for stored procedures
     * executed through SQL statements.\
     * This event may also occur when executing multiple calls with the same query using [[execSql]].
     */
    /**
     * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
     * See also `Using Parameters`.
     */
    /**
     * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
     */
    on(event, listener) {
      return super.on(event, listener);
    }
    /**
     * @private
     */
    emit(event, ...args) {
      return super.emit(event, ...args);
    }
    /**
     * @param sqlTextOrProcedure
     *   The SQL statement to be executed
     *
     * @param callback
     *   The callback to execute once the request has been fully completed.
     */
    constructor(sqlTextOrProcedure, callback, options) {
      super();
      this.sqlTextOrProcedure = void 0;
      this.parameters = void 0;
      this.parametersByName = void 0;
      this.preparing = void 0;
      this.canceled = void 0;
      this.paused = void 0;
      this.userCallback = void 0;
      this.handle = void 0;
      this.error = void 0;
      this.connection = void 0;
      this.timeout = void 0;
      this.rows = void 0;
      this.rst = void 0;
      this.rowCount = void 0;
      this.callback = void 0;
      this.shouldHonorAE = void 0;
      this.statementColumnEncryptionSetting = void 0;
      this.cryptoMetadataLoaded = void 0;
      this.sqlTextOrProcedure = sqlTextOrProcedure;
      this.parameters = [];
      this.parametersByName = {};
      this.preparing = false;
      this.handle = void 0;
      this.canceled = false;
      this.paused = false;
      this.error = void 0;
      this.connection = void 0;
      this.timeout = void 0;
      this.userCallback = callback;
      this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
      this.cryptoMetadataLoaded = false;
      this.callback = function(err, rowCount, rows) {
        if (this.preparing) {
          this.preparing = false;
          if (err) {
            this.emit("error", err);
          } else {
            this.emit("prepared");
          }
        } else {
          this.userCallback(err, rowCount, rows);
          this.emit("requestCompleted");
        }
      };
    }
    /**
     * @param name
     *   The parameter name. This should correspond to a parameter in the SQL,
     *   or a parameter that a called procedure expects. The name should not start with `@`.
     *
     * @param type
     *   One of the supported data types.
     *
     * @param value
     *   The value that the parameter is to be given. The Javascript type of the
     *   argument should match that documented for data types.
     *
     * @param options
     *   Additional type options. Optional.
     */
    // TODO: `type` must be a valid TDS value type
    addParameter(name2, type2, value, options) {
      const {
        output = false,
        length,
        precision,
        scale
      } = options ?? {};
      const parameter = {
        type: type2,
        name: name2,
        value,
        output,
        length,
        precision,
        scale
      };
      this.parameters.push(parameter);
      this.parametersByName[name2] = parameter;
    }
    /**
     * @param name
     *   The parameter name. This should correspond to a parameter in the SQL,
     *   or a parameter that a called procedure expects.
     *
     * @param type
     *   One of the supported data types.
     *
     * @param value
     *   The value that the parameter is to be given. The Javascript type of the
     *   argument should match that documented for data types
     *
     * @param options
     *   Additional type options. Optional.
     */
    addOutputParameter(name2, type2, value, options) {
      this.addParameter(name2, type2, value, {
        ...options,
        output: true
      });
    }
    /**
     * @private
     */
    makeParamsParameter(parameters) {
      let paramsParameter = "";
      for (let i = 0, len = parameters.length; i < len; i++) {
        const parameter = parameters[i];
        if (paramsParameter.length > 0) {
          paramsParameter += ", ";
        }
        paramsParameter += "@" + parameter.name + " ";
        paramsParameter += parameter.type.declaration(parameter);
        if (parameter.output) {
          paramsParameter += " OUTPUT";
        }
      }
      return paramsParameter;
    }
    /**
     * @private
     */
    validateParameters(collation2) {
      for (let i = 0, len = this.parameters.length; i < len; i++) {
        const parameter = this.parameters[i];
        try {
          parameter.value = parameter.type.validate(parameter.value, collation2);
        } catch (error2) {
          throw new _errors2.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error2.message, "EPARAM");
        }
      }
    }
    /**
     * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
     * If this request is already in a paused state, calling [[pause]] has no effect.
     */
    pause() {
      if (this.paused) {
        return;
      }
      this.emit("pause");
      this.paused = true;
    }
    /**
     * Resumes the flow of data from the database.
     * If this request is not in a paused state, calling [[resume]] has no effect.
     */
    resume() {
      if (!this.paused) {
        return;
      }
      this.paused = false;
      this.emit("resume");
    }
    /**
     * Cancels a request while waiting for a server response.
     */
    cancel() {
      if (this.canceled) {
        return;
      }
      this.canceled = true;
      this.emit("cancel");
    }
    /**
     * Sets a timeout for this request.
     *
     * @param timeout
     *   The number of milliseconds before the request is considered failed,
     *   or `0` for no timeout. When no timeout is set for the request,
     *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
     */
    setTimeout(timeout2) {
      this.timeout = timeout2;
    }
  }
  var _default2 = Request3;
  exports$1.default = _default2;
  module2.exports = Request3;
})(request$1, request$1.exports);
var requestExports = request$1.exports;
var rpcrequestPayload = { exports: {} };
var allHeaders = {};
Object.defineProperty(allHeaders, "__esModule", {
  value: true
});
allHeaders.writeToTrackingBuffer = writeToTrackingBuffer;
const TYPE$1 = {
  TXN_DESCRIPTOR: 2
};
const TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
const TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
function writeToTrackingBuffer(buffer2, txnDescriptor, outstandingRequestCount) {
  buffer2.writeUInt32LE(0);
  buffer2.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
  buffer2.writeUInt16LE(TYPE$1.TXN_DESCRIPTOR);
  buffer2.writeBuffer(txnDescriptor);
  buffer2.writeUInt32LE(outstandingRequestCount);
  const data = buffer2.data;
  data.writeUInt32LE(data.length, 0);
  return buffer2;
}
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  var _allHeaders2 = allHeaders;
  let _Symbol$iterator;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const STATUS2 = {
    BY_REF_VALUE: 1
  };
  _Symbol$iterator = Symbol.iterator;
  class RpcRequestPayload {
    constructor(procedure, parameters, txnDescriptor, options, collation2) {
      this.procedure = void 0;
      this.parameters = void 0;
      this.options = void 0;
      this.txnDescriptor = void 0;
      this.collation = void 0;
      this.procedure = procedure;
      this.parameters = parameters;
      this.options = options;
      this.txnDescriptor = txnDescriptor;
      this.collation = collation2;
    }
    [_Symbol$iterator]() {
      return this.generateData();
    }
    *generateData() {
      const buffer2 = new _writableTrackingBuffer2.default(500);
      if (this.options.tdsVersion >= "7_2") {
        const outstandingRequestCount = 1;
        (0, _allHeaders2.writeToTrackingBuffer)(buffer2, this.txnDescriptor, outstandingRequestCount);
      }
      if (typeof this.procedure === "string") {
        buffer2.writeUsVarchar(this.procedure);
      } else {
        buffer2.writeUShort(65535);
        buffer2.writeUShort(this.procedure);
      }
      const optionFlags = 0;
      buffer2.writeUInt16LE(optionFlags);
      yield buffer2.data;
      const parametersLength = this.parameters.length;
      for (let i = 0; i < parametersLength; i++) {
        yield* this.generateParameterData(this.parameters[i]);
      }
    }
    toString(indent = "") {
      return indent + ("RPC Request - " + this.procedure);
    }
    *generateParameterData(parameter) {
      const buffer2 = new _writableTrackingBuffer2.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
      buffer2.writeBVarchar("@" + parameter.name);
      let statusFlags = 0;
      if (parameter.output) {
        statusFlags |= STATUS2.BY_REF_VALUE;
      }
      buffer2.writeUInt8(statusFlags);
      yield buffer2.data;
      const param = {
        value: parameter.value
      };
      const type2 = parameter.type;
      if ((type2.id & 48) === 32) {
        if (parameter.length) {
          param.length = parameter.length;
        } else if (type2.resolveLength) {
          param.length = type2.resolveLength(parameter);
        }
      }
      if (parameter.precision) {
        param.precision = parameter.precision;
      } else if (type2.resolvePrecision) {
        param.precision = type2.resolvePrecision(parameter);
      }
      if (parameter.scale) {
        param.scale = parameter.scale;
      } else if (type2.resolveScale) {
        param.scale = type2.resolveScale(parameter);
      }
      if (this.collation) {
        param.collation = this.collation;
      }
      yield type2.generateTypeInfo(param, this.options);
      yield type2.generateParameterLength(param, this.options);
      yield* type2.generateParameterData(param, this.options);
    }
  }
  var _default2 = RpcRequestPayload;
  exports$1.default = _default2;
  module2.exports = RpcRequestPayload;
})(rpcrequestPayload, rpcrequestPayload.exports);
var rpcrequestPayloadExports = rpcrequestPayload.exports;
var sqlbatchPayload = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  var _allHeaders2 = allHeaders;
  let _Symbol$iterator;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  _Symbol$iterator = Symbol.iterator;
  class SqlBatchPayload {
    constructor(sqlText, txnDescriptor, options) {
      this.sqlText = void 0;
      this.txnDescriptor = void 0;
      this.options = void 0;
      this.sqlText = sqlText;
      this.txnDescriptor = txnDescriptor;
      this.options = options;
    }
    *[_Symbol$iterator]() {
      if (this.options.tdsVersion >= "7_2") {
        const buffer2 = new _writableTrackingBuffer2.default(18, "ucs2");
        const outstandingRequestCount = 1;
        (0, _allHeaders2.writeToTrackingBuffer)(buffer2, this.txnDescriptor, outstandingRequestCount);
        yield buffer2.data;
      }
      yield Buffer.from(this.sqlText, "ucs2");
    }
    toString(indent = "") {
      return indent + ("SQL Batch - " + this.sqlText);
    }
  }
  var _default2 = SqlBatchPayload;
  exports$1.default = _default2;
  module2.exports = SqlBatchPayload;
})(sqlbatchPayload, sqlbatchPayload.exports);
var sqlbatchPayloadExports = sqlbatchPayload.exports;
var messageIo = { exports: {} };
const Duplex = require$$0$4.Duplex;
const kCallback = Symbol("Callback");
const kOtherSide = Symbol("Other");
class DuplexSocket extends Duplex {
  constructor(options) {
    super(options);
    this[kCallback] = null;
    this[kOtherSide] = null;
  }
  _read() {
    const callback = this[kCallback];
    if (callback) {
      this[kCallback] = null;
      callback();
    }
  }
  _write(chunk, encoding, callback) {
    this[kOtherSide][kCallback] = callback;
    this[kOtherSide].push(chunk);
  }
  _final(callback) {
    this[kOtherSide].on("end", callback);
    this[kOtherSide].push(null);
  }
}
class DuplexPair {
  constructor(options) {
    this.socket1 = new DuplexSocket(options);
    this.socket2 = new DuplexSocket(options);
    this.socket1[kOtherSide] = this.socket2;
    this.socket2[kOtherSide] = this.socket1;
  }
}
var nativeDuplexpair = DuplexPair;
var message = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _stream2 = require$$0$4;
  class Message extends _stream2.PassThrough {
    constructor({
      type: type2,
      resetConnection = false
    }) {
      super();
      this.type = void 0;
      this.resetConnection = void 0;
      this.ignore = void 0;
      this.type = type2;
      this.resetConnection = resetConnection;
      this.ignore = false;
    }
  }
  var _default2 = Message;
  exports$1.default = _default2;
  module2.exports = Message;
})(message, message.exports);
var messageExports = message.exports;
var incomingMessageStream = { exports: {} };
var bl = { exports: {} };
var readable = { exports: {} };
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  stream = require$$0$4;
  return stream;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys3 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$0$5, Buffer2 = _require.Buffer;
  var _require2 = require$$1$2, inspect2 = _require2.inspect;
  var custom2 = inspect2 && inspect2.custom || "inspect";
  function copyBuffer2(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer2(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume2(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom2,
      value: function value(_2, options) {
        return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy2(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err);
    else stream2.emit("error", err);
  }
  destroy_1 = {
    destroy: destroy2,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const codes = {};
  function createErrorType2(code, message2, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message2 === "string") {
        return message2;
      } else {
        return message2(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes2(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType2("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType2("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes2(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType2("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType2("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType2("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType2("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errors.codes = codes;
  return errors;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  var util = require("util");
  if (typeof util.inherits !== "function") throw "";
  inherits$1.exports = util.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}
var inheritsExports = inherits$1.exports;
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  node = require$$1$2.deprecate;
  return node;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream();
  var Buffer2 = require$$0$5.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  inheritsExports(Writable, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) process.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys2 = Object.keys || function(obj2) {
    var keys4 = [];
    for (var key2 in obj2) keys4.push(key2);
    return keys4;
  };
  _stream_duplex = Duplex2;
  var Readable2 = require_stream_readable();
  var Writable = require_stream_writable();
  inheritsExports(Duplex2, Readable2);
  {
    var keys3 = objectKeys2(Writable.prototype);
    for (var v = 0; v < keys3.length; v++) {
      var method = keys3[v];
      if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2)) return new Duplex2(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end3 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end3);
    return buf.toString("utf8", i, end3);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end3 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end3);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos(stream2, opts, callback) {
    if (typeof opts === "function") return eos(stream2, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop);
    var readable2 = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable) onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable2) callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable2 = false;
      readableEnded = true;
      if (!writable) callback.call(stream2);
    };
    var onerror = function onerror2(err) {
      callback.call(stream2, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable2 && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req) onrequest();
      else stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false) stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error2 = this[kError];
      if (error2 !== null) {
        return Promise.reject(error2);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var from_1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
    try {
      var info = gen[key2](arg);
      var value = info.value;
    } catch (error2) {
      reject(error2);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys3 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable2, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable2 = new Readable2(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable2._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable2.push(null);
          } else if (readable2.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable2.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable2;
  }
  from_1 = from;
  return from_1;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable2;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  require$$0$3.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = requireStream();
  var Buffer2 = require$$0$5.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var debugUtil = require$$1$2;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inheritsExports(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume2(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume2(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) ;
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFrom();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrors().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex2 = require_stream_duplex();
  inheritsExports(Transform, Duplex2);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex2.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex2.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex2.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  inheritsExports(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrors().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err) throw err;
  }
  function isRequest(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream2)) return stream2.abort();
      if (typeof stream2.destroy === "function") return stream2.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call2(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams2) {
    if (!streams2.length) return noop;
    if (typeof streams2[streams2.length - 1] !== "function") return noop;
    return streams2.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams2 = new Array(_len), _key = 0; _key < _len; _key++) {
      streams2[_key] = arguments[_key];
    }
    var callback = popCallback(streams2);
    if (Array.isArray(streams2[0])) streams2 = streams2[0];
    if (streams2.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error2;
    var destroys = streams2.map(function(stream2, i) {
      var reading = i < streams2.length - 1;
      var writing = i > 0;
      return destroyer(stream2, reading, writing, function(err) {
        if (!error2) error2 = err;
        if (err) destroys.forEach(call2);
        if (reading) return;
        destroys.forEach(call2);
        callback(error2);
      });
    });
    return streams2.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
(function(module2, exports$1) {
  var Stream2 = require$$0$4;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module2.exports = Stream2.Readable;
    Object.assign(module2.exports, Stream2);
    module2.exports.Stream = Stream2;
  } else {
    exports$1 = module2.exports = require_stream_readable();
    exports$1.Stream = Stream2 || exports$1;
    exports$1.Readable = exports$1;
    exports$1.Writable = require_stream_writable();
    exports$1.Duplex = require_stream_duplex();
    exports$1.Transform = require_stream_transform();
    exports$1.PassThrough = require_stream_passthrough();
    exports$1.finished = requireEndOfStream();
    exports$1.pipeline = requirePipeline();
  }
})(readable, readable.exports);
var readableExports = readable.exports;
const { Buffer: Buffer$2 } = require$$0$5;
const symbol = Symbol.for("BufferList");
function BufferList$1(buf) {
  if (!(this instanceof BufferList$1)) {
    return new BufferList$1(buf);
  }
  BufferList$1._init.call(this, buf);
}
BufferList$1._init = function _init(buf) {
  Object.defineProperty(this, symbol, { value: true });
  this._bufs = [];
  this.length = 0;
  if (buf) {
    this.append(buf);
  }
};
BufferList$1.prototype._new = function _new(buf) {
  return new BufferList$1(buf);
};
BufferList$1.prototype._offset = function _offset(offset) {
  if (offset === 0) {
    return [0, 0];
  }
  let tot = 0;
  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length;
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot];
    }
    tot = _t;
  }
};
BufferList$1.prototype._reverseOffset = function(blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];
  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length;
  }
  return offset;
};
BufferList$1.prototype.get = function get(index) {
  if (index > this.length || index < 0) {
    return void 0;
  }
  const offset = this._offset(index);
  return this._bufs[offset[0]][offset[1]];
};
BufferList$1.prototype.slice = function slice(start, end3) {
  if (typeof start === "number" && start < 0) {
    start += this.length;
  }
  if (typeof end3 === "number" && end3 < 0) {
    end3 += this.length;
  }
  return this.copy(null, 0, start, end3);
};
BufferList$1.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== "number" || srcStart < 0) {
    srcStart = 0;
  }
  if (typeof srcEnd !== "number" || srcEnd > this.length) {
    srcEnd = this.length;
  }
  if (srcStart >= this.length) {
    return dst || Buffer$2.alloc(0);
  }
  if (srcEnd <= 0) {
    return dst || Buffer$2.alloc(0);
  }
  const copy2 = !!dst;
  const off = this._offset(srcStart);
  const len = srcEnd - srcStart;
  let bytes = len;
  let bufoff = copy2 && dstStart || 0;
  let start = off[1];
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy2) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer$2.concat(this._bufs, this.length);
    }
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff);
      bufoff += this._bufs[i].length;
    }
    return dst;
  }
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  }
  if (!copy2) {
    dst = Buffer$2.allocUnsafe(len);
  }
  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start;
    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start);
      bufoff += l;
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes);
      bufoff += l;
      break;
    }
    bytes -= l;
    if (start) {
      start = 0;
    }
  }
  if (dst.length > bufoff) return dst.slice(0, bufoff);
  return dst;
};
BufferList$1.prototype.shallowSlice = function shallowSlice(start, end3) {
  start = start || 0;
  end3 = typeof end3 !== "number" ? this.length : end3;
  if (start < 0) {
    start += this.length;
  }
  if (end3 < 0) {
    end3 += this.length;
  }
  if (start === end3) {
    return this._new();
  }
  const startOffset = this._offset(start);
  const endOffset = this._offset(end3);
  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  if (endOffset[1] === 0) {
    buffers.pop();
  } else {
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
  }
  if (startOffset[1] !== 0) {
    buffers[0] = buffers[0].slice(startOffset[1]);
  }
  return this._new(buffers);
};
BufferList$1.prototype.toString = function toString3(encoding, start, end3) {
  return this.slice(start, end3).toString(encoding);
};
BufferList$1.prototype.consume = function consume(bytes) {
  bytes = Math.trunc(bytes);
  if (Number.isNaN(bytes) || bytes <= 0) return this;
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length;
      this.length -= this._bufs[0].length;
      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes);
      this.length -= bytes;
      break;
    }
  }
  return this;
};
BufferList$1.prototype.duplicate = function duplicate() {
  const copy2 = this._new();
  for (let i = 0; i < this._bufs.length; i++) {
    copy2.append(this._bufs[i]);
  }
  return copy2;
};
BufferList$1.prototype.append = function append(buf) {
  if (buf == null) {
    return this;
  }
  if (buf.buffer) {
    this._appendBuffer(Buffer$2.from(buf.buffer, buf.byteOffset, buf.byteLength));
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i]);
    }
  } else if (this._isBufferList(buf)) {
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i]);
    }
  } else {
    if (typeof buf === "number") {
      buf = buf.toString();
    }
    this._appendBuffer(Buffer$2.from(buf));
  }
  return this;
};
BufferList$1.prototype._appendBuffer = function appendBuffer(buf) {
  this._bufs.push(buf);
  this.length += buf.length;
};
BufferList$1.prototype.indexOf = function(search, offset, encoding) {
  if (encoding === void 0 && typeof offset === "string") {
    encoding = offset;
    offset = void 0;
  }
  if (typeof search === "function" || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  } else if (typeof search === "number") {
    search = Buffer$2.from([search]);
  } else if (typeof search === "string") {
    search = Buffer$2.from(search, encoding);
  } else if (this._isBufferList(search)) {
    search = search.slice();
  } else if (Array.isArray(search.buffer)) {
    search = Buffer$2.from(search.buffer, search.byteOffset, search.byteLength);
  } else if (!Buffer$2.isBuffer(search)) {
    search = Buffer$2.from(search);
  }
  offset = Number(offset || 0);
  if (isNaN(offset)) {
    offset = 0;
  }
  if (offset < 0) {
    offset = this.length + offset;
  }
  if (offset < 0) {
    offset = 0;
  }
  if (search.length === 0) {
    return offset > this.length ? this.length : offset;
  }
  const blOffset = this._offset(offset);
  let blIndex = blOffset[0];
  let buffOffset = blOffset[1];
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];
    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset;
      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult]);
        }
        buffOffset = buff.length - search.length + 1;
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);
        if (this._match(revOffset, search)) {
          return revOffset;
        }
        buffOffset++;
      }
    }
    buffOffset = 0;
  }
  return -1;
};
BufferList$1.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false;
  }
  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false;
    }
  }
  return true;
};
(function() {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };
  for (const m in methods) {
    (function(m2) {
      if (methods[m2] === null) {
        BufferList$1.prototype[m2] = function(offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m2](0, byteLength);
        };
      } else {
        BufferList$1.prototype[m2] = function(offset = 0) {
          return this.slice(offset, offset + methods[m2])[m2](0);
        };
      }
    })(m);
  }
})();
BufferList$1.prototype._isBufferList = function _isBufferList(b) {
  return b instanceof BufferList$1 || BufferList$1.isBufferList(b);
};
BufferList$1.isBufferList = function isBufferList(b) {
  return b != null && b[symbol];
};
var BufferList_1 = BufferList$1;
const DuplexStream = readableExports.Duplex;
const inherits = inheritsExports;
const BufferList = BufferList_1;
function BufferListStream(callback) {
  if (!(this instanceof BufferListStream)) {
    return new BufferListStream(callback);
  }
  if (typeof callback === "function") {
    this._callback = callback;
    const piper = (function piper2(err) {
      if (this._callback) {
        this._callback(err);
        this._callback = null;
      }
    }).bind(this);
    this.on("pipe", function onPipe(src2) {
      src2.on("error", piper);
    });
    this.on("unpipe", function onUnpipe(src2) {
      src2.removeListener("error", piper);
    });
    callback = null;
  }
  BufferList._init.call(this, callback);
  DuplexStream.call(this);
}
inherits(BufferListStream, DuplexStream);
Object.assign(BufferListStream.prototype, BufferList.prototype);
BufferListStream.prototype._new = function _new2(callback) {
  return new BufferListStream(callback);
};
BufferListStream.prototype._write = function _write(buf, encoding, callback) {
  this._appendBuffer(buf);
  if (typeof callback === "function") {
    callback();
  }
};
BufferListStream.prototype._read = function _read(size) {
  if (!this.length) {
    return this.push(null);
  }
  size = Math.min(size, this.length);
  this.push(this.slice(0, size));
  this.consume(size);
};
BufferListStream.prototype.end = function end2(chunk) {
  DuplexStream.prototype.end.call(this, chunk);
  if (this._callback) {
    this._callback(null, this.slice());
    this._callback = null;
  }
};
BufferListStream.prototype._destroy = function _destroy(err, cb) {
  this._bufs.length = 0;
  this.length = 0;
  cb(err);
};
BufferListStream.prototype._isBufferList = function _isBufferList2(b) {
  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
};
BufferListStream.isBufferList = BufferList.isBufferList;
bl.exports = BufferListStream;
bl.exports.BufferListStream = BufferListStream;
bl.exports.BufferList = BufferList;
var blExports = bl.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _bl = _interopRequireDefault2(blExports);
  var _stream2 = require$$0$4;
  var _message = _interopRequireDefault2(messageExports);
  var _packet = packet;
  var _errors2 = errors$1;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  class IncomingMessageStream extends _stream2.Transform {
    constructor(debug2) {
      super({
        readableObjectMode: true
      });
      this.debug = void 0;
      this.bl = void 0;
      this.currentMessage = void 0;
      this.debug = debug2;
      this.currentMessage = void 0;
      this.bl = new _bl.default();
    }
    pause() {
      super.pause();
      if (this.currentMessage) {
        this.currentMessage.pause();
      }
      return this;
    }
    resume() {
      super.resume();
      if (this.currentMessage) {
        this.currentMessage.resume();
      }
      return this;
    }
    processBufferedData(callback) {
      while (this.bl.length >= _packet.HEADER_LENGTH) {
        const length = this.bl.readUInt16BE(2);
        if (length < _packet.HEADER_LENGTH) {
          return callback(new _errors2.ConnectionError("Unable to process incoming packet"));
        }
        if (this.bl.length >= length) {
          const data = this.bl.slice(0, length);
          this.bl.consume(length);
          const packet2 = new _packet.Packet(data);
          this.debug.packet("Received", packet2);
          this.debug.data(packet2);
          let message2 = this.currentMessage;
          if (message2 === void 0) {
            this.currentMessage = message2 = new _message.default({
              type: packet2.type(),
              resetConnection: false
            });
            this.push(message2);
          }
          if (packet2.isLast()) {
            message2.once("end", () => {
              this.currentMessage = void 0;
              this.processBufferedData(callback);
            });
            message2.end(packet2.data());
            return;
          } else if (!message2.write(packet2.data())) {
            message2.once("drain", () => {
              this.processBufferedData(callback);
            });
            return;
          }
        } else {
          break;
        }
      }
      callback();
    }
    _transform(chunk, _encoding, callback) {
      this.bl.append(chunk);
      this.processBufferedData(callback);
    }
  }
  var _default2 = IncomingMessageStream;
  exports$1.default = _default2;
  module2.exports = IncomingMessageStream;
})(incomingMessageStream, incomingMessageStream.exports);
var incomingMessageStreamExports = incomingMessageStream.exports;
var outgoingMessageStream = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _bl = _interopRequireDefault2(blExports);
  var _stream2 = require$$0$4;
  var _packet = packet;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  class OutgoingMessageStream extends _stream2.Duplex {
    constructor(debug2, {
      packetSize
    }) {
      super({
        writableObjectMode: true
      });
      this.packetSize = void 0;
      this.debug = void 0;
      this.bl = void 0;
      this.currentMessage = void 0;
      this.packetSize = packetSize;
      this.debug = debug2;
      this.bl = new _bl.default();
      this.on("finish", () => {
        this.push(null);
      });
    }
    _write(message2, _encoding, callback) {
      const length = this.packetSize - _packet.HEADER_LENGTH;
      let packetNumber = 0;
      this.currentMessage = message2;
      this.currentMessage.on("data", (data) => {
        if (message2.ignore) {
          return;
        }
        this.bl.append(data);
        while (this.bl.length > length) {
          const data2 = this.bl.slice(0, length);
          this.bl.consume(length);
          const packet2 = new _packet.Packet(message2.type);
          packet2.packetId(packetNumber += 1);
          packet2.resetConnection(message2.resetConnection);
          packet2.addData(data2);
          this.debug.packet("Sent", packet2);
          this.debug.data(packet2);
          if (this.push(packet2.buffer) === false) {
            message2.pause();
          }
        }
      });
      this.currentMessage.on("end", () => {
        const data = this.bl.slice();
        this.bl.consume(data.length);
        const packet2 = new _packet.Packet(message2.type);
        packet2.packetId(packetNumber += 1);
        packet2.resetConnection(message2.resetConnection);
        packet2.last(true);
        packet2.ignore(message2.ignore);
        packet2.addData(data);
        this.debug.packet("Sent", packet2);
        this.debug.data(packet2);
        this.push(packet2.buffer);
        this.currentMessage = void 0;
        callback();
      });
    }
    _read(_size) {
      if (this.currentMessage) {
        this.currentMessage.resume();
      }
    }
  }
  var _default2 = OutgoingMessageStream;
  exports$1.default = _default2;
  module2.exports = OutgoingMessageStream;
})(outgoingMessageStream, outgoingMessageStream.exports);
var outgoingMessageStreamExports = outgoingMessageStream.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _nativeDuplexpair = _interopRequireDefault2(nativeDuplexpair);
  var tls2 = _interopRequireWildcard2(require$$1$3);
  var _events2 = require$$0$3;
  var _message = _interopRequireDefault2(messageExports);
  var _packet = packet;
  var _incomingMessageStream = _interopRequireDefault2(incomingMessageStreamExports);
  var _outgoingMessageStream = _interopRequireDefault2(outgoingMessageStreamExports);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj2, nodeInterop) {
    if (obj2 && obj2.__esModule) {
      return obj2;
    }
    if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
      return { default: obj2 };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj2)) {
      return cache.get(obj2);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj2) {
      if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj2, key2)) {
        var desc2 = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key2) : null;
        if (desc2 && (desc2.get || desc2.set)) {
          Object.defineProperty(newObj, key2, desc2);
        } else {
          newObj[key2] = obj2[key2];
        }
      }
    }
    newObj.default = obj2;
    if (cache) {
      cache.set(obj2, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  class MessageIO extends _events2.EventEmitter {
    constructor(socket, packetSize, debug2) {
      super();
      this.socket = void 0;
      this.debug = void 0;
      this.tlsNegotiationComplete = void 0;
      this.incomingMessageStream = void 0;
      this.outgoingMessageStream = void 0;
      this.securePair = void 0;
      this.incomingMessageIterator = void 0;
      this.socket = socket;
      this.debug = debug2;
      this.tlsNegotiationComplete = false;
      this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
      this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
      this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
        packetSize
      });
      this.socket.pipe(this.incomingMessageStream);
      this.outgoingMessageStream.pipe(this.socket);
    }
    packetSize(...args) {
      if (args.length > 0) {
        const packetSize = args[0];
        this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
        this.outgoingMessageStream.packetSize = packetSize;
      }
      if (this.securePair) {
        this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
      }
      return this.outgoingMessageStream.packetSize;
    }
    // Negotiate TLS encryption.
    startTls(credentialsDetails, hostname, trustServerCertificate) {
      if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
        credentialsDetails.maxVersion = "TLSv1.2";
      }
      const secureContext = tls2.createSecureContext(credentialsDetails);
      return new Promise((resolve, reject) => {
        const duplexpair = new _nativeDuplexpair.default();
        const securePair = this.securePair = {
          cleartext: tls2.connect({
            socket: duplexpair.socket1,
            servername: hostname,
            secureContext,
            rejectUnauthorized: !trustServerCertificate
          }),
          encrypted: duplexpair.socket2
        };
        const onSecureConnect = () => {
          securePair.encrypted.removeListener("readable", onReadable);
          securePair.cleartext.removeListener("error", onError);
          securePair.cleartext.removeListener("secureConnect", onSecureConnect);
          securePair.cleartext.once("error", (err) => {
            this.socket.destroy(err);
          });
          const cipher = securePair.cleartext.getCipher();
          if (cipher) {
            this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
          }
          this.emit("secure", securePair.cleartext);
          securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
          this.outgoingMessageStream.unpipe(this.socket);
          this.socket.unpipe(this.incomingMessageStream);
          this.socket.pipe(securePair.encrypted);
          securePair.encrypted.pipe(this.socket);
          securePair.cleartext.pipe(this.incomingMessageStream);
          this.outgoingMessageStream.pipe(securePair.cleartext);
          this.tlsNegotiationComplete = true;
          resolve();
        };
        const onError = (err) => {
          securePair.encrypted.removeListener("readable", onReadable);
          securePair.cleartext.removeListener("error", onError);
          securePair.cleartext.removeListener("secureConnect", onSecureConnect);
          securePair.cleartext.destroy();
          securePair.encrypted.destroy();
          reject(err);
        };
        const onReadable = () => {
          const message2 = new _message.default({
            type: _packet.TYPE.PRELOGIN,
            resetConnection: false
          });
          let chunk;
          while (chunk = securePair.encrypted.read()) {
            message2.write(chunk);
          }
          this.outgoingMessageStream.write(message2);
          message2.end();
          this.readMessage().then(async (response) => {
            securePair.encrypted.once("readable", onReadable);
            for await (const data of response) {
              securePair.encrypted.write(data);
            }
          }).catch(onError);
        };
        securePair.cleartext.once("error", onError);
        securePair.cleartext.once("secureConnect", onSecureConnect);
        securePair.encrypted.once("readable", onReadable);
      });
    }
    // TODO listen for 'drain' event when socket.write returns false.
    // TODO implement incomplete request cancelation (2.2.1.6)
    sendMessage(packetType, data, resetConnection) {
      const message2 = new _message.default({
        type: packetType,
        resetConnection
      });
      message2.end(data);
      this.outgoingMessageStream.write(message2);
      return message2;
    }
    /**
     * Read the next incoming message from the socket.
     */
    async readMessage() {
      const result = await this.incomingMessageIterator.next();
      if (result.done) {
        throw new Error("unexpected end of message stream");
      }
      return result.value;
    }
  }
  var _default2 = MessageIO;
  exports$1.default = _default2;
  module2.exports = MessageIO;
})(messageIo, messageIo.exports);
var messageIoExports = messageIo.exports;
var tokenStreamParser = {};
var streamParser = { exports: {} };
var colmetadataTokenParser = { exports: {} };
var metadataParser = { exports: {} };
var collation = {};
Object.defineProperty(collation, "__esModule", {
  value: true
});
collation.codepageBySortId = collation.codepageByLanguageId = collation.Flags = collation.Collation = void 0;
const codepageByLanguageId = {
  // Arabic_*
  [1025]: "CP1256",
  // Chinese_Taiwan_Stroke_*
  // Chinese_Traditional_Stroke_Count_*
  // Chinese_Taiwan_Bopomofo_*
  // Chinese_Traditional_Bopomofo_*
  [1028]: "CP950",
  // Czech_*
  [1029]: "CP1250",
  // Danish_Greenlandic_*
  // Danish_Norwegian_*
  [1030]: "CP1252",
  // Greek_*
  [1032]: "CP1253",
  // Latin1_General_*
  [1033]: "CP1252",
  // Traditional_Spanish_*
  [1034]: "CP1252",
  // Finnish_Swedish_*
  [1035]: "CP1252",
  // French_*
  [1036]: "CP1252",
  // Hebrew_*
  [1037]: "CP1255",
  // Hungarian_*
  // Hungarian_Technical_*
  [1038]: "CP1250",
  // Icelandic_*
  [1039]: "CP1252",
  // Japanese_*
  // Japanese_XJIS_*
  // Japanese_Unicode_*
  // Japanese_Bushu_Kakusu_*
  [1041]: "CP932",
  // Korean_*
  // Korean_Wansung_*
  [1042]: "CP949",
  // Norwegian_*
  [1044]: "CP1252",
  // Polish_*
  [1045]: "CP1250",
  // Romansh_*
  [1047]: "CP1252",
  // Romanian_*
  [1048]: "CP1250",
  // Cyrillic_*
  [1049]: "CP1251",
  // Croatian_*
  [1050]: "CP1250",
  // Slovak_*
  [1051]: "CP1250",
  // Albanian_*
  [1052]: "CP1250",
  // Thai_*
  [1054]: "CP874",
  // Turkish_*
  [1055]: "CP1254",
  // Urdu_*
  [1056]: "CP1256",
  // Ukrainian_*
  [1058]: "CP1251",
  // Slovenian_*
  [1060]: "CP1250",
  // Estonian_*
  [1061]: "CP1257",
  // Latvian_*
  [1062]: "CP1257",
  // Lithuanian_*
  [1063]: "CP1257",
  // Persian_*
  [1065]: "CP1256",
  // Vietnamese_*
  [1066]: "CP1258",
  // Azeri_Latin_*
  [1068]: "CP1254",
  // Upper_Sorbian_*
  [1070]: "CP1252",
  // Macedonian_FYROM_*
  [1071]: "CP1251",
  // Sami_Norway_*
  [1083]: "CP1252",
  // Kazakh_*
  [1087]: "CP1251",
  // Turkmen_*
  [1090]: "CP1250",
  // Uzbek_Latin_*
  [1091]: "CP1254",
  // Tatar_*
  [1092]: "CP1251",
  // Welsh_*
  [1106]: "CP1252",
  // Frisian_*
  [1122]: "CP1252",
  // Bashkir_*
  [1133]: "CP1251",
  // Mapudungan_*
  [1146]: "CP1252",
  // Mohawk_*
  [1148]: "CP1252",
  // Breton_*
  [1150]: "CP1252",
  // Uighur_*
  [1152]: "CP1256",
  // Corsican_*
  [1155]: "CP1252",
  // Yakut_*
  [1157]: "CP1251",
  // Dari_*
  [1164]: "CP1256",
  // Chinese_PRC_*
  // Chinese_Simplified_Pinyin_*
  // Chinese_PRC_Stroke_*
  // Chinese_Simplified_Stroke_Order_*
  [2052]: "CP936",
  // Serbian_Latin_*
  [2074]: "CP1250",
  // Azeri_Cyrillic_*
  [2092]: "CP1251",
  // Sami_Sweden_Finland_*
  [2107]: "CP1252",
  // Tamazight_*
  [2143]: "CP1252",
  // Chinese_Hong_Kong_Stroke_*
  [3076]: "CP950",
  // Modern_Spanish_*
  [3082]: "CP1252",
  // Serbian_Cyrillic_*
  [3098]: "CP1251",
  // Chinese_Traditional_Pinyin_*
  // Chinese_Traditional_Stroke_Order_*
  [5124]: "CP950",
  // Bosnian_Latin_*
  [5146]: "CP1250",
  // Bosnian_Cyrillic_*
  [8218]: "CP1251",
  // German
  // German_PhoneBook_*
  [1031]: "CP1252",
  // Georgian_Modern_Sort_*
  [1079]: "CP1252"
};
collation.codepageByLanguageId = codepageByLanguageId;
const codepageBySortId = {
  [30]: "CP437",
  // SQL_Latin1_General_CP437_BIN
  [31]: "CP437",
  // SQL_Latin1_General_CP437_CS_AS
  [32]: "CP437",
  // SQL_Latin1_General_CP437_CI_AS
  [33]: "CP437",
  // SQL_Latin1_General_Pref_CP437_CI_AS
  [34]: "CP437",
  // SQL_Latin1_General_CP437_CI_AI
  [40]: "CP850",
  // SQL_Latin1_General_CP850_BIN
  [41]: "CP850",
  // SQL_Latin1_General_CP850_CS_AS
  [42]: "CP850",
  // SQL_Latin1_General_CP850_CI_AS
  [43]: "CP850",
  // SQL_Latin1_General_Pref_CP850_CI_AS
  [44]: "CP850",
  // SQL_Latin1_General_CP850_CI_AI
  [49]: "CP850",
  // SQL_1xCompat_CP850_CI_AS
  [51]: "CP1252",
  // SQL_Latin1_General_Cp1_CS_AS_KI_WI
  [52]: "CP1252",
  // SQL_Latin1_General_Cp1_CI_AS_KI_WI
  [53]: "CP1252",
  // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
  [54]: "CP1252",
  // SQL_Latin1_General_Cp1_CI_AI_KI_WI
  [55]: "CP850",
  // SQL_AltDiction_CP850_CS_AS
  [56]: "CP850",
  // SQL_AltDiction_Pref_CP850_CI_AS
  [57]: "CP850",
  // SQL_AltDiction_CP850_CI_AI
  [58]: "CP850",
  // SQL_Scandinavian_Pref_CP850_CI_AS
  [59]: "CP850",
  // SQL_Scandinavian_CP850_CS_AS
  [60]: "CP850",
  // SQL_Scandinavian_CP850_CI_AS
  [61]: "CP850",
  // SQL_AltDiction_CP850_CI_AS
  [80]: "CP1250",
  // SQL_Latin1_General_1250_BIN
  [81]: "CP1250",
  // SQL_Latin1_General_CP1250_CS_AS
  [82]: "CP1250",
  // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
  [83]: "CP1250",
  // SQL_Czech_Cp1250_CS_AS_KI_WI
  [84]: "CP1250",
  // SQL_Czech_Cp1250_CI_AS_KI_WI
  [85]: "CP1250",
  // SQL_Hungarian_Cp1250_CS_AS_KI_WI
  [86]: "CP1250",
  // SQL_Hungarian_Cp1250_CI_AS_KI_WI
  [87]: "CP1250",
  // SQL_Polish_Cp1250_CS_AS_KI_WI
  [88]: "CP1250",
  // SQL_Polish_Cp1250_CI_AS_KI_WI
  [89]: "CP1250",
  // SQL_Romanian_Cp1250_CS_AS_KI_WI
  [90]: "CP1250",
  // SQL_Romanian_Cp1250_CI_AS_KI_WI
  [91]: "CP1250",
  // SQL_Croatian_Cp1250_CS_AS_KI_WI
  [92]: "CP1250",
  // SQL_Croatian_Cp1250_CI_AS_KI_WI
  [93]: "CP1250",
  // SQL_Slovak_Cp1250_CS_AS_KI_WI
  [94]: "CP1250",
  // SQL_Slovak_Cp1250_CI_AS_KI_WI
  [95]: "CP1250",
  // SQL_Slovenian_Cp1250_CS_AS_KI_WI
  [96]: "CP1250",
  // SQL_Slovenian_Cp1250_CI_AS_KI_WI
  [104]: "CP1251",
  // SQL_Latin1_General_1251_BIN
  [105]: "CP1251",
  // SQL_Latin1_General_CP1251_CS_AS
  [106]: "CP1251",
  // SQL_Latin1_General_CP1251_CI_AS
  [107]: "CP1251",
  // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
  [108]: "CP1251",
  // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
  [112]: "CP1253",
  // SQL_Latin1_General_1253_BIN
  [113]: "CP1253",
  // SQL_Latin1_General_CP1253_CS_AS
  [114]: "CP1253",
  // SQL_Latin1_General_CP1253_CI_AS
  [120]: "CP1253",
  // SQL_MixDiction_CP1253_CS_AS
  [121]: "CP1253",
  // SQL_AltDiction_CP1253_CS_AS
  [122]: "CP1253",
  // SQL_AltDiction2_CP1253_CS_AS
  [124]: "CP1253",
  // SQL_Latin1_General_CP1253_CI_AI
  [128]: "CP1254",
  // SQL_Latin1_General_1254_BIN
  [129]: "CP1254",
  // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
  [130]: "CP1254",
  // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
  [136]: "CP1255",
  // SQL_Latin1_General_1255_BIN
  [137]: "CP1255",
  // SQL_Latin1_General_CP1255_CS_AS
  [138]: "CP1255",
  // SQL_Latin1_General_CP1255_CI_AS
  [144]: "CP1256",
  // SQL_Latin1_General_1256_BIN
  [145]: "CP1256",
  // SQL_Latin1_General_CP1256_CS_AS
  [146]: "CP1256",
  // SQL_Latin1_General_CP1256_CI_AS
  [152]: "CP1257",
  // SQL_Latin1_General_1257_BIN
  [153]: "CP1257",
  // SQL_Latin1_General_CP1257_CS_AS
  [154]: "CP1257",
  // SQL_Latin1_General_CP1257_CI_AS
  [155]: "CP1257",
  // SQL_Estonian_Cp1257_CS_AS_KI_WI
  [156]: "CP1257",
  // SQL_Estonian_Cp1257_CI_AS_KI_WI
  [157]: "CP1257",
  // SQL_Latvian_Cp1257_CS_AS_KI_WI
  [158]: "CP1257",
  // SQL_Latvian_Cp1257_CI_AS_KI_WI
  [159]: "CP1257",
  // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
  [160]: "CP1257",
  // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
  [183]: "CP1252",
  // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
  [184]: "CP1252",
  // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
  [185]: "CP1252",
  // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
  [186]: "CP1252"
  // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
};
collation.codepageBySortId = codepageBySortId;
const Flags = {
  IGNORE_CASE: 1 << 0,
  IGNORE_ACCENT: 1 << 1,
  IGNORE_KANA: 1 << 2,
  IGNORE_WIDTH: 1 << 3,
  BINARY: 1 << 4,
  BINARY2: 1 << 5,
  UTF8: 1 << 6
};
collation.Flags = Flags;
class Collation {
  static fromBuffer(buffer2, offset = 0) {
    let lcid = (buffer2[offset + 2] & 15) << 16;
    lcid |= buffer2[offset + 1] << 8;
    lcid |= buffer2[offset + 0];
    let flags = (buffer2[offset + 3] & 15) << 4;
    flags |= (buffer2[offset + 2] & 240) >>> 4;
    const version2 = (buffer2[offset + 3] & 240) >>> 4;
    const sortId = buffer2[offset + 4];
    return new this(lcid, flags, version2, sortId);
  }
  constructor(lcid, flags, version2, sortId) {
    this.lcid = void 0;
    this.flags = void 0;
    this.version = void 0;
    this.sortId = void 0;
    this.codepage = void 0;
    this.buffer = void 0;
    this.buffer = void 0;
    this.lcid = lcid;
    this.flags = flags;
    this.version = version2;
    this.sortId = sortId;
    if (this.flags & Flags.UTF8) {
      this.codepage = "utf-8";
    } else if (this.sortId) {
      this.codepage = codepageBySortId[this.sortId];
    } else {
      const languageId = this.lcid & 65535;
      this.codepage = codepageByLanguageId[languageId];
    }
  }
  toBuffer() {
    if (this.buffer) {
      return this.buffer;
    }
    this.buffer = Buffer.alloc(5);
    this.buffer[0] = this.lcid & 255;
    this.buffer[1] = this.lcid >>> 8 & 255;
    this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
    this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
    this.buffer[4] = this.sortId & 255;
    return this.buffer;
  }
}
collation.Collation = Collation;
var dataType = {};
var _null$1 = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const Null = {
    id: 31,
    type: "NULL",
    name: "Null",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = Null;
  exports$1.default = _default2;
  module2.exports = Null;
})(_null$1, _null$1.exports);
var _nullExports = _null$1.exports;
var tinyint = { exports: {} };
var intn = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const IntN = {
    id: 38,
    type: "INTN",
    name: "IntN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = IntN;
  exports$1.default = _default2;
  module2.exports = IntN;
})(intn, intn.exports);
var intnExports = intn.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _intn2 = _interopRequireDefault2(intnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const DATA_LENGTH = Buffer.from([1]);
  const NULL_LENGTH = Buffer.from([0]);
  const TinyInt = {
    id: 48,
    type: "INT1",
    name: "TinyInt",
    declaration: function() {
      return "tinyint";
    },
    generateTypeInfo() {
      return Buffer.from([_intn2.default.id, 1]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(1);
      buffer2.writeUInt8(Number(parameter.value), 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "number") {
        value = Number(value);
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      if (value < 0 || value > 255) {
        throw new TypeError("Value must be between 0 and 255, inclusive.");
      }
      return value | 0;
    }
  };
  var _default2 = TinyInt;
  exports$1.default = _default2;
  module2.exports = TinyInt;
})(tinyint, tinyint.exports);
var tinyintExports = tinyint.exports;
var bit = { exports: {} };
var bitn = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const BitN = {
    id: 104,
    type: "BITN",
    name: "BitN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    *generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = BitN;
  exports$1.default = _default2;
  module2.exports = BitN;
})(bitn, bitn.exports);
var bitnExports = bitn.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _bitn2 = _interopRequireDefault2(bitnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const DATA_LENGTH = Buffer.from([1]);
  const NULL_LENGTH = Buffer.from([0]);
  const Bit = {
    id: 50,
    type: "BIT",
    name: "Bit",
    declaration: function() {
      return "bit";
    },
    generateTypeInfo() {
      return Buffer.from([_bitn2.default.id, 1]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (value) {
        return true;
      } else {
        return false;
      }
    }
  };
  var _default2 = Bit;
  exports$1.default = _default2;
  module2.exports = Bit;
})(bit, bit.exports);
var bitExports = bit.exports;
var smallint = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _intn2 = _interopRequireDefault2(intnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const DATA_LENGTH = Buffer.from([2]);
  const NULL_LENGTH = Buffer.from([0]);
  const SmallInt = {
    id: 52,
    type: "INT2",
    name: "SmallInt",
    declaration: function() {
      return "smallint";
    },
    generateTypeInfo() {
      return Buffer.from([_intn2.default.id, 2]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(2);
      buffer2.writeInt16LE(Number(parameter.value), 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "number") {
        value = Number(value);
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      if (value < -32768 || value > 32767) {
        throw new TypeError("Value must be between -32768 and 32767, inclusive.");
      }
      return value | 0;
    }
  };
  var _default2 = SmallInt;
  exports$1.default = _default2;
  module2.exports = SmallInt;
})(smallint, smallint.exports);
var smallintExports = smallint.exports;
var int = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _intn2 = _interopRequireDefault2(intnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([4]);
  const Int = {
    id: 56,
    type: "INT4",
    name: "Int",
    declaration: function() {
      return "int";
    },
    generateTypeInfo() {
      return Buffer.from([_intn2.default.id, 4]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeInt32LE(Number(parameter.value), 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "number") {
        value = Number(value);
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      if (value < -2147483648 || value > 2147483647) {
        throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
      }
      return value | 0;
    }
  };
  var _default2 = Int;
  exports$1.default = _default2;
  module2.exports = Int;
})(int, int.exports);
var intExports = int.exports;
var smalldatetime = { exports: {} };
var datetimen = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const DateTimeN = {
    id: 111,
    type: "DATETIMN",
    name: "DateTimeN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = DateTimeN;
  exports$1.default = _default2;
  module2.exports = DateTimeN;
})(datetimen, datetimen.exports);
var datetimenExports = datetimen.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _datetimen2 = _interopRequireDefault2(datetimenExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const EPOCH_DATE = new Date(1900, 0, 1);
  const UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
  const DATA_LENGTH = Buffer.from([4]);
  const NULL_LENGTH = Buffer.from([0]);
  const SmallDateTime = {
    id: 58,
    type: "DATETIM4",
    name: "SmallDateTime",
    declaration: function() {
      return "smalldatetime";
    },
    generateTypeInfo() {
      return Buffer.from([_datetimen2.default.id, 4]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    generateParameterData: function* (parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(4);
      let days, dstDiff, minutes;
      if (options.useUTC) {
        days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
        minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
      } else {
        dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
        days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
        minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
      }
      buffer2.writeUInt16LE(days, 0);
      buffer2.writeUInt16LE(minutes, 2);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof Date)) {
        value = new Date(Date.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid date.");
      }
      return value;
    }
  };
  var _default2 = SmallDateTime;
  exports$1.default = _default2;
  module2.exports = SmallDateTime;
})(smalldatetime, smalldatetime.exports);
var smalldatetimeExports = smalldatetime.exports;
var real = { exports: {} };
var floatn = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const FloatN = {
    id: 109,
    type: "FLTN",
    name: "FloatN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = FloatN;
  exports$1.default = _default2;
  module2.exports = FloatN;
})(floatn, floatn.exports);
var floatnExports = floatn.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _floatn2 = _interopRequireDefault2(floatnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([4]);
  const Real = {
    id: 59,
    type: "FLT4",
    name: "Real",
    declaration: function() {
      return "real";
    },
    generateTypeInfo() {
      return Buffer.from([_floatn2.default.id, 4]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeFloatLE(parseFloat(parameter.value), 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      return value;
    }
  };
  var _default2 = Real;
  exports$1.default = _default2;
  module2.exports = Real;
})(real, real.exports);
var realExports = real.exports;
var money = { exports: {} };
var moneyn = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const MoneyN = {
    id: 110,
    type: "MONEYN",
    name: "MoneyN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = MoneyN;
  exports$1.default = _default2;
  module2.exports = MoneyN;
})(moneyn, moneyn.exports);
var moneynExports = moneyn.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _moneyn2 = _interopRequireDefault2(moneynExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
  const SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([8]);
  const Money = {
    id: 60,
    type: "MONEY",
    name: "Money",
    declaration: function() {
      return "money";
    },
    generateTypeInfo: function() {
      return Buffer.from([_moneyn2.default.id, 8]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value * 1e4;
      const buffer2 = Buffer.alloc(8);
      buffer2.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
      buffer2.writeInt32LE(value & -1, 4);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      return value;
    }
  };
  var _default2 = Money;
  exports$1.default = _default2;
  module2.exports = Money;
})(money, money.exports);
var moneyExports = money.exports;
var datetime = { exports: {} };
//! @version @js-joda/core - 5.6.5
//! @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function createErrorType(name2, init2, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message2) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message2;
    init2 && init2.apply(this, arguments);
    this.toString = function() {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name2;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
var DateTimeException = createErrorType("DateTimeException", messageWithCause);
var DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
var UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
var ArithmeticException = createErrorType("ArithmeticException");
var IllegalArgumentException = createErrorType("IllegalArgumentException");
var IllegalStateException = createErrorType("IllegalStateException");
var NullPointerException = createErrorType("NullPointerException");
function messageWithCause(message2, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message2 || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message2, text2, index, cause) {
  if (text2 === void 0) {
    text2 = "";
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message2 || this.name;
  msg += ": " + text2 + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function() {
    return text2;
  };
  this.errorIndex = function() {
    return index;
  };
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function assert(assertion, msg, error2) {
  if (!assertion) {
    if (error2) {
      throw new error2(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError('abstract method "' + methodName + '" is not implemented');
}
var assert$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abstractMethodFail,
  assert,
  requireInstance,
  requireNonNull
});
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_SAFE_INTEGER = 9007199254740991;
var MIN_SAFE_INTEGER = -9007199254740991;
var MathUtil = function() {
  function MathUtil2() {
  }
  MathUtil2.intDiv = function intDiv(x, y) {
    var r = x / y;
    r = MathUtil2.roundDown(r);
    return MathUtil2.safeZero(r);
  };
  MathUtil2.intMod = function intMod(x, y) {
    var r = x - MathUtil2.intDiv(x, y) * y;
    r = MathUtil2.roundDown(r);
    return MathUtil2.safeZero(r);
  };
  MathUtil2.roundDown = function roundDown(r) {
    if (r < 0) {
      return Math.ceil(r);
    } else {
      return Math.floor(r);
    }
  };
  MathUtil2.floorDiv = function floorDiv(x, y) {
    var r = Math.floor(x / y);
    return MathUtil2.safeZero(r);
  };
  MathUtil2.floorMod = function floorMod(x, y) {
    var r = x - MathUtil2.floorDiv(x, y) * y;
    return MathUtil2.safeZero(r);
  };
  MathUtil2.safeAdd = function safeAdd(x, y) {
    MathUtil2.verifyInt(x);
    MathUtil2.verifyInt(y);
    if (x === 0) {
      return MathUtil2.safeZero(y);
    }
    if (y === 0) {
      return MathUtil2.safeZero(x);
    }
    var r = MathUtil2.safeToInt(x + y);
    if (r === x || r === y) {
      throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
    }
    return r;
  };
  MathUtil2.safeSubtract = function safeSubtract(x, y) {
    MathUtil2.verifyInt(x);
    MathUtil2.verifyInt(y);
    if (x === 0 && y === 0) {
      return 0;
    } else if (x === 0) {
      return MathUtil2.safeZero(-1 * y);
    } else if (y === 0) {
      return MathUtil2.safeZero(x);
    }
    return MathUtil2.safeToInt(x - y);
  };
  MathUtil2.safeMultiply = function safeMultiply(x, y) {
    MathUtil2.verifyInt(x);
    MathUtil2.verifyInt(y);
    if (x === 1) {
      return MathUtil2.safeZero(y);
    }
    if (y === 1) {
      return MathUtil2.safeZero(x);
    }
    if (x === 0 || y === 0) {
      return 0;
    }
    var r = MathUtil2.safeToInt(x * y);
    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
      throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
    }
    return r;
  };
  MathUtil2.parseInt = function(_parseInt) {
    function parseInt2(_x) {
      return _parseInt.apply(this, arguments);
    }
    parseInt2.toString = function() {
      return _parseInt.toString();
    };
    return parseInt2;
  }(function(value) {
    var r = parseInt(value);
    return MathUtil2.safeToInt(r);
  });
  MathUtil2.safeToInt = function safeToInt(value) {
    MathUtil2.verifyInt(value);
    return MathUtil2.safeZero(value);
  };
  MathUtil2.verifyInt = function verifyInt(value) {
    if (value == null) {
      throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
    }
    if (isNaN(value)) {
      throw new ArithmeticException("Invalid int value, using NaN as argument");
    }
    if (Number.isInteger) {
      if (!Number.isInteger(Number(value))) {
        throw new ArithmeticException("Invalid value: '" + value + "' is a float");
      }
    } else if (value % 1 !== 0) {
      throw new ArithmeticException("Invalid value: '" + value + "' is a float");
    }
    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
      throw new ArithmeticException("Calculation overflows an int: " + value);
    }
  };
  MathUtil2.safeZero = function safeZero(value) {
    return value === 0 ? 0 : +value;
  };
  MathUtil2.compareNumbers = function compareNumbers(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  };
  MathUtil2.smi = function smi(int2) {
    return int2 >>> 1 & 1073741824 | int2 & 3221225471;
  };
  MathUtil2.hash = function hash(number) {
    if (number !== number || number === Infinity) {
      return 0;
    }
    var result = number;
    while (number > 4294967295) {
      number /= 4294967295;
      result ^= number;
    }
    return MathUtil2.smi(result);
  };
  MathUtil2.hashCode = function hashCode() {
    var result = 17;
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
      var n = _numbers[_i];
      result = (result << 5) - result + MathUtil2.hash(n);
    }
    return MathUtil2.hash(result);
  };
  return MathUtil2;
}();
MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var Enum = function() {
  function Enum2(name2) {
    this._name = name2;
  }
  var _proto = Enum2.prototype;
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString4() {
    return this._name;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Enum2;
}();
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAmount = function() {
  function TemporalAmount2() {
  }
  var _proto = TemporalAmount2.prototype;
  _proto.get = function get3(unit) {
    abstractMethodFail("get");
  };
  _proto.units = function units() {
    abstractMethodFail("units");
  };
  _proto.addTo = function addTo(temporal) {
    abstractMethodFail("addTo");
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    abstractMethodFail("subtractFrom");
  };
  return TemporalAmount2;
}();
if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
  TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
    if (hint !== "number") {
      return this.toString();
    }
    throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
  };
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalUnit = function() {
  function TemporalUnit2() {
  }
  var _proto = TemporalUnit2.prototype;
  _proto.duration = function duration2() {
    abstractMethodFail("duration");
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    abstractMethodFail("isDurationEstimated");
  };
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail("isDateBased");
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail("isTimeBased");
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail("isSupportedBy");
  };
  _proto.addTo = function addTo(dateTime, periodToAdd) {
    abstractMethodFail("addTo");
  };
  _proto.between = function between(temporal1, temporal2) {
    abstractMethodFail("between");
  };
  return TemporalUnit2;
}();
var Duration = function(_TemporalAmount) {
  _inheritsLoose(Duration2, _TemporalAmount);
  function Duration2(seconds, nanos) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanos);
    return _this;
  }
  Duration2.ofDays = function ofDays(days) {
    return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
  };
  Duration2.ofHours = function ofHours(hours) {
    return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
  };
  Duration2.ofMinutes = function ofMinutes(minutes) {
    return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Duration2._create(secs, nos);
  };
  Duration2.ofMillis = function ofMillis(millis) {
    var secs = MathUtil.intDiv(millis, 1e3);
    var mos = MathUtil.intMod(millis, 1e3);
    if (mos < 0) {
      mos += 1e3;
      secs--;
    }
    return Duration2._create(secs, mos * 1e6);
  };
  Duration2.ofNanos = function ofNanos(nanos) {
    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
    if (nos < 0) {
      nos += LocalTime.NANOS_PER_SECOND;
      secs--;
    }
    return this._create(secs, nos);
  };
  Duration2.of = function of(amount, unit) {
    return Duration2.ZERO.plus(amount, unit);
  };
  Duration2.from = function from(amount) {
    requireNonNull(amount, "amount");
    requireInstance(amount, TemporalAmount);
    var duration2 = Duration2.ZERO;
    amount.units().forEach(function(unit) {
      duration2 = duration2.plus(amount.get(unit), unit);
    });
    return duration2;
  };
  Duration2.between = function between(startInclusive, endExclusive) {
    requireNonNull(startInclusive, "startInclusive");
    requireNonNull(endExclusive, "endExclusive");
    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
    var nanos = 0;
    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
      try {
        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
        if (secs > 0 && nanos < 0) {
          nanos += LocalTime.NANOS_PER_SECOND;
        } else if (secs < 0 && nanos > 0) {
          nanos -= LocalTime.NANOS_PER_SECOND;
        } else if (secs === 0 && nanos !== 0) {
          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
        }
      } catch (e) {
      }
    }
    return this.ofSeconds(secs, nanos);
  };
  Duration2.parse = function parse2(text2) {
    requireNonNull(text2, "text");
    var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
    var matches = PATTERN2.exec(text2);
    if (matches !== null) {
      if ("T" === matches[3] === false) {
        var negate = "-" === matches[1];
        var dayMatch = matches[2];
        var hourMatch = matches[4];
        var minuteMatch = matches[5];
        var secondMatch = matches[6];
        var fractionMatch = matches[7];
        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
          var daysAsSecs = Duration2._parseNumber(text2, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
          var hoursAsSecs = Duration2._parseNumber(text2, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
          var minsAsSecs = Duration2._parseNumber(text2, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
          var seconds = Duration2._parseNumber(text2, secondMatch, 1, "seconds");
          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
          var nanos = Duration2._parseFraction(text2, fractionMatch, negativeSecs ? -1 : 1);
          try {
            return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
          } catch (ex) {
            throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text2, 0, ex);
          }
        }
      }
    }
    throw new DateTimeParseException("Text cannot be parsed to a Duration", text2, 0);
  };
  Duration2._parseNumber = function _parseNumber(text2, parsed, multiplier, errorText) {
    if (parsed == null) {
      return 0;
    }
    try {
      if (parsed[0] === "+") {
        parsed = parsed.substring(1);
      }
      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
    } catch (ex) {
      throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text2, 0, ex);
    }
  };
  Duration2._parseFraction = function _parseFraction(text2, parsed, negate) {
    if (parsed == null || parsed.length === 0) {
      return 0;
    }
    parsed = (parsed + "000000000").substring(0, 9);
    return parseFloat(parsed) * negate;
  };
  Duration2._create = function _create() {
    if (arguments.length <= 2) {
      return Duration2._createSecondsNanos(arguments[0], arguments[1]);
    } else {
      return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
    }
  };
  Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
    if (negate) {
      return Duration2.ofSeconds(seconds, nanos).negated();
    }
    return Duration2.ofSeconds(seconds, nanos);
  };
  Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
    if (seconds === void 0) {
      seconds = 0;
    }
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    if (seconds === 0 && nanoAdjustment === 0) {
      return Duration2.ZERO;
    }
    return new Duration2(seconds, nanoAdjustment);
  };
  var _proto = Duration2.prototype;
  _proto.get = function get3(unit) {
    if (unit === ChronoUnit.SECONDS) {
      return this._seconds;
    } else if (unit === ChronoUnit.NANOS) {
      return this._nanos;
    } else {
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
  };
  _proto.units = function units() {
    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
  };
  _proto.isZero = function isZero() {
    return this._seconds === 0 && this._nanos === 0;
  };
  _proto.isNegative = function isNegative() {
    return this._seconds < 0;
  };
  _proto.seconds = function seconds() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto.withSeconds = function withSeconds(seconds) {
    return Duration2._create(seconds, this._nanos);
  };
  _proto.withNanos = function withNanos(nanoOfSecond) {
    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
    return Duration2._create(this._seconds, nanoOfSecond);
  };
  _proto.plusDuration = function plusDuration(duration2) {
    requireNonNull(duration2, "duration");
    return this.plus(duration2.seconds(), duration2.nano());
  };
  _proto.plus = function plus(durationOrNumber, unitOrNumber) {
    if (arguments.length === 1) {
      return this.plusDuration(durationOrNumber);
    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
      return this.plusAmountUnit(durationOrNumber, unitOrNumber);
    } else {
      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
    }
  };
  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, "amountToAdd");
    requireNonNull(unit, "unit");
    if (unit === ChronoUnit.DAYS) {
      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
    }
    if (unit.isDurationEstimated()) {
      throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
    }
    if (amountToAdd === 0) {
      return this;
    }
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
      }
      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
    }
    var duration2 = unit.duration().multipliedBy(amountToAdd);
    return this.plusSecondsNanos(duration2.seconds(), duration2.nano());
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this.plusSecondsNanos(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this.plusSecondsNanos(0, nanosToAdd);
  };
  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
    requireNonNull(secondsToAdd, "secondsToAdd");
    requireNonNull(nanosToAdd, "nanosToAdd");
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
    return Duration2.ofSeconds(epochSec, nanoAdjustment);
  };
  _proto.minus = function minus(durationOrNumber, unit) {
    if (arguments.length === 1) {
      return this.minusDuration(durationOrNumber);
    } else {
      return this.minusAmountUnit(durationOrNumber, unit);
    }
  };
  _proto.minusDuration = function minusDuration(duration2) {
    requireNonNull(duration2, "duration");
    var secsToSubtract = duration2.seconds();
    var nanosToSubtract = duration2.nano();
    if (secsToSubtract === MIN_SAFE_INTEGER) {
      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
    }
    return this.plus(-secsToSubtract, -nanosToSubtract);
  };
  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, "amountToSubtract");
    requireNonNull(unit, "unit");
    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(multiplicand) {
    if (multiplicand === 0) {
      return Duration2.ZERO;
    }
    if (multiplicand === 1) {
      return this;
    }
    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
    return Duration2.ofSeconds(secs, nos);
  };
  _proto.dividedBy = function dividedBy(divisor) {
    if (divisor === 0) {
      throw new ArithmeticException("Cannot divide by zero");
    }
    if (divisor === 1) {
      return this;
    }
    var secs = MathUtil.intDiv(this._seconds, divisor);
    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intDiv(this._nanos, divisor);
    nos = secsMod + nos;
    return Duration2.ofSeconds(secs, nos);
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.abs = function abs2() {
    return this.isNegative() ? this.negated() : this;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, "temporal");
    if (this._seconds !== 0) {
      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, "temporal");
    if (this._seconds !== 0) {
      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.toDays = function toDays() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
  };
  _proto.toHours = function toHours() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
  };
  _proto.toMinutes = function toMinutes() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
  };
  _proto.toMillis = function toMillis() {
    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
    return millis;
  };
  _proto.toNanos = function toNanos() {
    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
    return totalNanos;
  };
  _proto.compareTo = function compareTo(otherDuration) {
    requireNonNull(otherDuration, "otherDuration");
    requireInstance(otherDuration, Duration2, "otherDuration");
    var cmp2 = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
    if (cmp2 !== 0) {
      return cmp2;
    }
    return this._nanos - otherDuration.nano();
  };
  _proto.equals = function equals(otherDuration) {
    if (this === otherDuration) {
      return true;
    }
    if (otherDuration instanceof Duration2) {
      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
    }
    return false;
  };
  _proto.toString = function toString4() {
    if (this === Duration2.ZERO) {
      return "PT0S";
    }
    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
    var rval = "PT";
    if (hours !== 0) {
      rval += hours + "H";
    }
    if (minutes !== 0) {
      rval += minutes + "M";
    }
    if (secs === 0 && this._nanos === 0 && rval.length > 2) {
      return rval;
    }
    if (secs < 0 && this._nanos > 0) {
      if (secs === -1) {
        rval += "-0";
      } else {
        rval += secs + 1;
      }
    } else {
      rval += secs;
    }
    if (this._nanos > 0) {
      rval += ".";
      var nanoString;
      if (secs < 0) {
        nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
      } else {
        nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
      }
      nanoString = nanoString.slice(1, nanoString.length);
      rval += nanoString;
      while (rval.charAt(rval.length - 1) === "0") {
        rval = rval.slice(0, rval.length - 1);
      }
    }
    rval += "S";
    return rval;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Duration2;
}(TemporalAmount);
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
 */
var YearConstants = function YearConstants2() {
};
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}
var ChronoUnit = function(_TemporalUnit) {
  _inheritsLoose(ChronoUnit2, _TemporalUnit);
  function ChronoUnit2(name2, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name2;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto = ChronoUnit2.prototype;
  _proto.duration = function duration2() {
    return this._duration;
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    return this.isDateBased() || this === ChronoUnit2.FOREVER;
  };
  _proto.isDateBased = function isDateBased() {
    return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
  };
  _proto.isTimeBased = function isTimeBased() {
    return this.compareTo(ChronoUnit2.DAYS) < 0;
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    if (this === ChronoUnit2.FOREVER) {
      return false;
    }
    try {
      temporal.plus(1, this);
      return true;
    } catch (e) {
      try {
        temporal.plus(-1, this);
        return true;
      } catch (e2) {
        return false;
      }
    }
  };
  _proto.addTo = function addTo(temporal, amount) {
    return temporal.plus(amount, this);
  };
  _proto.between = function between(temporal1, temporal2) {
    return temporal1.until(temporal2, this);
  };
  _proto.toString = function toString4() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    return this.duration().compareTo(other.duration());
  };
  return ChronoUnit2;
}(TemporalUnit);
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
  ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
  ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
  ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalField = function() {
  function TemporalField2() {
  }
  var _proto = TemporalField2.prototype;
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail("isDateBased");
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail("isTimeBased");
  };
  _proto.baseUnit = function baseUnit() {
    abstractMethodFail("baseUnit");
  };
  _proto.rangeUnit = function rangeUnit() {
    abstractMethodFail("rangeUnit");
  };
  _proto.range = function range2() {
    abstractMethodFail("range");
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    abstractMethodFail("rangeRefinedBy");
  };
  _proto.getFrom = function getFrom(temporal) {
    abstractMethodFail("getFrom");
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    abstractMethodFail("adjustInto");
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail("isSupportedBy");
  };
  _proto.displayName = function displayName() {
    abstractMethodFail("displayName");
  };
  _proto.equals = function equals(other) {
    abstractMethodFail("equals");
  };
  _proto.name = function name2() {
    abstractMethodFail("name");
  };
  return TemporalField2;
}();
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ValueRange = function() {
  function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
    assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
    assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
    assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
    this._minSmallest = minSmallest;
    this._minLargest = minLargest;
    this._maxLargest = maxLargest;
    this._maxSmallest = maxSmallest;
  }
  var _proto = ValueRange2.prototype;
  _proto.isFixed = function isFixed() {
    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
  };
  _proto.minimum = function minimum() {
    return this._minSmallest;
  };
  _proto.largestMinimum = function largestMinimum() {
    return this._minLargest;
  };
  _proto.maximum = function maximum() {
    return this._maxLargest;
  };
  _proto.smallestMaximum = function smallestMaximum() {
    return this._maxSmallest;
  };
  _proto.isValidValue = function isValidValue(value) {
    return this.minimum() <= value && value <= this.maximum();
  };
  _proto.checkValidValue = function checkValidValue(value, field) {
    var msg;
    if (!this.isValidValue(value)) {
      if (field != null) {
        msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
      } else {
        msg = "Invalid value (valid values " + this.toString() + "): " + value;
      }
      return assert(false, msg, DateTimeException);
    }
    return value;
  };
  _proto.checkValidIntValue = function checkValidIntValue(value, field) {
    if (this.isValidIntValue(value) === false) {
      throw new DateTimeException("Invalid int value for " + field + ": " + value);
    }
    return value;
  };
  _proto.isValidIntValue = function isValidIntValue(value) {
    return this.isIntValue() && this.isValidValue(value);
  };
  _proto.isIntValue = function isIntValue() {
    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ValueRange2) {
      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
  };
  _proto.toString = function toString4() {
    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
    str += " - ";
    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
    return str;
  };
  ValueRange2.of = function of() {
    if (arguments.length === 2) {
      return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
    } else if (arguments.length === 3) {
      return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
    } else if (arguments.length === 4) {
      return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
    } else {
      return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
    }
  };
  return ValueRange2;
}();
var ChronoField = function(_TemporalField) {
  _inheritsLoose(ChronoField2, _TemporalField);
  ChronoField2.byName = function byName(fieldName) {
    for (var prop in ChronoField2) {
      if (ChronoField2[prop]) {
        if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
          return ChronoField2[prop];
        }
      }
    }
  };
  function ChronoField2(name2, baseUnit, rangeUnit, range2) {
    var _this;
    _this = _TemporalField.call(this) || this;
    _this._name = name2;
    _this._baseUnit = baseUnit;
    _this._rangeUnit = rangeUnit;
    _this._range = range2;
    return _this;
  }
  var _proto = ChronoField2.prototype;
  _proto.name = function name2() {
    return this._name;
  };
  _proto.baseUnit = function baseUnit() {
    return this._baseUnit;
  };
  _proto.rangeUnit = function rangeUnit() {
    return this._rangeUnit;
  };
  _proto.range = function range2() {
    return this._range;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.checkValidValue = function checkValidValue(value) {
    return this.range().checkValidValue(value, this);
  };
  _proto.checkValidIntValue = function checkValidIntValue(value) {
    return this.range().checkValidIntValue(value, this);
  };
  _proto.isDateBased = function isDateBased() {
    var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
    return dateBased;
  };
  _proto.isTimeBased = function isTimeBased() {
    var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
    return timeBased;
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return temporal.range(this);
  };
  _proto.getFrom = function getFrom(temporal) {
    return temporal.getLong(this);
  };
  _proto.toString = function toString4() {
    return this.name();
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    return temporal.with(this, newValue);
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(this);
  };
  return ChronoField2;
}(TemporalField);
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
  ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
  ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
  ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalQueries = function() {
  function TemporalQueries2() {
  }
  TemporalQueries2.zoneId = function zoneId() {
    return TemporalQueries2.ZONE_ID;
  };
  TemporalQueries2.chronology = function chronology() {
    return TemporalQueries2.CHRONO;
  };
  TemporalQueries2.precision = function precision() {
    return TemporalQueries2.PRECISION;
  };
  TemporalQueries2.zone = function zone() {
    return TemporalQueries2.ZONE;
  };
  TemporalQueries2.offset = function offset() {
    return TemporalQueries2.OFFSET;
  };
  TemporalQueries2.localDate = function localDate() {
    return TemporalQueries2.LOCAL_DATE;
  };
  TemporalQueries2.localTime = function localTime() {
    return TemporalQueries2.LOCAL_TIME;
  };
  return TemporalQueries2;
}();
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAccessor = function() {
  function TemporalAccessor2() {
  }
  var _proto = TemporalAccessor2.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.get = function get3(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    abstractMethodFail("getLong");
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      if (this.isSupported(field)) {
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.isSupported = function isSupported(field) {
    abstractMethodFail("isSupported");
  };
  return TemporalAccessor2;
}();
var TemporalQuery = function(_Enum) {
  _inheritsLoose(TemporalQuery2, _Enum);
  function TemporalQuery2() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TemporalQuery2.prototype;
  _proto.queryFrom = function queryFrom(temporal) {
    abstractMethodFail("queryFrom");
  };
  return TemporalQuery2;
}(Enum);
function createTemporalQuery(name2, queryFromFunction) {
  var ExtendedTemporalQuery = function(_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
    function ExtendedTemporalQuery2() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery2;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name2);
}
var DayOfWeek = function(_TemporalAccessor) {
  _inheritsLoose(DayOfWeek2, _TemporalAccessor);
  function DayOfWeek2(ordinal, name2) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._ordinal = ordinal;
    _this._name = name2;
    return _this;
  }
  var _proto = DayOfWeek2.prototype;
  _proto.ordinal = function ordinal() {
    return this._ordinal;
  };
  _proto.name = function name2() {
    return this._name;
  };
  DayOfWeek2.values = function values2() {
    return ENUMS.slice();
  };
  DayOfWeek2.valueOf = function valueOf(name2) {
    var ordinal = 0;
    for (ordinal; ordinal < ENUMS.length; ordinal++) {
      if (ENUMS[ordinal].name() === name2) {
        break;
      }
    }
    return DayOfWeek2.of(ordinal + 1);
  };
  DayOfWeek2.of = function of(dayOfWeek) {
    if (dayOfWeek < 1 || dayOfWeek > 7) {
      throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
    }
    return ENUMS[dayOfWeek - 1];
  };
  DayOfWeek2.from = function from(temporal) {
    assert(temporal != null, "temporal", NullPointerException);
    if (temporal instanceof DayOfWeek2) {
      return temporal;
    }
    try {
      return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
    } catch (ex) {
      if (ex instanceof DateTimeException) {
        throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
      } else {
        throw ex;
      }
    }
  };
  _proto.value = function value() {
    return this._ordinal + 1;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.DAY_OF_WEEK;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get3(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(days) {
    var amount = MathUtil.floorMod(days, 7);
    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
  };
  _proto.minus = function minus(days) {
    return this.plus(-1 * MathUtil.floorMod(days, 7));
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    assert(_query != null, "query", NullPointerException);
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, "temporal");
    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString4() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, DayOfWeek2, "other");
    return this._ordinal - other._ordinal;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return DayOfWeek2;
}(TemporalAccessor);
var ENUMS;
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
  DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
  DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
  DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
  DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
  DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
  DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}
var Month = function(_TemporalAccessor) {
  _inheritsLoose(Month2, _TemporalAccessor);
  function Month2(value, name2) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._value = MathUtil.safeToInt(value);
    _this._name = name2;
    return _this;
  }
  var _proto = Month2.prototype;
  _proto.value = function value() {
    return this._value;
  };
  _proto.ordinal = function ordinal() {
    return this._value - 1;
  };
  _proto.name = function name2() {
    return this._name;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
  };
  _proto.isSupported = function isSupported(field) {
    if (null === field) {
      return false;
    }
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.get = function get3(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(months) {
    var amount = MathUtil.intMod(months, 12) + 12;
    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
    return Month2.of(newMonthVal);
  };
  _proto.minus = function minus(months) {
    return this.plus(-1 * MathUtil.intMod(months, 12));
  };
  _proto.length = function length(leapYear) {
    switch (this) {
      case Month2.FEBRUARY:
        return leapYear ? 29 : 28;
      case Month2.APRIL:
      case Month2.JUNE:
      case Month2.SEPTEMBER:
      case Month2.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.minLength = function minLength() {
    switch (this) {
      case Month2.FEBRUARY:
        return 28;
      case Month2.APRIL:
      case Month2.JUNE:
      case Month2.SEPTEMBER:
      case Month2.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.maxLength = function maxLength() {
    switch (this) {
      case Month2.FEBRUARY:
        return 29;
      case Month2.APRIL:
      case Month2.JUNE:
      case Month2.SEPTEMBER:
      case Month2.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
    var leap = leapYear ? 1 : 0;
    switch (this) {
      case Month2.JANUARY:
        return 1;
      case Month2.FEBRUARY:
        return 32;
      case Month2.MARCH:
        return 60 + leap;
      case Month2.APRIL:
        return 91 + leap;
      case Month2.MAY:
        return 121 + leap;
      case Month2.JUNE:
        return 152 + leap;
      case Month2.JULY:
        return 182 + leap;
      case Month2.AUGUST:
        return 213 + leap;
      case Month2.SEPTEMBER:
        return 244 + leap;
      case Month2.OCTOBER:
        return 274 + leap;
      case Month2.NOVEMBER:
        return 305 + leap;
      case Month2.DECEMBER:
      default:
        return 335 + leap;
    }
  };
  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
    switch (this) {
      case Month2.JANUARY:
      case Month2.FEBRUARY:
      case Month2.MARCH:
        return Month2.JANUARY;
      case Month2.APRIL:
      case Month2.MAY:
      case Month2.JUNE:
        return Month2.APRIL;
      case Month2.JULY:
      case Month2.AUGUST:
      case Month2.SEPTEMBER:
        return Month2.JULY;
      case Month2.OCTOBER:
      case Month2.NOVEMBER:
      case Month2.DECEMBER:
      default:
        return Month2.OCTOBER;
    }
  };
  _proto.query = function query(_query) {
    assert(_query != null, "query() parameter must not be null", DateTimeException);
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.toString = function toString4() {
    switch (this) {
      case Month2.JANUARY:
        return "JANUARY";
      case Month2.FEBRUARY:
        return "FEBRUARY";
      case Month2.MARCH:
        return "MARCH";
      case Month2.APRIL:
        return "APRIL";
      case Month2.MAY:
        return "MAY";
      case Month2.JUNE:
        return "JUNE";
      case Month2.JULY:
        return "JULY";
      case Month2.AUGUST:
        return "AUGUST";
      case Month2.SEPTEMBER:
        return "SEPTEMBER";
      case Month2.OCTOBER:
        return "OCTOBER";
      case Month2.NOVEMBER:
        return "NOVEMBER";
      case Month2.DECEMBER:
        return "DECEMBER";
      default:
        return "unknown Month, value: " + this.value();
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, Month2, "other");
    return this._value - other._value;
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  Month2.valueOf = function valueOf(name2) {
    var ordinal = 0;
    for (ordinal; ordinal < MONTHS.length; ordinal++) {
      if (MONTHS[ordinal].name() === name2) {
        break;
      }
    }
    return Month2.of(ordinal + 1);
  };
  Month2.values = function values2() {
    return MONTHS.slice();
  };
  Month2.of = function of(month) {
    if (month < 1 || month > 12) {
      assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
    }
    return MONTHS[month - 1];
  };
  Month2.from = function from(temporal) {
    if (temporal instanceof Month2) {
      return temporal;
    }
    try {
      return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
    }
  };
  return Month2;
}(TemporalAccessor);
var MONTHS;
function _init$i() {
  Month.JANUARY = new Month(1, "JANUARY");
  Month.FEBRUARY = new Month(2, "FEBRUARY");
  Month.MARCH = new Month(3, "MARCH");
  Month.APRIL = new Month(4, "APRIL");
  Month.MAY = new Month(5, "MAY");
  Month.JUNE = new Month(6, "JUNE");
  Month.JULY = new Month(7, "JULY");
  Month.AUGUST = new Month(8, "AUGUST");
  Month.SEPTEMBER = new Month(9, "SEPTEMBER");
  Month.OCTOBER = new Month(10, "OCTOBER");
  Month.NOVEMBER = new Month(11, "NOVEMBER");
  Month.DECEMBER = new Month(12, "DECEMBER");
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}
var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
var Period = function(_TemporalAmount) {
  _inheritsLoose(Period2, _TemporalAmount);
  function Period2(years, months, days) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    var _years = MathUtil.safeToInt(years);
    var _months = MathUtil.safeToInt(months);
    var _days = MathUtil.safeToInt(days);
    if (_years === 0 && _months === 0 && _days === 0) {
      if (!Period2.ZERO) {
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        Period2.ZERO = _assertThisInitialized(_this);
      }
      return Period2.ZERO || _assertThisInitialized(_this);
    }
    _this._years = _years;
    _this._months = _months;
    _this._days = _days;
    return _this;
  }
  Period2.ofYears = function ofYears(years) {
    return Period2.create(years, 0, 0);
  };
  Period2.ofMonths = function ofMonths(months) {
    return Period2.create(0, months, 0);
  };
  Period2.ofWeeks = function ofWeeks(weeks) {
    return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
  };
  Period2.ofDays = function ofDays(days) {
    return Period2.create(0, 0, days);
  };
  Period2.of = function of(years, months, days) {
    return Period2.create(years, months, days);
  };
  Period2.from = function from(amount) {
    if (amount instanceof Period2) {
      return amount;
    }
    requireNonNull(amount, "amount");
    var years = 0;
    var months = 0;
    var days = 0;
    var units = amount.units();
    for (var i = 0; i < units.length; i++) {
      var unit = units[i];
      var unitAmount = amount.get(unit);
      if (unit === ChronoUnit.YEARS) {
        years = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.MONTHS) {
        months = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.DAYS) {
        days = MathUtil.safeToInt(unitAmount);
      } else {
        throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
      }
    }
    return Period2.create(years, months, days);
  };
  Period2.between = function between(startDate, endDate) {
    requireNonNull(startDate, "startDate");
    requireNonNull(endDate, "endDate");
    requireInstance(startDate, LocalDate, "startDate");
    requireInstance(endDate, LocalDate, "endDate");
    return startDate.until(endDate);
  };
  Period2.parse = function parse2(text2) {
    requireNonNull(text2, "text");
    try {
      return Period2._parse(text2);
    } catch (ex) {
      if (ex instanceof ArithmeticException) {
        throw new DateTimeParseException("Text cannot be parsed to a Period", text2, 0, ex);
      } else {
        throw ex;
      }
    }
  };
  Period2._parse = function _parse(text2) {
    var matches = PATTERN.exec(text2);
    if (matches != null) {
      var negate = "-" === matches[1] ? -1 : 1;
      var yearMatch = matches[2];
      var monthMatch = matches[3];
      var weekMatch = matches[4];
      var dayMatch = matches[5];
      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
        var years = Period2._parseNumber(text2, yearMatch, negate);
        var months = Period2._parseNumber(text2, monthMatch, negate);
        var weeks = Period2._parseNumber(text2, weekMatch, negate);
        var days = Period2._parseNumber(text2, dayMatch, negate);
        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
        return Period2.create(years, months, days);
      }
    }
    throw new DateTimeParseException("Text cannot be parsed to a Period", text2, 0);
  };
  Period2._parseNumber = function _parseNumber(text2, str, negate) {
    if (str == null) {
      return 0;
    }
    var val = MathUtil.parseInt(str);
    return MathUtil.safeMultiply(val, negate);
  };
  Period2.create = function create(years, months, days) {
    return new Period2(years, months, days);
  };
  var _proto = Period2.prototype;
  _proto.units = function units() {
    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.get = function get3(unit) {
    if (unit === ChronoUnit.YEARS) {
      return this._years;
    }
    if (unit === ChronoUnit.MONTHS) {
      return this._months;
    }
    if (unit === ChronoUnit.DAYS) {
      return this._days;
    }
    throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
  };
  _proto.isZero = function isZero() {
    return this === Period2.ZERO;
  };
  _proto.isNegative = function isNegative() {
    return this._years < 0 || this._months < 0 || this._days < 0;
  };
  _proto.years = function years() {
    return this._years;
  };
  _proto.months = function months() {
    return this._months;
  };
  _proto.days = function days() {
    return this._days;
  };
  _proto.withYears = function withYears(years) {
    if (years === this._years) {
      return this;
    }
    return Period2.create(years, this._months, this._days);
  };
  _proto.withMonths = function withMonths(months) {
    if (months === this._months) {
      return this;
    }
    return Period2.create(this._years, months, this._days);
  };
  _proto.withDays = function withDays(days) {
    if (days === this._days) {
      return this;
    }
    return Period2.create(this._years, this._months, days);
  };
  _proto.plus = function plus(amountToAdd) {
    var amount = Period2.from(amountToAdd);
    return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
  };
  _proto.minus = function minus(amountToSubtract) {
    var amount = Period2.from(amountToSubtract);
    return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(-1 * yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(-1 * monthsToSubtract);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(-1 * daysToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(scalar) {
    if (this === Period2.ZERO || scalar === 1) {
      return this;
    }
    return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.normalized = function normalized() {
    var totalMonths = this.toTotalMonths();
    var splitYears = MathUtil.intDiv(totalMonths, 12);
    var splitMonths = MathUtil.intMod(totalMonths, 12);
    if (splitYears === this._years && splitMonths === this._months) {
      return this;
    }
    return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
  };
  _proto.toTotalMonths = function toTotalMonths() {
    return this._years * 12 + this._months;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, "temporal");
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.plus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.plus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, "temporal");
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.minus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.minus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.equals = function equals(obj2) {
    if (this === obj2) {
      return true;
    }
    if (obj2 instanceof Period2) {
      var other = obj2;
      return this._years === other._years && this._months === other._months && this._days === other._days;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._years, this._months, this._days);
  };
  _proto.toString = function toString4() {
    if (this === Period2.ZERO) {
      return "P0D";
    } else {
      var buf = "P";
      if (this._years !== 0) {
        buf += this._years + "Y";
      }
      if (this._months !== 0) {
        buf += this._months + "M";
      }
      if (this._days !== 0) {
        buf += this._days + "D";
      }
      return buf;
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Period2;
}(TemporalAmount);
function _init$h() {
  Period.ofDays(0);
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ParsePosition = function() {
  function ParsePosition2(index) {
    this._index = index;
    this._errorIndex = -1;
  }
  var _proto = ParsePosition2.prototype;
  _proto.getIndex = function getIndex() {
    return this._index;
  };
  _proto.setIndex = function setIndex(index) {
    this._index = index;
  };
  _proto.getErrorIndex = function getErrorIndex() {
    return this._errorIndex;
  };
  _proto.setErrorIndex = function setErrorIndex(errorIndex) {
    this._errorIndex = errorIndex;
  };
  return ParsePosition2;
}();
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var EnumMap = function() {
  function EnumMap2() {
    this._map = {};
  }
  var _proto = EnumMap2.prototype;
  _proto.putAll = function putAll(otherMap) {
    for (var key2 in otherMap._map) {
      this._map[key2] = otherMap._map[key2];
    }
    return this;
  };
  _proto.containsKey = function containsKey(key2) {
    return this._map.hasOwnProperty(key2.name()) && this.get(key2) !== void 0;
  };
  _proto.get = function get3(key2) {
    return this._map[key2.name()];
  };
  _proto.put = function put(key2, val) {
    return this.set(key2, val);
  };
  _proto.set = function set2(key2, val) {
    this._map[key2.name()] = val;
    return this;
  };
  _proto.retainAll = function retainAll(keyList) {
    var map = {};
    for (var i = 0; i < keyList.length; i++) {
      var key2 = keyList[i].name();
      map[key2] = this._map[key2];
    }
    this._map = map;
    return this;
  };
  _proto.remove = function remove2(key2) {
    var keyName = key2.name();
    var val = this._map[keyName];
    this._map[keyName] = void 0;
    return val;
  };
  _proto.keySet = function keySet() {
    return this._map;
  };
  _proto.clear = function clear() {
    this._map = {};
  };
  return EnumMap2;
}();
var ResolverStyle = function(_Enum) {
  _inheritsLoose(ResolverStyle2, _Enum);
  function ResolverStyle2() {
    return _Enum.apply(this, arguments) || this;
  }
  return ResolverStyle2;
}(Enum);
ResolverStyle.STRICT = new ResolverStyle("STRICT");
ResolverStyle.SMART = new ResolverStyle("SMART");
ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
var Temporal = function(_TemporalAccessor) {
  _inheritsLoose(Temporal2, _TemporalAccessor);
  function Temporal2() {
    return _TemporalAccessor.apply(this, arguments) || this;
  }
  var _proto = Temporal2.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    abstractMethodFail("isSupported");
  };
  _proto.minus = function minus(amount, unit) {
    if (arguments.length < 2) {
      return this._minusAmount(amount);
    } else {
      return this._minusUnit(amount, unit);
    }
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount, "amount");
    requireInstance(amount, TemporalAmount, "amount");
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, "amountToSubtract");
    requireNonNull(unit, "unit");
    requireInstance(unit, TemporalUnit, "unit");
    return this._plusUnit(-amountToSubtract, unit);
  };
  _proto.plus = function plus(amount, unit) {
    if (arguments.length < 2) {
      return this._plusAmount(amount);
    } else {
      return this._plusUnit(amount, unit);
    }
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, "amount");
    requireInstance(amount, TemporalAmount, "amount");
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    abstractMethodFail("_plusUnit");
  };
  _proto.until = function until(endTemporal, unit) {
    abstractMethodFail("until");
  };
  _proto.with = function _with(adjusterOrField, newValue) {
    if (arguments.length < 2) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, newValue);
    }
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, "adjuster");
    assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    abstractMethodFail("_withField");
  };
  return Temporal2;
}(TemporalAccessor);
if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
  Temporal.prototype[Symbol.toPrimitive] = function(hint) {
    if (hint !== "number") {
      return this.toString();
    }
    throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
  };
}
var ChronoLocalDate = function(_Temporal) {
  _inheritsLoose(ChronoLocalDate2, _Temporal);
  function ChronoLocalDate2() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDate2.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toEpochDay());
    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return formatter.format(this);
  };
  return ChronoLocalDate2;
}(Temporal);
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringUtil = function() {
  function StringUtil2() {
  }
  StringUtil2.startsWith = function startsWith(text2, pattern) {
    return text2.indexOf(pattern) === 0;
  };
  StringUtil2.hashCode = function hashCode(text2) {
    var len = text2.length;
    if (len === 0) {
      return 0;
    }
    var hash = 0;
    for (var i = 0; i < len; i++) {
      var chr = text2.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return MathUtil.smi(hash);
  };
  return StringUtil2;
}();
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneId = function() {
  function ZoneId2() {
  }
  ZoneId2.systemDefault = function systemDefault() {
    throw new DateTimeException("not supported operation");
  };
  ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
    throw new DateTimeException("not supported operation");
  };
  ZoneId2.of = function of(zoneId) {
    throw new DateTimeException("not supported operation" + zoneId);
  };
  ZoneId2.ofOffset = function ofOffset(prefix, offset) {
    throw new DateTimeException("not supported operation" + prefix + offset);
  };
  ZoneId2.from = function from(temporal) {
    throw new DateTimeException("not supported operation" + temporal);
  };
  var _proto = ZoneId2.prototype;
  _proto.id = function id() {
    abstractMethodFail("ZoneId.id");
  };
  _proto.rules = function rules() {
    abstractMethodFail("ZoneId.rules");
  };
  _proto.normalized = function normalized() {
    var rules = this.rules();
    if (rules.isFixedOffset()) {
      return rules.offset(Instant.EPOCH);
    }
    return this;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZoneId2) {
      return this.id() === other.id();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return StringUtil.hashCode(this.id());
  };
  _proto.toString = function toString4() {
    return this.id();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneId2;
}();
var ZoneRules = function() {
  function ZoneRules2() {
  }
  ZoneRules2.of = function of(offset) {
    requireNonNull(offset, "offset");
    return new Fixed(offset);
  };
  var _proto = ZoneRules2.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    abstractMethodFail("ZoneRules.isFixedOffset");
  };
  _proto.offset = function offset(instantOrLocalDateTime) {
    if (instantOrLocalDateTime instanceof Instant) {
      return this.offsetOfInstant(instantOrLocalDateTime);
    } else {
      return this.offsetOfLocalDateTime(instantOrLocalDateTime);
    }
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    abstractMethodFail("ZoneRules.offsetInstant");
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    abstractMethodFail("ZoneRules.offsetOfEpochMilli");
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    abstractMethodFail("ZoneRules.offsetLocalDateTime");
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    abstractMethodFail("ZoneRules.validOffsets");
  };
  _proto.transition = function transition(localDateTime) {
    abstractMethodFail("ZoneRules.transition");
  };
  _proto.standardOffset = function standardOffset(instant) {
    abstractMethodFail("ZoneRules.standardOffset");
  };
  _proto.daylightSavings = function daylightSavings(instant) {
    abstractMethodFail("ZoneRules.daylightSavings");
  };
  _proto.isDaylightSavings = function isDaylightSavings(instant) {
    abstractMethodFail("ZoneRules.isDaylightSavings");
  };
  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
    abstractMethodFail("ZoneRules.isValidOffset");
  };
  _proto.nextTransition = function nextTransition(instant) {
    abstractMethodFail("ZoneRules.nextTransition");
  };
  _proto.previousTransition = function previousTransition(instant) {
    abstractMethodFail("ZoneRules.previousTransition");
  };
  _proto.transitions = function transitions() {
    abstractMethodFail("ZoneRules.transitions");
  };
  _proto.transitionRules = function transitionRules() {
    abstractMethodFail("ZoneRules.transitionRules");
  };
  _proto.toString = function toString4() {
    abstractMethodFail("ZoneRules.toString");
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneRules2;
}();
var Fixed = function(_ZoneRules) {
  _inheritsLoose(Fixed2, _ZoneRules);
  function Fixed2(offset) {
    var _this;
    _this = _ZoneRules.call(this) || this;
    _this._offset = offset;
    return _this;
  }
  var _proto2 = Fixed2.prototype;
  _proto2.isFixedOffset = function isFixedOffset() {
    return true;
  };
  _proto2.offsetOfInstant = function offsetOfInstant() {
    return this._offset;
  };
  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
    return this._offset;
  };
  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
    return this._offset;
  };
  _proto2.validOffsets = function validOffsets() {
    return [this._offset];
  };
  _proto2.transition = function transition() {
    return null;
  };
  _proto2.standardOffset = function standardOffset() {
    return this._offset;
  };
  _proto2.daylightSavings = function daylightSavings() {
    return Duration.ZERO;
  };
  _proto2.isDaylightSavings = function isDaylightSavings() {
    return false;
  };
  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
    return this._offset.equals(offset);
  };
  _proto2.nextTransition = function nextTransition() {
    return null;
  };
  _proto2.previousTransition = function previousTransition() {
    return null;
  };
  _proto2.transitions = function transitions() {
    return [];
  };
  _proto2.transitionRules = function transitionRules() {
    return [];
  };
  _proto2.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Fixed2) {
      return this._offset.equals(other._offset);
    }
    return false;
  };
  _proto2.toString = function toString4() {
    return "FixedRules:" + this._offset.toString();
  };
  return Fixed2;
}(ZoneRules);
var SECONDS_CACHE = {};
var ID_CACHE = {};
var ZoneOffset = function(_ZoneId) {
  _inheritsLoose(ZoneOffset2, _ZoneId);
  function ZoneOffset2(totalSeconds) {
    var _this;
    _this = _ZoneId.call(this) || this;
    ZoneOffset2._validateTotalSeconds(totalSeconds);
    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
    _this._rules = ZoneRules.of(_assertThisInitialized(_this));
    _this._id = ZoneOffset2._buildId(totalSeconds);
    return _this;
  }
  var _proto = ZoneOffset2.prototype;
  _proto.totalSeconds = function totalSeconds() {
    return this._totalSeconds;
  };
  _proto.id = function id() {
    return this._id;
  };
  ZoneOffset2._buildId = function _buildId(totalSeconds) {
    if (totalSeconds === 0) {
      return "Z";
    } else {
      var absTotalSeconds = Math.abs(totalSeconds);
      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
      var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
      if (absSeconds !== 0) {
        buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
      }
      return buf;
    }
  };
  ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
    if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
      throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
    }
  };
  ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
    if (hours < -18 || hours > 18) {
      throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
    }
    if (hours > 0) {
      if (minutes < 0 || seconds < 0) {
        throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
      }
    } else if (hours < 0) {
      if (minutes > 0 || seconds > 0) {
        throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
      }
    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
      throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
    }
    if (Math.abs(minutes) > 59) {
      throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
    }
    if (Math.abs(seconds) > 59) {
      throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
    }
    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
      throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
    }
  };
  ZoneOffset2.of = function of(offsetId) {
    requireNonNull(offsetId, "offsetId");
    var offset = ID_CACHE[offsetId];
    if (offset != null) {
      return offset;
    }
    var hours, minutes, seconds;
    switch (offsetId.length) {
      case 2:
        offsetId = offsetId[0] + "0" + offsetId[1];
      case 3:
        hours = ZoneOffset2._parseNumber(offsetId, 1, false);
        minutes = 0;
        seconds = 0;
        break;
      case 5:
        hours = ZoneOffset2._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
        seconds = 0;
        break;
      case 6:
        hours = ZoneOffset2._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
        seconds = 0;
        break;
      case 7:
        hours = ZoneOffset2._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
        seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
        break;
      case 9:
        hours = ZoneOffset2._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
        seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
        break;
      default:
        throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
    }
    var first = offsetId[0];
    if (first !== "+" && first !== "-") {
      throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
    }
    if (first === "-") {
      return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
    } else {
      return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
    }
  };
  ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
    if (precededByColon && offsetId[pos - 1] !== ":") {
      throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
    }
    var ch1 = offsetId[pos];
    var ch2 = offsetId[pos + 1];
    if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
      throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
    }
    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
  };
  ZoneOffset2.ofHours = function ofHours(hours) {
    return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
  };
  ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
    return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
  };
  ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
    ZoneOffset2._validate(hours, minutes, seconds);
    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
    return ZoneOffset2.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
    return ZoneOffset2.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
      var totalSecs = totalSeconds;
      var result = SECONDS_CACHE[totalSecs];
      if (result == null) {
        result = new ZoneOffset2(totalSeconds);
        SECONDS_CACHE[totalSecs] = result;
        ID_CACHE[result.id()] = result;
      }
      return result;
    } else {
      return new ZoneOffset2(totalSeconds);
    }
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.get = function get3(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.OFFSET_SECONDS) {
      return this._totalSeconds;
    } else if (field instanceof ChronoField) {
      throw new DateTimeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    return other._totalSeconds - this._totalSeconds;
  };
  _proto.equals = function equals(obj2) {
    if (this === obj2) {
      return true;
    }
    if (obj2 instanceof ZoneOffset2) {
      return this._totalSeconds === obj2._totalSeconds;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._totalSeconds;
  };
  _proto.toString = function toString4() {
    return this._id;
  };
  return ZoneOffset2;
}(ZoneId);
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}
var DateTimeBuilder = function(_TemporalAccessor) {
  _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
  DateTimeBuilder2.create = function create(field, value) {
    var dtb = new DateTimeBuilder2();
    dtb._addFieldValue(field, value);
    return dtb;
  };
  function DateTimeBuilder2() {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this.fieldValues = new EnumMap();
    _this.chrono = null;
    _this.zone = null;
    _this.date = null;
    _this.time = null;
    _this.leapSecond = false;
    _this.excessDays = null;
    return _this;
  }
  var _proto = DateTimeBuilder2.prototype;
  _proto.getFieldValue0 = function getFieldValue0(field) {
    return this.fieldValues.get(field);
  };
  _proto._addFieldValue = function _addFieldValue(field, value) {
    requireNonNull(field, "field");
    var old = this.getFieldValue0(field);
    if (old != null && old !== value) {
      throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
    }
    return this._putFieldValue0(field, value);
  };
  _proto._putFieldValue0 = function _putFieldValue0(field, value) {
    this.fieldValues.put(field, value);
    return this;
  };
  _proto.resolve = function resolve(resolverStyle, resolverFields) {
    if (resolverFields != null) {
      this.fieldValues.retainAll(resolverFields);
    }
    this._mergeDate(resolverStyle);
    this._mergeTime(resolverStyle);
    this._resolveTimeInferZeroes(resolverStyle);
    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
      this.date = this.date.plus(this.excessDays);
      this.excessDays = Period.ZERO;
    }
    this._resolveInstant();
    return this;
  };
  _proto._mergeDate = function _mergeDate(resolverStyle) {
    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
  };
  _proto._checkDate = function _checkDate(date2) {
    if (date2 != null) {
      this._addObject(date2);
      for (var fieldName in this.fieldValues.keySet()) {
        var field = ChronoField.byName(fieldName);
        if (field) {
          if (this.fieldValues.get(field) !== void 0) {
            if (field.isDateBased()) {
              var val1 = void 0;
              try {
                val1 = date2.getLong(field);
              } catch (ex) {
                if (ex instanceof DateTimeException) {
                  continue;
                } else {
                  throw ex;
                }
              }
              var val2 = this.fieldValues.get(field);
              if (val1 !== val2) {
                throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date2);
              }
            }
          }
        }
      }
    }
  };
  _proto._mergeTime = function _mergeTime(resolverStyle) {
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && ch === 0) ;
        else {
          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
    }
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ;
        else {
          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
      }
      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
    }
    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.NANO_OF_DAY.checkValidValue(nod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MICRO_OF_DAY.checkValidValue(cod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MILLI_OF_DAY.checkValidValue(lod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
    }
    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.SECOND_OF_DAY.checkValidValue(sod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
    }
    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
      }
      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
    }
  };
  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
    if (hod == null) {
      return;
    }
    if (moh == null && (som != null || nos != null)) {
      return;
    }
    if (moh != null && som == null && nos != null) {
      return;
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (hod != null) {
        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
          hod = 0;
          this.excessDays = Period.ofDays(1);
        }
        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
        if (moh != null) {
          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
          if (som != null) {
            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
            if (nos != null) {
              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
            } else {
              this._addObject(LocalTime.of(hodVal, mohVal, somVal));
            }
          } else {
            if (nos == null) {
              this._addObject(LocalTime.of(hodVal, mohVal));
            }
          }
        } else {
          if (som == null && nos == null) {
            this._addObject(LocalTime.of(hodVal, 0));
          }
        }
      }
    } else {
      if (hod != null) {
        var _hodVal = hod;
        if (moh != null) {
          if (som != null) {
            if (nos == null) {
              nos = 0;
            }
            var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
            totalNanos = MathUtil.safeAdd(totalNanos, nos);
            var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
            var nod = MathUtil.floorMod(totalNanos, 864e11);
            this._addObject(LocalTime.ofNanoOfDay(nod));
            this.excessDays = Period.ofDays(excessDays);
          } else {
            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
            var sod = MathUtil.floorMod(totalSecs, 86400);
            this._addObject(LocalTime.ofSecondOfDay(sod));
            this.excessDays = Period.ofDays(_excessDays);
          }
        } else {
          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
          _hodVal = MathUtil.floorMod(_hodVal, 24);
          this._addObject(LocalTime.of(_hodVal, 0));
          this.excessDays = Period.ofDays(_excessDays2);
        }
      }
    }
    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
  };
  _proto._addObject = function _addObject(dateOrTime) {
    if (dateOrTime instanceof ChronoLocalDate) {
      this.date = dateOrTime;
    } else if (dateOrTime instanceof LocalTime) {
      this.time = dateOrTime;
    }
  };
  _proto._resolveInstant = function _resolveInstant() {
    if (this.date != null && this.time != null) {
      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
      if (offsetSecs != null) {
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
      } else if (this.zone != null) {
        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
      }
    }
  };
  _proto.build = function build(type2) {
    return type2.queryFrom(this);
  };
  _proto.isSupported = function isSupported(field) {
    if (field == null) {
      return false;
    }
    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    var value = this.getFieldValue0(field);
    if (value == null) {
      if (this.date != null && this.date.isSupported(field)) {
        return this.date.getLong(field);
      }
      if (this.time != null && this.time.isSupported(field)) {
        return this.time.getLong(field);
      }
      throw new DateTimeException("Field not found: " + field);
    }
    return value;
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId()) {
      return this.zone;
    } else if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    } else if (_query === TemporalQueries.localDate()) {
      return this.date != null ? LocalDate.from(this.date) : null;
    } else if (_query === TemporalQueries.localTime()) {
      return this.time;
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return _query.queryFrom(this);
    } else if (_query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  return DateTimeBuilder2;
}(TemporalAccessor);
var DateTimeParseContext = function() {
  function DateTimeParseContext2() {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DateTimeParseContext2) {
        this._constructorSelf.apply(this, arguments);
        return;
      } else {
        this._constructorFormatter.apply(this, arguments);
      }
    } else {
      this._constructorParam.apply(this, arguments);
    }
    this._caseSensitive = true;
    this._strict = true;
    this._parsed = [new Parsed(this)];
  }
  var _proto = DateTimeParseContext2.prototype;
  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
    this._locale = locale;
    this._symbols = symbols;
    this._overrideChronology = chronology;
  };
  _proto._constructorFormatter = function _constructorFormatter(formatter) {
    this._locale = formatter.locale();
    this._symbols = formatter.decimalStyle();
    this._overrideChronology = formatter.chronology();
  };
  _proto._constructorSelf = function _constructorSelf(other) {
    this._locale = other._locale;
    this._symbols = other._symbols;
    this._overrideChronology = other._overrideChronology;
    this._overrideZone = other._overrideZone;
    this._caseSensitive = other._caseSensitive;
    this._strict = other._strict;
    this._parsed = [new Parsed(this)];
  };
  _proto.copy = function copy2() {
    return new DateTimeParseContext2(this);
  };
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.isStrict = function isStrict() {
    return this._strict;
  };
  _proto.setStrict = function setStrict(strict) {
    this._strict = strict;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  _proto.startOptional = function startOptional() {
    this._parsed.push(this.currentParsed().copy());
  };
  _proto.endOptional = function endOptional(successful) {
    if (successful) {
      this._parsed.splice(this._parsed.length - 2, 1);
    } else {
      this._parsed.splice(this._parsed.length - 1, 1);
    }
  };
  _proto.isCaseSensitive = function isCaseSensitive() {
    return this._caseSensitive;
  };
  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
    this._caseSensitive = caseSensitive;
  };
  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
      return false;
    }
    if (!this.isCaseSensitive()) {
      cs1 = cs1.toLowerCase();
      cs2 = cs2.toLowerCase();
    }
    for (var i = 0; i < length; i++) {
      var ch1 = cs1[offset1 + i];
      var ch2 = cs2[offset2 + i];
      if (ch1 !== ch2) {
        return false;
      }
    }
    return true;
  };
  _proto.charEquals = function charEquals(ch1, ch2) {
    if (this.isCaseSensitive()) {
      return ch1 === ch2;
    }
    return this.charEqualsIgnoreCase(ch1, ch2);
  };
  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
  };
  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
    var currentParsedFieldValues = this.currentParsed().fieldValues;
    var old = currentParsedFieldValues.get(field);
    currentParsedFieldValues.set(field, value);
    return old != null && old !== value ? ~errorPos : successPos;
  };
  _proto.setParsedZone = function setParsedZone(zone) {
    requireNonNull(zone, "zone");
    this.currentParsed().zone = zone;
  };
  _proto.getParsed = function getParsed(field) {
    return this.currentParsed().fieldValues.get(field);
  };
  _proto.toParsed = function toParsed() {
    return this.currentParsed();
  };
  _proto.currentParsed = function currentParsed() {
    return this._parsed[this._parsed.length - 1];
  };
  _proto.setParsedLeapSecond = function setParsedLeapSecond() {
    this.currentParsed().leapSecond = true;
  };
  _proto.getEffectiveChronology = function getEffectiveChronology() {
    var chrono = this.currentParsed().chrono;
    if (chrono == null) {
      chrono = this._overrideChronology;
      if (chrono == null) {
        chrono = IsoChronology.INSTANCE;
      }
    }
    return chrono;
  };
  return DateTimeParseContext2;
}();
var Parsed = function(_Temporal) {
  _inheritsLoose(Parsed2, _Temporal);
  function Parsed2(dateTimeParseContext) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this.chrono = null;
    _this.zone = null;
    _this.fieldValues = new EnumMap();
    _this.leapSecond = false;
    _this.dateTimeParseContext = dateTimeParseContext;
    return _this;
  }
  var _proto2 = Parsed2.prototype;
  _proto2.copy = function copy2() {
    var cloned = new Parsed2();
    cloned.chrono = this.chrono;
    cloned.zone = this.zone;
    cloned.fieldValues.putAll(this.fieldValues);
    cloned.leapSecond = this.leapSecond;
    cloned.dateTimeParseContext = this.dateTimeParseContext;
    return cloned;
  };
  _proto2.toString = function toString4() {
    return this.fieldValues + ", " + this.chrono + ", " + this.zone;
  };
  _proto2.isSupported = function isSupported(field) {
    return this.fieldValues.containsKey(field);
  };
  _proto2.get = function get3(field) {
    var val = this.fieldValues.get(field);
    assert(val != null);
    return val;
  };
  _proto2.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    }
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto2.toBuilder = function toBuilder() {
    var builder2 = new DateTimeBuilder();
    builder2.fieldValues.putAll(this.fieldValues);
    builder2.chrono = this.dateTimeParseContext.getEffectiveChronology();
    if (this.zone != null) {
      builder2.zone = this.zone;
    } else {
      builder2.zone = this.overrideZone;
    }
    builder2.leapSecond = this.leapSecond;
    builder2.excessDays = this.excessDays;
    return builder2;
  };
  return Parsed2;
}(Temporal);
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimePrintContext = function() {
  function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
      this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
      this._locale = localeOrFormatter.locale();
      this._symbols = localeOrFormatter.decimalStyle();
    } else {
      this._temporal = temporal;
      this._locale = localeOrFormatter;
      this._symbols = symbols;
    }
    this._optional = 0;
  }
  DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
    return temporal;
  };
  var _proto = DateTimePrintContext2.prototype;
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.startOptional = function startOptional() {
    this._optional++;
  };
  _proto.endOptional = function endOptional() {
    this._optional--;
  };
  _proto.getValueQuery = function getValueQuery(query) {
    var result = this._temporal.query(query);
    if (result == null && this._optional === 0) {
      throw new DateTimeException("Unable to extract value: " + this._temporal);
    }
    return result;
  };
  _proto.getValue = function getValue(field) {
    try {
      return this._temporal.getLong(field);
    } catch (ex) {
      if (ex instanceof DateTimeException && this._optional > 0) {
        return null;
      }
      throw ex;
    }
  };
  _proto.temporal = function temporal() {
    return this._temporal;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setDateTime = function setDateTime(temporal) {
    this._temporal = temporal;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  return DateTimePrintContext2;
}();
var IsoFields = {};
var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
var Field = function(_TemporalField) {
  _inheritsLoose(Field2, _TemporalField);
  function Field2() {
    return _TemporalField.apply(this, arguments) || this;
  }
  var _proto = Field2.prototype;
  _proto.isDateBased = function isDateBased() {
    return true;
  };
  _proto.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto._isIso = function _isIso() {
    return true;
  };
  Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date2) {
    var wby = Field2._getWeekBasedYear(date2);
    return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
  };
  Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
    var date2 = LocalDate.of(wby, 1, 1);
    if (date2.dayOfWeek() === DayOfWeek.THURSDAY || date2.dayOfWeek() === DayOfWeek.WEDNESDAY && date2.isLeapYear()) {
      return 53;
    }
    return 52;
  };
  Field2._getWeek = function _getWeek(date2) {
    var dow0 = date2.dayOfWeek().ordinal();
    var doy0 = date2.dayOfYear() - 1;
    var doyThu0 = doy0 + (3 - dow0);
    var alignedWeek = MathUtil.intDiv(doyThu0, 7);
    var firstThuDoy0 = doyThu0 - alignedWeek * 7;
    var firstMonDoy0 = firstThuDoy0 - 3;
    if (firstMonDoy0 < -3) {
      firstMonDoy0 += 7;
    }
    if (doy0 < firstMonDoy0) {
      return Field2._getWeekRangeByLocalDate(date2.withDayOfYear(180).minusYears(1)).maximum();
    }
    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
    if (week === 53) {
      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date2.isLeapYear()) === false) {
        week = 1;
      }
    }
    return week;
  };
  Field2._getWeekBasedYear = function _getWeekBasedYear(date2) {
    var year = date2.year();
    var doy = date2.dayOfYear();
    if (doy <= 3) {
      var dow = date2.dayOfWeek().ordinal();
      if (doy - dow < -2) {
        year--;
      }
    } else if (doy >= 363) {
      var _dow = date2.dayOfWeek().ordinal();
      doy = doy - 363 - (date2.isLeapYear() ? 1 : 0);
      if (doy - _dow >= 0) {
        year++;
      }
    }
    return year;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.resolve = function resolve() {
    return null;
  };
  _proto.name = function name2() {
    return this.toString();
  };
  return Field2;
}(TemporalField);
var DAY_OF_QUARTER_FIELD = function(_Field) {
  _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
  function DAY_OF_QUARTER_FIELD2() {
    return _Field.apply(this, arguments) || this;
  }
  var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
  _proto2.toString = function toString4() {
    return "DayOfQuarter";
  };
  _proto2.baseUnit = function baseUnit() {
    return ChronoUnit.DAYS;
  };
  _proto2.rangeUnit = function rangeUnit() {
    return QUARTER_YEARS;
  };
  _proto2.range = function range2() {
    return ValueRange.of(1, 90, 92);
  };
  _proto2.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
  };
  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
    }
    var qoy = temporal.getLong(QUARTER_OF_YEAR);
    if (qoy === 1) {
      var year = temporal.getLong(ChronoField.YEAR);
      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
    } else if (qoy === 2) {
      return ValueRange.of(1, 91);
    } else if (qoy === 3 || qoy === 4) {
      return ValueRange.of(1, 92);
    }
    return this.range();
  };
  _proto2.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
    }
    var doy = temporal.get(ChronoField.DAY_OF_YEAR);
    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
    var year = temporal.getLong(ChronoField.YEAR);
    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
  };
  _proto2.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
  };
  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var yearLong = fieldValues.get(ChronoField.YEAR);
    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
    if (yearLong == null || qoyLong == null) {
      return null;
    }
    var y = ChronoField.YEAR.checkValidIntValue(yearLong);
    var doq = fieldValues.get(DAY_OF_QUARTER);
    var date2;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var qoy = qoyLong;
      date2 = LocalDate.of(y, 1, 1);
      date2 = date2.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
      date2 = date2.plusDays(MathUtil.safeSubtract(doq, 1));
    } else {
      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
      if (resolverStyle === ResolverStyle.STRICT) {
        var max2 = 92;
        if (_qoy === 1) {
          max2 = IsoChronology.isLeapYear(y) ? 91 : 90;
        } else if (_qoy === 2) {
          max2 = 91;
        }
        ValueRange.of(1, max2).checkValidValue(doq, this);
      } else {
        this.range().checkValidValue(doq, this);
      }
      date2 = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
    }
    fieldValues.remove(this);
    fieldValues.remove(ChronoField.YEAR);
    fieldValues.remove(QUARTER_OF_YEAR);
    return date2;
  };
  return DAY_OF_QUARTER_FIELD2;
}(Field);
var QUARTER_OF_YEAR_FIELD = function(_Field2) {
  _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
  function QUARTER_OF_YEAR_FIELD2() {
    return _Field2.apply(this, arguments) || this;
  }
  var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
  _proto3.toString = function toString4() {
    return "QuarterOfYear";
  };
  _proto3.baseUnit = function baseUnit() {
    return QUARTER_YEARS;
  };
  _proto3.rangeUnit = function rangeUnit() {
    return ChronoUnit.YEARS;
  };
  _proto3.range = function range2() {
    return ValueRange.of(1, 4);
  };
  _proto3.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
  };
  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return this.range();
  };
  _proto3.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
    }
    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
    return MathUtil.intDiv(moy + 2, 3);
  };
  _proto3.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
  };
  return QUARTER_OF_YEAR_FIELD2;
}(Field);
var WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
  function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
    return _Field3.apply(this, arguments) || this;
  }
  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
  _proto4.toString = function toString4() {
    return "WeekOfWeekBasedYear";
  };
  _proto4.baseUnit = function baseUnit() {
    return ChronoUnit.WEEKS;
  };
  _proto4.rangeUnit = function rangeUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto4.range = function range2() {
    return ValueRange.of(1, 52, 53);
  };
  _proto4.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
    }
    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
  };
  _proto4.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
    }
    return Field._getWeek(LocalDate.from(temporal));
  };
  _proto4.adjustInto = function adjustInto(temporal, newValue) {
    this.range().checkValidValue(newValue, this);
    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
  };
  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
    if (wbyLong == null || dowLong == null) {
      return null;
    }
    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
    var date2;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var dow = dowLong;
      var weeks = 0;
      if (dow > 7) {
        weeks = MathUtil.intDiv(dow - 1, 7);
        dow = MathUtil.intMod(dow - 1, 7) + 1;
      } else if (dow < 1) {
        weeks = MathUtil.intDiv(dow, 7) - 1;
        dow = MathUtil.intMod(dow, 7) + 7;
      }
      date2 = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
    } else {
      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
      if (resolverStyle === ResolverStyle.STRICT) {
        var temp = LocalDate.of(wby, 1, 4);
        var range2 = Field._getWeekRangeByLocalDate(temp);
        range2.checkValidValue(wowby, this);
      } else {
        this.range().checkValidValue(wowby, this);
      }
      date2 = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
    }
    fieldValues.remove(this);
    fieldValues.remove(WEEK_BASED_YEAR);
    fieldValues.remove(ChronoField.DAY_OF_WEEK);
    return date2;
  };
  _proto4.displayName = function displayName() {
    return "Week";
  };
  return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
}(Field);
var WEEK_BASED_YEAR_FIELD = function(_Field4) {
  _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
  function WEEK_BASED_YEAR_FIELD2() {
    return _Field4.apply(this, arguments) || this;
  }
  var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
  _proto5.toString = function toString4() {
    return "WeekBasedYear";
  };
  _proto5.baseUnit = function baseUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto5.rangeUnit = function rangeUnit() {
    return ChronoUnit.FOREVER;
  };
  _proto5.range = function range2() {
    return ChronoField.YEAR.range();
  };
  _proto5.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return ChronoField.YEAR.range();
  };
  _proto5.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
    }
    return Field._getWeekBasedYear(LocalDate.from(temporal));
  };
  _proto5.adjustInto = function adjustInto(temporal, newValue) {
    if (this.isSupportedBy(temporal) === false) {
      throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
    }
    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
    var date2 = LocalDate.from(temporal);
    var dow = date2.get(ChronoField.DAY_OF_WEEK);
    var week = Field._getWeek(date2);
    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
      week = 52;
    }
    var resolved = LocalDate.of(newWby, 1, 4);
    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
    resolved = resolved.plusDays(days);
    return temporal.with(resolved);
  };
  return WEEK_BASED_YEAR_FIELD2;
}(Field);
var Unit = function(_TemporalUnit) {
  _inheritsLoose(Unit2, _TemporalUnit);
  function Unit2(name2, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name2;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto6 = Unit2.prototype;
  _proto6.duration = function duration2() {
    return this._duration;
  };
  _proto6.isDurationEstimated = function isDurationEstimated() {
    return true;
  };
  _proto6.isDateBased = function isDateBased() {
    return true;
  };
  _proto6.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto6.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY);
  };
  _proto6.addTo = function addTo(temporal, periodToAdd) {
    switch (this) {
      case WEEK_BASED_YEARS: {
        var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
        return temporal.with(WEEK_BASED_YEAR, added);
      }
      case QUARTER_YEARS:
        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
      default:
        throw new IllegalStateException("Unreachable");
    }
  };
  _proto6.between = function between(temporal1, temporal2) {
    switch (this) {
      case WEEK_BASED_YEARS:
        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
      case QUARTER_YEARS:
        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
      default:
        throw new IllegalStateException("Unreachable");
    }
  };
  _proto6.toString = function toString4() {
    return this._name;
  };
  return Unit2;
}(TemporalUnit);
var DAY_OF_QUARTER = null;
var QUARTER_OF_YEAR = null;
var WEEK_OF_WEEK_BASED_YEAR = null;
var WEEK_BASED_YEAR = null;
var WEEK_BASED_YEARS = null;
var QUARTER_YEARS = null;
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function() {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function() {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DecimalStyle = function() {
  function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
    this._zeroDigit = zeroChar;
    this._zeroDigitCharCode = zeroChar.charCodeAt(0);
    this._positiveSign = positiveSignChar;
    this._negativeSign = negativeSignChar;
    this._decimalSeparator = decimalPointChar;
  }
  var _proto = DecimalStyle2.prototype;
  _proto.positiveSign = function positiveSign() {
    return this._positiveSign;
  };
  _proto.withPositiveSign = function withPositiveSign(positiveSign) {
    if (positiveSign === this._positiveSign) {
      return this;
    }
    return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.negativeSign = function negativeSign() {
    return this._negativeSign;
  };
  _proto.withNegativeSign = function withNegativeSign(negativeSign) {
    if (negativeSign === this._negativeSign) {
      return this;
    }
    return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
  };
  _proto.zeroDigit = function zeroDigit() {
    return this._zeroDigit;
  };
  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
    if (zeroDigit === this._zeroDigit) {
      return this;
    }
    return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.decimalSeparator = function decimalSeparator() {
    return this._decimalSeparator;
  };
  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
    if (decimalSeparator === this._decimalSeparator) {
      return this;
    }
    return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
  };
  _proto.convertToDigit = function convertToDigit(char2) {
    var val = char2.charCodeAt(0) - this._zeroDigitCharCode;
    return val >= 0 && val <= 9 ? val : -1;
  };
  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
    if (this._zeroDigit === "0") {
      return numericText;
    }
    var diff2 = this._zeroDigitCharCode - "0".charCodeAt(0);
    var convertedText = "";
    for (var i = 0; i < numericText.length; i++) {
      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff2);
    }
    return convertedText;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof DecimalStyle2) {
      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
  };
  _proto.toString = function toString4() {
    return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
  };
  DecimalStyle2.of = function of() {
    throw new Error("not yet supported");
  };
  DecimalStyle2.availableLocales = function availableLocales() {
    throw new Error("not yet supported");
  };
  return DecimalStyle2;
}();
DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
var SignStyle = function(_Enum) {
  _inheritsLoose(SignStyle2, _Enum);
  function SignStyle2() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SignStyle2.prototype;
  _proto.parse = function parse2(positive, strict, fixedWidth) {
    switch (this) {
      case SignStyle2.NORMAL:
        return !positive || !strict;
      case SignStyle2.ALWAYS:
      case SignStyle2.EXCEEDS_PAD:
        return true;
      default:
        return !strict && !fixedWidth;
    }
  };
  return SignStyle2;
}(Enum);
SignStyle.NORMAL = new SignStyle("NORMAL");
SignStyle.NEVER = new SignStyle("NEVER");
SignStyle.ALWAYS = new SignStyle("ALWAYS");
SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
var TextStyle = function(_Enum) {
  _inheritsLoose(TextStyle2, _Enum);
  function TextStyle2() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TextStyle2.prototype;
  _proto.isStandalone = function isStandalone() {
    switch (this) {
      case TextStyle2.FULL_STANDALONE:
      case TextStyle2.SHORT_STANDALONE:
      case TextStyle2.NARROW_STANDALONE:
        return true;
      default:
        return false;
    }
  };
  _proto.asStandalone = function asStandalone() {
    switch (this) {
      case TextStyle2.FULL:
        return TextStyle2.FULL_STANDALONE;
      case TextStyle2.SHORT:
        return TextStyle2.SHORT_STANDALONE;
      case TextStyle2.NARROW:
        return TextStyle2.NARROW_STANDALONE;
      default:
        return this;
    }
  };
  _proto.asNormal = function asNormal() {
    switch (this) {
      case TextStyle2.FULL_STANDALONE:
        return TextStyle2.FULL;
      case TextStyle2.SHORT_STANDALONE:
        return TextStyle2.SHORT;
      case TextStyle2.NARROW_STANDALONE:
        return TextStyle2.NARROW;
      default:
        return this;
    }
  };
  return TextStyle2;
}(Enum);
TextStyle.FULL = new TextStyle("FULL");
TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
TextStyle.SHORT = new TextStyle("SHORT");
TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
TextStyle.NARROW = new TextStyle("NARROW");
TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var CharLiteralPrinterParser = function() {
  function CharLiteralPrinterParser2(literal) {
    if (literal.length > 1) {
      throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
    }
    this._literal = literal;
  }
  var _proto = CharLiteralPrinterParser2.prototype;
  _proto.print = function print(context2, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var length = text2.length;
    if (position === length) {
      return ~position;
    }
    var ch = text2.charAt(position);
    if (context2.charEquals(this._literal, ch) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString4() {
    if (this._literal === "'") {
      return "''";
    }
    return "'" + this._literal + "'";
  };
  return CharLiteralPrinterParser2;
}();
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var CompositePrinterParser = function() {
  function CompositePrinterParser2(printerParsers, optional) {
    this._printerParsers = printerParsers;
    this._optional = optional;
  }
  var _proto = CompositePrinterParser2.prototype;
  _proto.withOptional = function withOptional(optional) {
    if (optional === this._optional) {
      return this;
    }
    return new CompositePrinterParser2(this._printerParsers, optional);
  };
  _proto.print = function print(context2, buf) {
    var length = buf.length();
    if (this._optional) {
      context2.startOptional();
    }
    try {
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        if (pp.print(context2, buf) === false) {
          buf.setLength(length);
          return true;
        }
      }
    } finally {
      if (this._optional) {
        context2.endOptional();
      }
    }
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    if (this._optional) {
      context2.startOptional();
      var pos = position;
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        pos = pp.parse(context2, text2, pos);
        if (pos < 0) {
          context2.endOptional(false);
          return position;
        }
      }
      context2.endOptional(true);
      return pos;
    } else {
      for (var _i = 0; _i < this._printerParsers.length; _i++) {
        var _pp = this._printerParsers[_i];
        position = _pp.parse(context2, text2, position);
        if (position < 0) {
          break;
        }
      }
      return position;
    }
  };
  _proto.toString = function toString4() {
    var buf = "";
    if (this._printerParsers != null) {
      buf += this._optional ? "[" : "(";
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        buf += pp.toString();
      }
      buf += this._optional ? "]" : ")";
    }
    return buf;
  };
  return CompositePrinterParser2;
}();
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var FractionPrinterParser = function() {
  function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
    requireNonNull(field, "field");
    if (field.range().isFixed() === false) {
      throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
    }
    if (minWidth < 0 || minWidth > 9) {
      throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > 9) {
      throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    this.field = field;
    this.minWidth = minWidth;
    this.maxWidth = maxWidth;
    this.decimalPoint = decimalPoint;
  }
  var _proto = FractionPrinterParser2.prototype;
  _proto.print = function print(context2, buf) {
    var value = context2.getValue(this.field);
    if (value === null) {
      return false;
    }
    var symbols = context2.symbols();
    if (value === 0) {
      if (this.minWidth > 0) {
        if (this.decimalPoint) {
          buf.append(symbols.decimalSeparator());
        }
        for (var i = 0; i < this.minWidth; i++) {
          buf.append(symbols.zeroDigit());
        }
      }
    } else {
      var fraction = this.convertToFraction(value, symbols.zeroDigit());
      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
      fraction = fraction.substr(0, outputScale);
      if (fraction * 1 > 0) {
        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
          fraction = fraction.substr(0, fraction.length - 1);
        }
      }
      var str = fraction;
      str = symbols.convertNumberToI18N(str);
      if (this.decimalPoint) {
        buf.append(symbols.decimalSeparator());
      }
      buf.append(str);
    }
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var effectiveMin = context2.isStrict() ? this.minWidth : 0;
    var effectiveMax = context2.isStrict() ? this.maxWidth : 9;
    var length = text2.length;
    if (position === length) {
      return effectiveMin > 0 ? ~position : position;
    }
    if (this.decimalPoint) {
      if (text2[position] !== context2.symbols().decimalSeparator()) {
        return effectiveMin > 0 ? ~position : position;
      }
      position++;
    }
    var minEndPos = position + effectiveMin;
    if (minEndPos > length) {
      return ~position;
    }
    var maxEndPos = Math.min(position + effectiveMax, length);
    var total = 0;
    var pos = position;
    while (pos < maxEndPos) {
      var ch = text2.charAt(pos++);
      var digit = context2.symbols().convertToDigit(ch);
      if (digit < 0) {
        if (pos < minEndPos) {
          return ~position;
        }
        pos--;
        break;
      }
      total = total * 10 + digit;
    }
    var moveLeft = pos - position;
    var scale = Math.pow(10, moveLeft);
    var value = this.convertFromFraction(total, scale);
    return context2.setParsedField(this.field, value, position, pos);
  };
  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
    var range2 = this.field.range();
    range2.checkValidValue(value, this.field);
    var _min = range2.minimum();
    var _range = range2.maximum() - _min + 1;
    var _value = value - _min;
    var _scaled = MathUtil.intDiv(_value * 1e9, _range);
    var fraction = "" + _scaled;
    while (fraction.length < 9) {
      fraction = zeroDigit + fraction;
    }
    return fraction;
  };
  _proto.convertFromFraction = function convertFromFraction(total, scale) {
    var range2 = this.field.range();
    var _min = range2.minimum();
    var _range = range2.maximum() - _min + 1;
    var _value = MathUtil.intDiv(total * _range, scale);
    return _value;
  };
  _proto.toString = function toString4() {
    var decimal2 = this.decimalPoint ? ",DecimalPoint" : "";
    return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal2 + ")";
  };
  return FractionPrinterParser2;
}();
var MAX_WIDTH$1 = 15;
var EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
var NumberPrinterParser = function() {
  function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
    if (subsequentWidth === void 0) {
      subsequentWidth = 0;
    }
    this._field = field;
    this._minWidth = minWidth;
    this._maxWidth = maxWidth;
    this._signStyle = signStyle;
    this._subsequentWidth = subsequentWidth;
  }
  var _proto = NumberPrinterParser2.prototype;
  _proto.field = function field() {
    return this._field;
  };
  _proto.minWidth = function minWidth() {
    return this._minWidth;
  };
  _proto.maxWidth = function maxWidth() {
    return this._maxWidth;
  };
  _proto.signStyle = function signStyle() {
    return this._signStyle;
  };
  _proto.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
  };
  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
  };
  _proto._isFixedWidth = function _isFixedWidth() {
    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
  };
  _proto.print = function print(context2, buf) {
    var contextValue = context2.getValue(this._field);
    if (contextValue == null) {
      return false;
    }
    var value = this._getValue(context2, contextValue);
    var symbols = context2.symbols();
    var str = "" + Math.abs(value);
    if (str.length > this._maxWidth) {
      throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
    }
    str = symbols.convertNumberToI18N(str);
    if (value >= 0) {
      switch (this._signStyle) {
        case SignStyle.EXCEEDS_PAD:
          if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
            buf.append(symbols.positiveSign());
          }
          break;
        case SignStyle.ALWAYS:
          buf.append(symbols.positiveSign());
          break;
      }
    } else {
      switch (this._signStyle) {
        case SignStyle.NORMAL:
        case SignStyle.EXCEEDS_PAD:
        case SignStyle.ALWAYS:
          buf.append(symbols.negativeSign());
          break;
        case SignStyle.NOT_NEGATIVE:
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
      }
    }
    for (var i = 0; i < this._minWidth - str.length; i++) {
      buf.append(symbols.zeroDigit());
    }
    buf.append(str);
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var length = text2.length;
    if (position === length) {
      return ~position;
    }
    assert(position >= 0 && position < length);
    var sign4 = text2.charAt(position);
    var negative = false;
    var positive = false;
    if (sign4 === context2.symbols().positiveSign()) {
      if (this._signStyle.parse(true, context2.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      positive = true;
      position++;
    } else if (sign4 === context2.symbols().negativeSign()) {
      if (this._signStyle.parse(false, context2.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      negative = true;
      position++;
    } else {
      if (this._signStyle === SignStyle.ALWAYS && context2.isStrict()) {
        return ~position;
      }
    }
    var effMinWidth = context2.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
    var minEndPos = position + effMinWidth;
    if (minEndPos > length) {
      return ~position;
    }
    var effMaxWidth = (context2.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
    var total = 0;
    var pos = position;
    for (var pass = 0; pass < 2; pass++) {
      var maxEndPos = Math.min(pos + effMaxWidth, length);
      while (pos < maxEndPos) {
        var ch = text2.charAt(pos++);
        var digit = context2.symbols().convertToDigit(ch);
        if (digit < 0) {
          pos--;
          if (pos < minEndPos) {
            return ~position;
          }
          break;
        }
        if (pos - position > MAX_WIDTH$1) {
          throw new ArithmeticException("number text exceeds length");
        } else {
          total = total * 10 + digit;
        }
      }
      if (this._subsequentWidth > 0 && pass === 0) {
        var parseLen = pos - position;
        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
        pos = position;
        total = 0;
      } else {
        break;
      }
    }
    if (negative) {
      if (total === 0 && context2.isStrict()) {
        return ~(position - 1);
      }
      if (total !== 0) {
        total = -total;
      }
    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context2.isStrict()) {
      var _parseLen = pos - position;
      if (positive) {
        if (_parseLen <= this._minWidth) {
          return ~(position - 1);
        }
      } else {
        if (_parseLen > this._minWidth) {
          return ~position;
        }
      }
    }
    return this._setValue(context2, total, position, pos);
  };
  _proto._getValue = function _getValue(context2, value) {
    return value;
  };
  _proto._setValue = function _setValue(context2, value, errorPos, successPos) {
    return context2.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto.toString = function toString4() {
    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
      return "Value(" + this._field + ")";
    }
    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
      return "Value(" + this._field + "," + this._minWidth + ")";
    }
    return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
  };
  return NumberPrinterParser2;
}();
var ReducedPrinterParser = function(_NumberPrinterParser) {
  _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
  function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
    var _this;
    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
    if (width < 1 || width > 10) {
      throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
    }
    if (maxWidth < 1 || maxWidth > 10) {
      throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
    }
    if (maxWidth < width) {
      throw new IllegalArgumentException("The maxWidth must be greater than the width");
    }
    if (baseDate === null) {
      if (field.range().isValidValue(baseValue) === false) {
        throw new IllegalArgumentException("The base value must be within the range of the field");
      }
      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
        throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
      }
    }
    _this._baseValue = baseValue;
    _this._baseDate = baseDate;
    return _this;
  }
  var _proto2 = ReducedPrinterParser2.prototype;
  _proto2._getValue = function _getValue(context2, value) {
    var absValue = Math.abs(value);
    var baseValue = this._baseValue;
    if (this._baseDate !== null) {
      context2.temporal();
      var chrono = IsoChronology.INSTANCE;
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
      return absValue % EXCEED_POINTS[this._minWidth];
    }
    return absValue % EXCEED_POINTS[this._maxWidth];
  };
  _proto2._setValue = function _setValue(context2, value, errorPos, successPos) {
    var baseValue = this._baseValue;
    if (this._baseDate != null) {
      var chrono = context2.getEffectiveChronology();
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    var parseLen = successPos - errorPos;
    if (parseLen === this._minWidth && value >= 0) {
      var range2 = EXCEED_POINTS[this._minWidth];
      var lastPart = baseValue % range2;
      var basePart = baseValue - lastPart;
      if (baseValue > 0) {
        value = basePart + value;
      } else {
        value = basePart - value;
      }
      if (value < baseValue) {
        value += range2;
      }
    }
    return context2.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto2.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
  };
  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
  };
  _proto2.isFixedWidth = function isFixedWidth(context2) {
    if (context2.isStrict() === false) {
      return false;
    }
    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context2);
  };
  _proto2.toString = function toString4() {
    return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
  };
  return ReducedPrinterParser2;
}(NumberPrinterParser);
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
var OffsetIdPrinterParser = function() {
  function OffsetIdPrinterParser2(noOffsetText, pattern) {
    requireNonNull(noOffsetText, "noOffsetText");
    requireNonNull(pattern, "pattern");
    this.noOffsetText = noOffsetText;
    this.type = this._checkPattern(pattern);
  }
  var _proto = OffsetIdPrinterParser2.prototype;
  _proto._checkPattern = function _checkPattern(pattern) {
    for (var i = 0; i < PATTERNS.length; i++) {
      if (PATTERNS[i] === pattern) {
        return i;
      }
    }
    throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
  };
  _proto.print = function print(context2, buf) {
    var offsetSecs = context2.getValue(ChronoField.OFFSET_SECONDS);
    if (offsetSecs == null) {
      return false;
    }
    var totalSecs = MathUtil.safeToInt(offsetSecs);
    if (totalSecs === 0) {
      buf.append(this.noOffsetText);
    } else {
      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
      var bufPos = buf.length();
      var output = absHours;
      buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
        buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
        output += absMinutes;
        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
          buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
          output += absSeconds;
        }
      }
      if (output === 0) {
        buf.setLength(bufPos);
        buf.append(this.noOffsetText);
      }
    }
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var length = text2.length;
    var noOffsetLen = this.noOffsetText.length;
    if (noOffsetLen === 0) {
      if (position === length) {
        return context2.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
      }
    } else {
      if (position === length) {
        return ~position;
      }
      if (context2.subSequenceEquals(text2, position, this.noOffsetText, 0, noOffsetLen)) {
        return context2.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
      }
    }
    var sign4 = text2[position];
    if (sign4 === "+" || sign4 === "-") {
      var negative = sign4 === "-" ? -1 : 1;
      var array = [0, 0, 0, 0];
      array[0] = position + 1;
      if ((this._parseNumber(array, 1, text2, true) || this._parseNumber(array, 2, text2, this.type >= 3) || this._parseNumber(array, 3, text2, false)) === false) {
        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
        return context2.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
      }
    }
    if (noOffsetLen === 0) {
      return context2.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
    }
    return ~position;
  };
  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
    if ((this.type + 3) / 2 < arrayIndex) {
      return false;
    }
    var pos = array[0];
    if (this.type % 2 === 0 && arrayIndex > 1) {
      if (pos + 1 > parseText.length || parseText[pos] !== ":") {
        return required;
      }
      pos++;
    }
    if (pos + 2 > parseText.length) {
      return required;
    }
    var ch1 = parseText[pos++];
    var ch2 = parseText[pos++];
    if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
      return required;
    }
    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
    if (value < 0 || value > 59) {
      return required;
    }
    array[arrayIndex] = value;
    array[0] = pos;
    return false;
  };
  _proto.toString = function toString4() {
    var converted = this.noOffsetText.replace("'", "''");
    return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
  };
  return OffsetIdPrinterParser2;
}();
OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
OffsetIdPrinterParser.PATTERNS = PATTERNS;
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PadPrinterParserDecorator = function() {
  function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
    this._printerParser = printerParser;
    this._padWidth = padWidth;
    this._padChar = padChar;
  }
  var _proto = PadPrinterParserDecorator2.prototype;
  _proto.print = function print(context2, buf) {
    var preLen = buf.length();
    if (this._printerParser.print(context2, buf) === false) {
      return false;
    }
    var len = buf.length() - preLen;
    if (len > this._padWidth) {
      throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
    }
    for (var i = 0; i < this._padWidth - len; i++) {
      buf.insert(preLen, this._padChar);
    }
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var strict = context2.isStrict();
    var caseSensitive = context2.isCaseSensitive();
    assert(!(position > text2.length));
    assert(position >= 0);
    if (position === text2.length) {
      return ~position;
    }
    var endPos = position + this._padWidth;
    if (endPos > text2.length) {
      if (strict) {
        return ~position;
      }
      endPos = text2.length;
    }
    var pos = position;
    while (pos < endPos && (caseSensitive ? text2[pos] === this._padChar : context2.charEquals(text2[pos], this._padChar))) {
      pos++;
    }
    text2 = text2.substring(0, endPos);
    var resultPos = this._printerParser.parse(context2, text2, pos);
    if (resultPos !== endPos && strict) {
      return ~(position + pos);
    }
    return resultPos;
  };
  _proto.toString = function toString4() {
    return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
  };
  return PadPrinterParserDecorator2;
}();
var SettingsParser = function(_Enum) {
  _inheritsLoose(SettingsParser2, _Enum);
  function SettingsParser2() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SettingsParser2.prototype;
  _proto.print = function print() {
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    switch (this) {
      case SettingsParser2.SENSITIVE:
        context2.setCaseSensitive(true);
        break;
      case SettingsParser2.INSENSITIVE:
        context2.setCaseSensitive(false);
        break;
      case SettingsParser2.STRICT:
        context2.setStrict(true);
        break;
      case SettingsParser2.LENIENT:
        context2.setStrict(false);
        break;
    }
    return position;
  };
  _proto.toString = function toString4() {
    switch (this) {
      case SettingsParser2.SENSITIVE:
        return "ParseCaseSensitive(true)";
      case SettingsParser2.INSENSITIVE:
        return "ParseCaseSensitive(false)";
      case SettingsParser2.STRICT:
        return "ParseStrict(true)";
      case SettingsParser2.LENIENT:
        return "ParseStrict(false)";
    }
  };
  return SettingsParser2;
}(Enum);
SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
SettingsParser.STRICT = new SettingsParser("STRICT");
SettingsParser.LENIENT = new SettingsParser("LENIENT");
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringLiteralPrinterParser = function() {
  function StringLiteralPrinterParser2(literal) {
    this._literal = literal;
  }
  var _proto = StringLiteralPrinterParser2.prototype;
  _proto.print = function print(context2, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var length = text2.length;
    assert(!(position > length || position < 0));
    if (context2.subSequenceEquals(text2, position, this._literal, 0, this._literal.length) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString4() {
    var converted = this._literal.replace("'", "''");
    return "'" + converted + "'";
  };
  return StringLiteralPrinterParser2;
}();
/*
 * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneRulesProvider = function() {
  function ZoneRulesProvider2() {
  }
  ZoneRulesProvider2.getRules = function getRules(zoneId) {
    throw new DateTimeException("unsupported ZoneId:" + zoneId);
  };
  ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
    return [];
  };
  return ZoneRulesProvider2;
}();
var ZoneRegion = function(_ZoneId) {
  _inheritsLoose(ZoneRegion2, _ZoneId);
  ZoneRegion2.ofId = function ofId(zoneId) {
    var rules = ZoneRulesProvider.getRules(zoneId);
    return new ZoneRegion2(zoneId, rules);
  };
  function ZoneRegion2(id, rules) {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._id = id;
    _this._rules = rules;
    return _this;
  }
  var _proto = ZoneRegion2.prototype;
  _proto.id = function id() {
    return this._id;
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  return ZoneRegion2;
}(ZoneId);
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdPrinterParser = function() {
  function ZoneIdPrinterParser2(query, description) {
    this.query = query;
    this.description = description;
  }
  var _proto = ZoneIdPrinterParser2.prototype;
  _proto.print = function print(context2, buf) {
    var zone = context2.getValueQuery(this.query);
    if (zone == null) {
      return false;
    }
    buf.append(zone.id());
    return true;
  };
  _proto.parse = function parse2(context2, text2, position) {
    var length = text2.length;
    if (position > length) {
      return ~position;
    }
    if (position === length) {
      return ~position;
    }
    var nextChar = text2.charAt(position);
    if (nextChar === "+" || nextChar === "-") {
      var newContext = context2.copy();
      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text2, position);
      if (endPos < 0) {
        return endPos;
      }
      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
      var zone = ZoneOffset.ofTotalSeconds(offset);
      context2.setParsedZone(zone);
      return endPos;
    } else if (length >= position + 2) {
      var nextNextChar = text2.charAt(position + 1);
      if (context2.charEquals(nextChar, "U") && context2.charEquals(nextNextChar, "T")) {
        if (length >= position + 3 && context2.charEquals(text2.charAt(position + 2), "C")) {
          return this._parsePrefixedOffset(context2, text2, position, position + 3);
        }
        return this._parsePrefixedOffset(context2, text2, position, position + 2);
      } else if (context2.charEquals(nextChar, "G") && length >= position + 3 && context2.charEquals(nextNextChar, "M") && context2.charEquals(text2.charAt(position + 2), "T")) {
        return this._parsePrefixedOffset(context2, text2, position, position + 3);
      }
    }
    if (text2.substr(position, 6) === "SYSTEM") {
      context2.setParsedZone(ZoneId.systemDefault());
      return position + 6;
    }
    if (context2.charEquals(nextChar, "Z")) {
      context2.setParsedZone(ZoneOffset.UTC);
      return position + 1;
    }
    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
    if (zoneIdTree.size !== availableZoneIds.length) {
      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
    }
    var maxParseLength = length - position;
    var treeMap = zoneIdTree.treeMap;
    var parsedZoneId = null;
    var parseLength = 0;
    while (treeMap != null) {
      var parsedSubZoneId = text2.substr(position, Math.min(treeMap.length, maxParseLength));
      treeMap = treeMap.get(parsedSubZoneId);
      if (treeMap != null && treeMap.isLeaf) {
        parsedZoneId = parsedSubZoneId;
        parseLength = treeMap.length;
      }
    }
    if (parsedZoneId != null) {
      context2.setParsedZone(ZoneRegion.ofId(parsedZoneId));
      return position + parseLength;
    }
    return ~position;
  };
  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context2, text2, prefixPos, position) {
    var prefix = text2.substring(prefixPos, position).toUpperCase();
    var newContext = context2.copy();
    if (position < text2.length && context2.charEquals(text2.charAt(position), "Z")) {
      context2.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text2, position);
    if (endPos < 0) {
      context2.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
    context2.setParsedZone(ZoneId.ofOffset(prefix, offset));
    return endPos;
  };
  _proto.toString = function toString4() {
    return this.description;
  };
  return ZoneIdPrinterParser2;
}();
var ZoneIdTree = function() {
  ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
    var sortedZoneIds = availableZoneIds.sort(function(a, b) {
      return a.length - b.length;
    });
    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
    for (var i = 0; i < sortedZoneIds.length; i++) {
      treeMap.add(sortedZoneIds[i]);
    }
    return new ZoneIdTree2(sortedZoneIds.length, treeMap);
  };
  function ZoneIdTree2(size, treeMap) {
    this.size = size;
    this.treeMap = treeMap;
  }
  return ZoneIdTree2;
}();
var ZoneIdTreeMap = function() {
  function ZoneIdTreeMap2(length, isLeaf) {
    if (length === void 0) {
      length = 0;
    }
    if (isLeaf === void 0) {
      isLeaf = false;
    }
    this.length = length;
    this.isLeaf = isLeaf;
    this._treeMap = {};
  }
  var _proto2 = ZoneIdTreeMap2.prototype;
  _proto2.add = function add(zoneId) {
    var idLength = zoneId.length;
    if (idLength === this.length) {
      this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
    } else if (idLength > this.length) {
      var subZoneId = zoneId.substr(0, this.length);
      var subTreeMap = this._treeMap[subZoneId];
      if (subTreeMap == null) {
        subTreeMap = new ZoneIdTreeMap2(idLength, false);
        this._treeMap[subZoneId] = subTreeMap;
      }
      subTreeMap.add(zoneId);
    }
  };
  _proto2.get = function get3(zoneId) {
    return this._treeMap[zoneId];
  };
  return ZoneIdTreeMap2;
}();
var zoneIdTree = new ZoneIdTree([]);
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_WIDTH = 15;
var DateTimeFormatterBuilder = function() {
  function DateTimeFormatterBuilder2() {
    this._active = this;
    this._parent = null;
    this._printerParsers = [];
    this._optional = false;
    this._padNextWidth = 0;
    this._padNextChar = null;
    this._valueParserIndex = -1;
  }
  DateTimeFormatterBuilder2._of = function _of(parent, optional) {
    requireNonNull(parent, "parent");
    requireNonNull(optional, "optional");
    var dtFormatterBuilder = new DateTimeFormatterBuilder2();
    dtFormatterBuilder._parent = parent;
    dtFormatterBuilder._optional = optional;
    return dtFormatterBuilder;
  };
  var _proto = DateTimeFormatterBuilder2.prototype;
  _proto.parseCaseSensitive = function parseCaseSensitive() {
    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
    return this;
  };
  _proto.parseCaseInsensitive = function parseCaseInsensitive() {
    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
    return this;
  };
  _proto.parseStrict = function parseStrict() {
    this._appendInternalPrinterParser(SettingsParser.STRICT);
    return this;
  };
  _proto.parseLenient = function parseLenient() {
    this._appendInternalPrinterParser(SettingsParser.LENIENT);
    return this;
  };
  _proto.parseDefaulting = function parseDefaulting(field, value) {
    requireNonNull(field);
    this._appendInternal(new DefaultingParser(field, value));
    return this;
  };
  _proto.appendValue = function appendValue() {
    if (arguments.length === 1) {
      return this._appendValue1.apply(this, arguments);
    } else if (arguments.length === 2) {
      return this._appendValue2.apply(this, arguments);
    } else {
      return this._appendValue4.apply(this, arguments);
    }
  };
  _proto._appendValue1 = function _appendValue1(field) {
    requireNonNull(field);
    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
    return this;
  };
  _proto._appendValue2 = function _appendValue2(field, width) {
    requireNonNull(field);
    if (width < 1 || width > MAX_WIDTH) {
      throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
    }
    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
    requireNonNull(field);
    requireNonNull(signStyle);
    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
      return this._appendValue2(field, maxWidth);
    }
    if (minWidth < 1 || minWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto.appendValueReduced = function appendValueReduced() {
    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
    } else {
      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
    }
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
    requireNonNull(field, "field");
    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
    requireNonNull(field, "field");
    requireNonNull(baseDate, "baseDate");
    requireInstance(baseDate, ChronoLocalDate, "baseDate");
    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
    assert(pp != null);
    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
      var activeValueParser = this._active._valueParserIndex;
      var basePP = this._active._printerParsers[activeValueParser];
      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
        basePP = basePP.withSubsequentWidth(pp.maxWidth());
        this._appendInternal(pp.withFixedWidth());
        this._active._valueParserIndex = activeValueParser;
      } else {
        basePP = basePP.withFixedWidth();
        this._active._valueParserIndex = this._appendInternal(pp);
      }
      this._active._printerParsers[activeValueParser] = basePP;
    } else {
      this._active._valueParserIndex = this._appendInternal(pp);
    }
    return this;
  };
  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
    return this;
  };
  _proto.appendInstant = function appendInstant(fractionalDigits) {
    if (fractionalDigits === void 0) {
      fractionalDigits = -2;
    }
    if (fractionalDigits < -2 || fractionalDigits > 9) {
      throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
    }
    this._appendInternal(new InstantPrinterParser(fractionalDigits));
    return this;
  };
  _proto.appendOffsetId = function appendOffsetId() {
    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
    return this;
  };
  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
    return this;
  };
  _proto.appendZoneId = function appendZoneId() {
    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
    return this;
  };
  _proto.appendPattern = function appendPattern(pattern) {
    requireNonNull(pattern, "pattern");
    this._parsePattern(pattern);
    return this;
  };
  _proto.appendZoneText = function appendZoneText() {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
  };
  _proto.appendText = function appendText() {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
  };
  _proto.appendLocalizedOffset = function appendLocalizedOffset() {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
  };
  _proto.appendWeekField = function appendWeekField() {
    throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
  };
  _proto._parsePattern = function _parsePattern(pattern) {
    var FIELD_MAP = {
      "G": ChronoField.ERA,
      "y": ChronoField.YEAR_OF_ERA,
      "u": ChronoField.YEAR,
      "Q": IsoFields.QUARTER_OF_YEAR,
      "q": IsoFields.QUARTER_OF_YEAR,
      "M": ChronoField.MONTH_OF_YEAR,
      "L": ChronoField.MONTH_OF_YEAR,
      "D": ChronoField.DAY_OF_YEAR,
      "d": ChronoField.DAY_OF_MONTH,
      "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
      "E": ChronoField.DAY_OF_WEEK,
      "c": ChronoField.DAY_OF_WEEK,
      "e": ChronoField.DAY_OF_WEEK,
      "a": ChronoField.AMPM_OF_DAY,
      "H": ChronoField.HOUR_OF_DAY,
      "k": ChronoField.CLOCK_HOUR_OF_DAY,
      "K": ChronoField.HOUR_OF_AMPM,
      "h": ChronoField.CLOCK_HOUR_OF_AMPM,
      "m": ChronoField.MINUTE_OF_HOUR,
      "s": ChronoField.SECOND_OF_MINUTE,
      "S": ChronoField.NANO_OF_SECOND,
      "A": ChronoField.MILLI_OF_DAY,
      "n": ChronoField.NANO_OF_SECOND,
      "N": ChronoField.NANO_OF_DAY
    };
    for (var pos = 0; pos < pattern.length; pos++) {
      var cur = pattern.charAt(pos);
      if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
        var start = pos++;
        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) ;
        var count = pos - start;
        if (cur === "p") {
          var pad = 0;
          if (pos < pattern.length) {
            cur = pattern.charAt(pos);
            if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
              pad = count;
              start = pos++;
              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) ;
              count = pos - start;
            }
          }
          if (pad === 0) {
            throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
          }
          this.padNext(pad);
        }
        var field = FIELD_MAP[cur];
        if (field != null) {
          this._parseField(cur, count, field);
        } else if (cur === "z") {
          if (count > 4) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          } else if (count === 4) {
            this.appendZoneText(TextStyle.FULL);
          } else {
            this.appendZoneText(TextStyle.SHORT);
          }
        } else if (cur === "V") {
          if (count !== 2) {
            throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
          }
          this.appendZoneId();
        } else if (cur === "Z") {
          if (count < 4) {
            this.appendOffset("+HHMM", "+0000");
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else if (count === 5) {
            this.appendOffset("+HH:MM:ss", "Z");
          } else {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
        } else if (cur === "O") {
          if (count === 1) {
            this.appendLocalizedOffset(TextStyle.SHORT);
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else {
            throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
          }
        } else if (cur === "X") {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
        } else if (cur === "x") {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
        } else if (cur === "W") {
          if (count > 1) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField("W", count);
        } else if (cur === "w") {
          if (count > 2) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField("w", count);
        } else if (cur === "Y") {
          this.appendWeekField("Y", count);
        } else {
          throw new IllegalArgumentException("Unknown pattern letter: " + cur);
        }
        pos--;
      } else if (cur === "'") {
        var _start = pos++;
        for (; pos < pattern.length; pos++) {
          if (pattern.charAt(pos) === "'") {
            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
              pos++;
            } else {
              break;
            }
          }
        }
        if (pos >= pattern.length) {
          throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
        }
        var str = pattern.substring(_start + 1, pos);
        if (str.length === 0) {
          this.appendLiteral("'");
        } else {
          this.appendLiteral(str.replace("''", "'"));
        }
      } else if (cur === "[") {
        this.optionalStart();
      } else if (cur === "]") {
        if (this._active._parent === null) {
          throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
        }
        this.optionalEnd();
      } else if (cur === "{" || cur === "}" || cur === "#") {
        throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
      } else {
        this.appendLiteral(cur);
      }
    }
  };
  _proto._parseField = function _parseField(cur, count, field) {
    switch (cur) {
      case "u":
      case "y":
        if (count === 2) {
          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
        } else if (count < 4) {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
        } else {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
        }
        break;
      case "M":
      case "Q":
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "L":
      case "q":
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "e":
        switch (count) {
          case 1:
          case 2:
            this.appendWeekField("e", count);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "c":
        switch (count) {
          case 1:
            this.appendWeekField("c", count);
            break;
          case 2:
            throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "a":
        if (count === 1) {
          this.appendText(field, TextStyle.SHORT);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "E":
      case "G":
        switch (count) {
          case 1:
          case 2:
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "S":
        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
        break;
      case "F":
        if (count === 1) {
          this.appendValue(field);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "d":
      case "h":
      case "H":
      case "k":
      case "K":
      case "m":
      case "s":
        if (count === 1) {
          this.appendValue(field);
        } else if (count === 2) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case "D":
        if (count === 1) {
          this.appendValue(field);
        } else if (count <= 3) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      default:
        if (count === 1) {
          this.appendValue(field);
        } else {
          this.appendValue(field, count);
        }
        break;
    }
  };
  _proto.padNext = function padNext() {
    if (arguments.length === 1) {
      return this._padNext1.apply(this, arguments);
    } else {
      return this._padNext2.apply(this, arguments);
    }
  };
  _proto._padNext1 = function _padNext1(padWidth) {
    return this._padNext2(padWidth, " ");
  };
  _proto._padNext2 = function _padNext2(padWidth, padChar) {
    if (padWidth < 1) {
      throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
    }
    this._active._padNextWidth = padWidth;
    this._active._padNextChar = padChar;
    this._active._valueParserIndex = -1;
    return this;
  };
  _proto.optionalStart = function optionalStart() {
    this._active._valueParserIndex = -1;
    this._active = DateTimeFormatterBuilder2._of(this._active, true);
    return this;
  };
  _proto.optionalEnd = function optionalEnd() {
    if (this._active._parent == null) {
      throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
    }
    if (this._active._printerParsers.length > 0) {
      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
      this._active = this._active._parent;
      this._appendInternal(cpp);
    } else {
      this._active = this._active._parent;
    }
    return this;
  };
  _proto._appendInternal = function _appendInternal(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.appendLiteral = function appendLiteral(literal) {
    assert(literal != null);
    if (literal.length > 0) {
      if (literal.length === 1) {
        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
      } else {
        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
      }
    }
    return this;
  };
  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.append = function append2(formatter) {
    requireNonNull(formatter, "formatter");
    this._appendInternal(formatter._toPrinterParser(false));
    return this;
  };
  _proto.toFormatter = function toFormatter(resolverStyle) {
    if (resolverStyle === void 0) {
      resolverStyle = ResolverStyle.SMART;
    }
    while (this._active._parent != null) {
      this.optionalEnd();
    }
    var pp = new CompositePrinterParser(this._printerParsers, false);
    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
  };
  return DateTimeFormatterBuilder2;
}();
var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
var InstantPrinterParser = function() {
  function InstantPrinterParser2(fractionalDigits) {
    this.fractionalDigits = fractionalDigits;
  }
  var _proto2 = InstantPrinterParser2.prototype;
  _proto2.print = function print(context2, buf) {
    var inSecs = context2.getValue(ChronoField.INSTANT_SECONDS);
    var inNanos = 0;
    if (context2.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
      inNanos = context2.temporal().getLong(ChronoField.NANO_OF_SECOND);
    }
    if (inSecs == null) {
      return false;
    }
    var inSec = inSecs;
    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
    if (inSec >= -SECONDS_0000_TO_1970) {
      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      if (hi > 0) {
        buf.append("+").append(hi);
      }
      buf.append(ldt.toString());
      if (ldt.second() === 0) {
        buf.append(":00");
      }
    } else {
      var _zeroSecs = inSec + SECONDS_0000_TO_1970;
      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      var pos = buf.length();
      buf.append(_ldt.toString());
      if (_ldt.second() === 0) {
        buf.append(":00");
      }
      if (_hi < 0) {
        if (_ldt.year() === -1e4) {
          buf.replace(pos, pos + 2, "" + (_hi - 1));
        } else if (_lo === 0) {
          buf.insert(pos, _hi);
        } else {
          buf.insert(pos + 1, Math.abs(_hi));
        }
      }
    }
    if (this.fractionalDigits === -2) {
      if (inNano !== 0) {
        buf.append(".");
        if (MathUtil.intMod(inNano, 1e6) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
        } else if (MathUtil.intMod(inNano, 1e3) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
        } else {
          buf.append(("" + (inNano + 1e9)).substring(1));
        }
      }
    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
      buf.append(".");
      var div = 1e8;
      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
        var digit = MathUtil.intDiv(inNano, div);
        buf.append(digit);
        inNano = inNano - digit * div;
        div = MathUtil.intDiv(div, 10);
      }
    }
    buf.append("Z");
    return true;
  };
  _proto2.parse = function parse2(context2, text2, position) {
    var newContext = context2.copy();
    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
    var pos = parser.parse(newContext, text2, position);
    if (pos < 0) {
      return pos;
    }
    var yearParsed = newContext.getParsed(ChronoField.YEAR);
    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
    var min2 = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
    var sec = secVal != null ? secVal : 0;
    var nano = nanoVal != null ? nanoVal : 0;
    var year = MathUtil.intMod(yearParsed, 1e4);
    var days = 0;
    if (hour === 24 && min2 === 0 && sec === 0 && nano === 0) {
      hour = 0;
      days = 1;
    } else if (hour === 23 && min2 === 59 && sec === 60) {
      context2.setParsedLeapSecond();
      sec = 59;
    }
    var instantSecs;
    try {
      var ldt = LocalDateTime.of(year, month, day, hour, min2, sec, 0).plusDays(days);
      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
    } catch (ex) {
      return ~position;
    }
    var successPos = pos;
    successPos = context2.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
    return context2.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
  };
  _proto2.toString = function toString4() {
    return "Instant()";
  };
  return InstantPrinterParser2;
}();
var DefaultingParser = function() {
  function DefaultingParser2(field, value) {
    this._field = field;
    this._value = value;
  }
  var _proto3 = DefaultingParser2.prototype;
  _proto3.print = function print() {
    return true;
  };
  _proto3.parse = function parse2(context2, text2, position) {
    if (context2.getParsed(this._field) == null) {
      context2.setParsedField(this._field, this._value, position, position);
    }
    return position;
  };
  return DefaultingParser2;
}();
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringBuilder = function() {
  function StringBuilder2() {
    this._str = "";
  }
  var _proto = StringBuilder2.prototype;
  _proto.append = function append2(str) {
    this._str += str;
    return this;
  };
  _proto.appendChar = function appendChar(str) {
    this._str += str[0];
    return this;
  };
  _proto.insert = function insert(offset, str) {
    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
    return this;
  };
  _proto.replace = function replace(start, end3, str) {
    this._str = this._str.slice(0, start) + str + this._str.slice(end3);
    return this;
  };
  _proto.length = function length() {
    return this._str.length;
  };
  _proto.setLength = function setLength(length) {
    this._str = this._str.slice(0, length);
    return this;
  };
  _proto.toString = function toString4() {
    return this._str;
  };
  return StringBuilder2;
}();
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimeFormatter = function() {
  DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
    return DateTimeFormatter2.PARSED_EXCESS_DAYS;
  };
  DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
    return DateTimeFormatter2.PARSED_LEAP_SECOND;
  };
  DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
  };
  function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
    if (chrono === void 0) {
      chrono = IsoChronology.INSTANCE;
    }
    assert(printerParser != null);
    assert(decimalStyle != null);
    assert(resolverStyle != null);
    this._printerParser = printerParser;
    this._locale = locale;
    this._decimalStyle = decimalStyle;
    this._resolverStyle = resolverStyle;
    this._resolverFields = resolverFields;
    this._chrono = chrono;
    this._zone = zone;
  }
  var _proto = DateTimeFormatter2.prototype;
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.decimalStyle = function decimalStyle() {
    return this._decimalStyle;
  };
  _proto.chronology = function chronology() {
    return this._chrono;
  };
  _proto.withChronology = function withChronology(chrono) {
    if (this._chrono != null && this._chrono.equals(chrono)) {
      return this;
    }
    return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
  };
  _proto.withLocale = function withLocale() {
    return this;
  };
  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
    requireNonNull(resolverStyle, "resolverStyle");
    if (resolverStyle.equals(this._resolverStyle)) {
      return this;
    }
    return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
  };
  _proto.format = function format(temporal) {
    var buf = new StringBuilder(32);
    this._formatTo(temporal, buf);
    return buf.toString();
  };
  _proto._formatTo = function _formatTo(temporal, appendable) {
    requireNonNull(temporal, "temporal");
    requireNonNull(appendable, "appendable");
    var context2 = new DateTimePrintContext(temporal, this);
    this._printerParser.print(context2, appendable);
  };
  _proto.parse = function parse2(text2, type2) {
    if (arguments.length === 1) {
      return this.parse1(text2);
    } else {
      return this.parse2(text2, type2);
    }
  };
  _proto.parse1 = function parse1(text2) {
    requireNonNull(text2, "text");
    try {
      return this._parseToBuilder(text2, null).resolve(this._resolverStyle, this._resolverFields);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text2, ex);
      }
    }
  };
  _proto.parse2 = function parse2(text2, type2) {
    requireNonNull(text2, "text");
    requireNonNull(type2, "type");
    try {
      var builder2 = this._parseToBuilder(text2, null).resolve(this._resolverStyle, this._resolverFields);
      return builder2.build(type2);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text2, ex);
      }
    }
  };
  _proto._createError = function _createError(text2, ex) {
    var abbr = "";
    if (text2.length > 64) {
      abbr = text2.substring(0, 64) + "...";
    } else {
      abbr = text2;
    }
    return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text2, 0, ex);
  };
  _proto._parseToBuilder = function _parseToBuilder(text2, position) {
    var pos = position != null ? position : new ParsePosition(0);
    var result = this._parseUnresolved0(text2, pos);
    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text2.length) {
      var abbr = "";
      if (text2.length > 64) {
        abbr = text2.substr(0, 64).toString() + "...";
      } else {
        abbr = text2;
      }
      if (pos.getErrorIndex() >= 0) {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text2, pos.getErrorIndex());
      } else {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text2, pos.getIndex());
      }
    }
    return result.toBuilder();
  };
  _proto.parseUnresolved = function parseUnresolved(text2, position) {
    return this._parseUnresolved0(text2, position);
  };
  _proto._parseUnresolved0 = function _parseUnresolved0(text2, position) {
    assert(text2 != null, "text", NullPointerException);
    assert(position != null, "position", NullPointerException);
    var context2 = new DateTimeParseContext(this);
    var pos = position.getIndex();
    pos = this._printerParser.parse(context2, text2, pos);
    if (pos < 0) {
      position.setErrorIndex(~pos);
      return null;
    }
    position.setIndex(pos);
    return context2.toParsed();
  };
  _proto._toPrinterParser = function _toPrinterParser(optional) {
    return this._printerParser.withOptional(optional);
  };
  _proto.toString = function toString4() {
    var pattern = this._printerParser.toString();
    return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
  };
  return DateTimeFormatter2;
}();
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}
var MonthDay = function(_TemporalAccessor) {
  _inheritsLoose(MonthDay2, _TemporalAccessor);
  MonthDay2.now = function now2(zoneIdOrClock) {
    if (arguments.length === 0) {
      return MonthDay2.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return MonthDay2.nowZoneId(zoneIdOrClock);
    } else {
      return MonthDay2.nowClock(zoneIdOrClock);
    }
  };
  MonthDay2.now0 = function now0() {
    return this.nowClock(Clock.systemDefaultZone());
  };
  MonthDay2.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, "zone");
    return this.nowClock(Clock.system(zone));
  };
  MonthDay2.nowClock = function nowClock(clock) {
    requireNonNull(clock, "clock");
    var now2 = LocalDate.now(clock);
    return MonthDay2.of(now2.month(), now2.dayOfMonth());
  };
  MonthDay2.of = function of(monthOrNumber, number) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return MonthDay2.ofMonthNumber(monthOrNumber, number);
    } else {
      return MonthDay2.ofNumberNumber(monthOrNumber, number);
    }
  };
  MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
    requireNonNull(month, "month");
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > month.maxLength()) {
      throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
    }
    return new MonthDay2(month.value(), dayOfMonth);
  };
  MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
    requireNonNull(month, "month");
    requireNonNull(dayOfMonth, "dayOfMonth");
    return MonthDay2.of(Month.of(month), dayOfMonth);
  };
  MonthDay2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    requireInstance(temporal, TemporalAccessor, "temporal");
    if (temporal instanceof MonthDay2) {
      return temporal;
    }
    try {
      return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  MonthDay2.parse = function parse2(text2, formatter) {
    if (arguments.length === 1) {
      return MonthDay2.parseString(text2);
    } else {
      return MonthDay2.parseStringFormatter(text2, formatter);
    }
  };
  MonthDay2.parseString = function parseString(text2) {
    return MonthDay2.parseStringFormatter(text2, PARSER$2);
  };
  MonthDay2.parseStringFormatter = function parseStringFormatter(text2, formatter) {
    requireNonNull(text2, "text");
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return formatter.parse(text2, MonthDay2.FROM);
  };
  function MonthDay2(month, dayOfMonth) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    return _this;
  }
  var _proto = MonthDay2.prototype;
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return field.range();
    } else if (field === ChronoField.DAY_OF_MONTH) {
      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
    }
    return _TemporalAccessor.prototype.range.call(this, field);
  };
  _proto.get = function get3(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.DAY_OF_MONTH:
          return this._day;
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isValidYear = function isValidYear(year) {
    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
  };
  _proto.withMonth = function withMonth(month) {
    return this.with(Month.of(month));
  };
  _proto.with = function _with(month) {
    requireNonNull(month, "month");
    if (month.value() === this._month) {
      return this;
    }
    var day = Math.min(this._day, month.maxLength());
    return new MonthDay2(month.value(), day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (dayOfMonth === this._day) {
      return this;
    }
    return MonthDay2.of(this._month, dayOfMonth);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    requireInstance(_query, TemporalQuery, "query");
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, "temporal");
    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
  };
  _proto.atYear = function atYear(year) {
    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, MonthDay2, "other");
    var cmp2 = this._month - other.monthValue();
    if (cmp2 === 0) {
      cmp2 = this._day - other.dayOfMonth();
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, "other");
    requireInstance(other, MonthDay2, "other");
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, "other");
    requireInstance(other, MonthDay2, "other");
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj2) {
    if (this === obj2) {
      return true;
    }
    if (obj2 instanceof MonthDay2) {
      var other = obj2;
      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
    }
    return false;
  };
  _proto.toString = function toString4() {
    return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return formatter.format(this);
  };
  return MonthDay2;
}(TemporalAccessor);
var PARSER$2;
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
    return MonthDay.from(temporal);
  });
}
var YearMonth = function(_Temporal) {
  _inheritsLoose(YearMonth2, _Temporal);
  YearMonth2.now = function now2(zoneIdOrClock) {
    if (arguments.length === 0) {
      return YearMonth2.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return YearMonth2.nowZoneId(zoneIdOrClock);
    } else {
      return YearMonth2.nowClock(zoneIdOrClock);
    }
  };
  YearMonth2.now0 = function now0() {
    return YearMonth2.nowClock(Clock.systemDefaultZone());
  };
  YearMonth2.nowZoneId = function nowZoneId(zone) {
    return YearMonth2.nowClock(Clock.system(zone));
  };
  YearMonth2.nowClock = function nowClock(clock) {
    var now2 = LocalDate.now(clock);
    return YearMonth2.of(now2.year(), now2.month());
  };
  YearMonth2.of = function of(year, monthOrNumber) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return YearMonth2.ofNumberMonth(year, monthOrNumber);
    } else {
      return YearMonth2.ofNumberNumber(year, monthOrNumber);
    }
  };
  YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
    requireNonNull(month, "month");
    requireInstance(month, Month, "month");
    return YearMonth2.ofNumberNumber(year, month.value());
  };
  YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
    requireNonNull(year, "year");
    requireNonNull(month, "month");
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth2(year, month);
  };
  YearMonth2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    if (temporal instanceof YearMonth2) {
      return temporal;
    }
    try {
      return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  YearMonth2.parse = function parse2(text2, formatter) {
    if (arguments.length === 1) {
      return YearMonth2.parseString(text2);
    } else {
      return YearMonth2.parseStringFormatter(text2, formatter);
    }
  };
  YearMonth2.parseString = function parseString(text2) {
    return YearMonth2.parseStringFormatter(text2, PARSER$1);
  };
  YearMonth2.parseStringFormatter = function parseStringFormatter(text2, formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, YearMonth2.FROM);
  };
  function YearMonth2(year, month) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    return _this;
  }
  var _proto = YearMonth2.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field === ChronoField.YEAR_OF_ERA) {
      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get3(field) {
    requireNonNull(field, "field");
    requireInstance(field, TemporalField, "field");
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    requireInstance(field, TemporalField, "field");
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
        case ChronoField.PROLEPTIC_MONTH:
          return this._getProlepticMonth();
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto._getProlepticMonth = function _getProlepticMonth() {
    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.isValidDay = function isValidDay(dayOfMonth) {
    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    return this.month().length(this.isLeapYear());
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto.with = function _with(adjusterOrField, value) {
    if (arguments.length === 1) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, value);
    }
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    requireInstance(field, TemporalField, "field");
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    ChronoField.YEAR.checkValidValue(year);
    return new YearMonth2(year, this._month);
  };
  _proto.withMonth = function withMonth(month) {
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth2(this._year, month);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, "unit");
    requireInstance(unit, TemporalUnit, "unit");
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return this.withYear(newYear);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return new YearMonth2(newYear, newMonth);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    requireInstance(_query, TemporalQuery, "query");
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, "temporal");
    requireInstance(temporal, Temporal, "temporal");
    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, "endExclusive");
    requireNonNull(unit, "unit");
    requireInstance(endExclusive, Temporal, "endExclusive");
    requireInstance(unit, TemporalUnit, "unit");
    var end3 = YearMonth2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var monthsUntil = end3._getProlepticMonth() - this._getProlepticMonth();
      switch (unit) {
        case ChronoUnit.MONTHS:
          return monthsUntil;
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(monthsUntil, 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(monthsUntil, 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(monthsUntil, 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(monthsUntil, 12e3);
        case ChronoUnit.ERAS:
          return end3.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  _proto.atDay = function atDay(dayOfMonth) {
    requireNonNull(dayOfMonth, "dayOfMonth");
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };
  _proto.atEndOfMonth = function atEndOfMonth() {
    return LocalDate.of(this._year, this._month, this.lengthOfMonth());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, YearMonth2, "other");
    var cmp2 = this._year - other.year();
    if (cmp2 === 0) {
      cmp2 = this._month - other.monthValue();
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj2) {
    if (this === obj2) {
      return true;
    }
    if (obj2 instanceof YearMonth2) {
      var other = obj2;
      return this.year() === other.year() && this.monthValue() === other.monthValue();
    }
    return false;
  };
  _proto.toString = function toString4() {
    return PARSER$1.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this);
  };
  return YearMonth2;
}(Temporal);
var PARSER$1;
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
    return YearMonth.from(temporal);
  });
}
var Year = function(_Temporal) {
  _inheritsLoose(Year2, _Temporal);
  function Year2(value) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(value);
    return _this;
  }
  var _proto = Year2.prototype;
  _proto.value = function value() {
    return this._year;
  };
  Year2.now = function now2(zoneIdOrClock) {
    if (zoneIdOrClock === void 0) {
      zoneIdOrClock = void 0;
    }
    if (zoneIdOrClock === void 0) {
      return Year2.now0();
    } else if (zoneIdOrClock instanceof ZoneId) {
      return Year2.nowZoneId(zoneIdOrClock);
    } else {
      return Year2.nowClock(zoneIdOrClock);
    }
  };
  Year2.now0 = function now0() {
    return Year2.nowClock(Clock.systemDefaultZone());
  };
  Year2.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, "zone");
    requireInstance(zone, ZoneId, "zone");
    return Year2.nowClock(Clock.system(zone));
  };
  Year2.nowClock = function nowClock(clock) {
    requireNonNull(clock, "clock");
    requireInstance(clock, Clock, "clock");
    var now2 = LocalDate.now(clock);
    return Year2.of(now2.year());
  };
  Year2.of = function of(isoYear) {
    requireNonNull(isoYear, "isoYear");
    ChronoField.YEAR.checkValidValue(isoYear);
    return new Year2(isoYear);
  };
  Year2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    requireInstance(temporal, TemporalAccessor, "temporal");
    if (temporal instanceof Year2) {
      return temporal;
    }
    try {
      return Year2.of(temporal.get(ChronoField.YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  Year2.parse = function parse2(text2, formatter) {
    if (arguments.length <= 1) {
      return Year2.parseText(text2);
    } else {
      return Year2.parseTextFormatter(text2, formatter);
    }
  };
  Year2.parseText = function parseText(text2) {
    requireNonNull(text2, "text");
    return Year2.parse(text2, PARSER);
  };
  Year2.parseTextFormatter = function parseTextFormatter(text2, formatter) {
    if (formatter === void 0) {
      formatter = PARSER;
    }
    requireNonNull(text2, "text");
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return formatter.parse(text2, Year2.FROM);
  };
  Year2.isLeap = function isLeap(year) {
    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (this.isSupported(field)) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get3(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isLeap = function isLeap() {
    return Year2.isLeap(this._year);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    requireInstance(field, TemporalField, "field");
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return Year2.of(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return Year2.of(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, "amountToAdd");
    requireNonNull(unit, "unit");
    requireInstance(unit, TemporalUnit, "unit");
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, "temporal");
    return temporal.with(ChronoField.YEAR, this._year);
  };
  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
    return monthDay != null && monthDay.isValidYear(this._year);
  };
  _proto.length = function length() {
    return this.isLeap() ? 366 : 365;
  };
  _proto.atDay = function atDay(dayOfYear) {
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };
  _proto.atMonth = function atMonth(monthOrNumber) {
    if (arguments.length === 1 && monthOrNumber instanceof Month) {
      return this.atMonthMonth(monthOrNumber);
    } else {
      return this.atMonthNumber(monthOrNumber);
    }
  };
  _proto.atMonthMonth = function atMonthMonth(month) {
    requireNonNull(month, "month");
    requireInstance(month, Month, "month");
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthNumber = function atMonthNumber(month) {
    requireNonNull(month, "month");
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthDay = function atMonthDay(monthDay) {
    requireNonNull(monthDay, "monthDay");
    requireInstance(monthDay, MonthDay, "monthDay");
    return monthDay.atYear(this._year);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query()");
    requireInstance(_query, TemporalQuery, "query()");
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.YEARS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, Year2, "other");
    return this._year - other._year;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, "other");
    requireInstance(other, Year2, "other");
    return this._year > other._year;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, "other");
    requireInstance(other, Year2, "other");
    return this._year < other._year;
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return formatter.format(this);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Year2) {
      return this.value() === other.value();
    }
    return false;
  };
  _proto.toString = function toString4() {
    return "" + this._year;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.until = function until(endExclusive, unit) {
    var end3 = Year2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var yearsUntil = end3.value() - this.value();
      switch (unit) {
        case ChronoUnit.YEARS:
          return yearsUntil;
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(yearsUntil, 10);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(yearsUntil, 100);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(yearsUntil, 1e3);
        case ChronoUnit.ERAS:
          return end3.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  return Year2;
}(Temporal);
var PARSER;
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
    return Year.from(temporal);
  });
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAdjuster = function() {
  function TemporalAdjuster2() {
  }
  var _proto = TemporalAdjuster2.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    abstractMethodFail("adjustInto");
  };
  return TemporalAdjuster2;
}();
var TemporalAdjusters = function() {
  function TemporalAdjusters2() {
  }
  TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
    return Impl.FIRST_DAY_OF_MONTH;
  };
  TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
    return Impl.LAST_DAY_OF_MONTH;
  };
  TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
    return Impl.FIRST_DAY_OF_NEXT_MONTH;
  };
  TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
    return Impl.FIRST_DAY_OF_YEAR;
  };
  TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
    return Impl.LAST_DAY_OF_YEAR;
  };
  TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
    return Impl.FIRST_DAY_OF_NEXT_YEAR;
  };
  TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, "dayOfWeek");
    return new DayOfWeekInMonth(1, dayOfWeek);
  };
  TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, "dayOfWeek");
    return new DayOfWeekInMonth(-1, dayOfWeek);
  };
  TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
    requireNonNull(dayOfWeek, "dayOfWeek");
    return new DayOfWeekInMonth(ordinal, dayOfWeek);
  };
  TemporalAdjusters2.next = function next(dayOfWeek) {
    return new RelativeDayOfWeek(2, dayOfWeek);
  };
  TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(0, dayOfWeek);
  };
  TemporalAdjusters2.previous = function previous(dayOfWeek) {
    return new RelativeDayOfWeek(3, dayOfWeek);
  };
  TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(1, dayOfWeek);
  };
  return TemporalAdjusters2;
}();
var Impl = function(_TemporalAdjuster) {
  _inheritsLoose(Impl2, _TemporalAdjuster);
  function Impl2(ordinal) {
    var _this;
    _this = _TemporalAdjuster.call(this) || this;
    _this._ordinal = ordinal;
    return _this;
  }
  var _proto = Impl2.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    switch (this._ordinal) {
      case 0:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1);
      case 1:
        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      case 2:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
      case 3:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1);
      case 4:
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
      case 5:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
    }
    throw new IllegalStateException("Unreachable");
  };
  return Impl2;
}(TemporalAdjuster);
Impl.FIRST_DAY_OF_MONTH = new Impl(0);
Impl.LAST_DAY_OF_MONTH = new Impl(1);
Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
Impl.FIRST_DAY_OF_YEAR = new Impl(3);
Impl.LAST_DAY_OF_YEAR = new Impl(4);
Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
var DayOfWeekInMonth = function(_TemporalAdjuster2) {
  _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
  function DayOfWeekInMonth2(ordinal, dow) {
    var _this2;
    _this2 = _TemporalAdjuster2.call(this) || this;
    _this2._ordinal = ordinal;
    _this2._dowValue = dow.value();
    return _this2;
  }
  var _proto2 = DayOfWeekInMonth2.prototype;
  _proto2.adjustInto = function adjustInto(temporal) {
    if (this._ordinal >= 0) {
      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
      var curDow = temp.get(ChronoField.DAY_OF_WEEK);
      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
      dowDiff += (this._ordinal - 1) * 7;
      return temp.plus(dowDiff, ChronoUnit.DAYS);
    } else {
      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
      var daysDiff = this._dowValue - _curDow;
      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
      daysDiff -= (-this._ordinal - 1) * 7;
      return _temp.plus(daysDiff, ChronoUnit.DAYS);
    }
  };
  return DayOfWeekInMonth2;
}(TemporalAdjuster);
var RelativeDayOfWeek = function(_TemporalAdjuster3) {
  _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
  function RelativeDayOfWeek2(relative, dayOfWeek) {
    var _this3;
    _this3 = _TemporalAdjuster3.call(this) || this;
    requireNonNull(dayOfWeek, "dayOfWeek");
    _this3._relative = relative;
    _this3._dowValue = dayOfWeek.value();
    return _this3;
  }
  var _proto3 = RelativeDayOfWeek2.prototype;
  _proto3.adjustInto = function adjustInto(temporal) {
    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
    if (this._relative < 2 && calDow === this._dowValue) {
      return temporal;
    }
    if ((this._relative & 1) === 0) {
      var daysDiff = calDow - this._dowValue;
      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
    } else {
      var _daysDiff = this._dowValue - calDow;
      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
    }
  };
  return RelativeDayOfWeek2;
}(TemporalAdjuster);
var IsoChronology = function(_Enum) {
  _inheritsLoose(IsoChronology2, _Enum);
  function IsoChronology2() {
    return _Enum.apply(this, arguments) || this;
  }
  IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
  };
  var _proto = IsoChronology2.prototype;
  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
    requireNonNull(fieldValues, "fieldValues");
    requireNonNull(field, "field");
    var current = fieldValues.get(field);
    if (current != null && current !== value) {
      throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
    }
    fieldValues.put(field, value);
  };
  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
    }
    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
    if (prolepticMonth != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
      }
      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
    }
    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
    if (yoeLong != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
      }
      var era = fieldValues.remove(ChronoField.ERA);
      if (era == null) {
        var year = fieldValues.get(ChronoField.YEAR);
        if (resolverStyle === ResolverStyle.STRICT) {
          if (year != null) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
          } else {
            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
          }
        } else {
          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
        }
      } else if (era === 1) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
      } else if (era === 0) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
      } else {
        throw new DateTimeException("Invalid value for era: " + era);
      }
    } else if (fieldValues.containsKey(ChronoField.ERA)) {
      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
    }
    if (fieldValues.containsKey(ChronoField.YEAR)) {
      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
          if (resolverStyle === ResolverStyle.LENIENT) {
            var months = moy - 1;
            var days = dom - 1;
            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
          } else if (resolverStyle === ResolverStyle.SMART) {
            ChronoField.DAY_OF_MONTH.checkValidValue(dom);
            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
              dom = Math.min(dom, 30);
            } else if (moy === 2) {
              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
            }
            return LocalDate.of(y, moy, dom);
          } else {
            return LocalDate.of(y, moy, dom);
          }
        }
      }
      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
        if (resolverStyle === ResolverStyle.LENIENT) {
          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
          return LocalDate.ofYearDay(_y, 1).plusDays(_days);
        }
        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
        return LocalDate.ofYearDay(_y, doy);
      }
      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
          }
          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
          var date2 = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
          if (resolverStyle === ResolverStyle.STRICT && date2.get(ChronoField.YEAR) !== _y2) {
            throw new DateTimeException("Strict mode rejected date parsed to a different year");
          }
          return date2;
        }
        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
          }
          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
          var _date2 = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
          if (resolverStyle === ResolverStyle.STRICT && _date2.get(ChronoField.YEAR) !== _y3) {
            throw new DateTimeException("Strict mode rejected date parsed to a different month");
          }
          return _date2;
        }
      }
    }
    return null;
  };
  _proto.date = function date2(temporal) {
    return LocalDate.from(temporal);
  };
  return IsoChronology2;
}(Enum);
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
}
var OffsetTime = function(_Temporal) {
  _inheritsLoose(OffsetTime2, _Temporal);
  OffsetTime2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    if (temporal instanceof OffsetTime2) {
      return temporal;
    } else if (temporal instanceof OffsetDateTime) {
      return temporal.toOffsetTime();
    }
    try {
      var time2 = LocalTime.from(temporal);
      var offset = ZoneOffset.from(temporal);
      return new OffsetTime2(time2, offset);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  OffsetTime2.now = function now2(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetTime2._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return OffsetTime2._now(clockOrZone);
    } else {
      return OffsetTime2._now(Clock.system(clockOrZone));
    }
  };
  OffsetTime2._now = function _now(clock) {
    requireNonNull(clock, "clock");
    var now2 = clock.instant();
    return OffsetTime2.ofInstant(now2, clock.zone().rules().offset(now2));
  };
  OffsetTime2.of = function of() {
    if (arguments.length <= 2) {
      return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
    } else {
      return OffsetTime2.ofNumbers.apply(this, arguments);
    }
  };
  OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
    var time2 = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new OffsetTime2(time2, offset);
  };
  OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time2, offset) {
    return new OffsetTime2(time2, offset);
  };
  OffsetTime2.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, "instant");
    requireInstance(instant, Instant, "instant");
    requireNonNull(zone, "zone");
    requireInstance(zone, ZoneId, "zone");
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }
    var time2 = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
    return new OffsetTime2(time2, offset);
  };
  OffsetTime2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_TIME;
    }
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, OffsetTime2.FROM);
  };
  function OffsetTime2(time2, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(time2, "time");
    requireInstance(time2, LocalTime, "time");
    requireNonNull(offset, "offset");
    requireInstance(offset, ZoneOffset, "offset");
    _this._time = time2;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetTime2.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.atDate = function atDate(date2) {
    return OffsetDateTime.of(date2, this._time, this._offset);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this, OffsetTime2.FROM);
  };
  _proto.get = function get3(field) {
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._offset.totalSeconds();
      }
      return this._time.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, "other");
    return this._toEpochNano() > other._toEpochNano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, "other");
    return this._toEpochNano() < other._toEpochNano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, "other");
    return this._toEpochNano() === other._toEpochNano();
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount);
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localTime()) {
      return this._time;
    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._time.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, "endExclusive");
    requireNonNull(unit, "unit");
    var end3 = OffsetTime2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end3._toEpochNano() - this._toEpochNano();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1e3);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1e6);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  _proto.withHour = function withHour(hour) {
    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nano) {
    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, "offset");
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._time.plusSeconds(difference);
    return new OffsetTime2(adjusted, offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
  };
  _proto._toEpochNano = function _toEpochNano() {
    var nod = this._time.toNanoOfDay();
    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
    return nod - offsetNanos;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, "adjuster");
    if (adjuster instanceof LocalTime) {
      return this._withLocalTimeOffset(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withLocalTimeOffset(this._time, adjuster);
    } else if (adjuster instanceof OffsetTime2) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
      }
      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time2, offset) {
    if (this._time === time2 && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetTime2(time2, offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, OffsetTime2, "other");
    if (this._offset.equals(other._offset)) {
      return this._time.compareTo(other._time);
    }
    var compare2 = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
    if (compare2 === 0) {
      return this._time.compareTo(other._time);
    }
    return compare2;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetTime2) {
      return this._time.equals(other._time) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._time.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString4() {
    return this._time.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return OffsetTime2;
}(Temporal);
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
    return OffsetTime.from(temporal);
  });
}
var ChronoZonedDateTime = function(_Temporal) {
  _inheritsLoose(ChronoZonedDateTime2, _Temporal);
  function ChronoZonedDateTime2() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoZonedDateTime2.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone();
    } else if (_query === TemporalQueries.chronology()) {
      return this.toLocalDate().chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this);
  };
  _proto.toInstant = function toInstant() {
    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond() {
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= this.offset().totalSeconds();
    return secs;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    var cmp2 = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp2 === 0) {
      cmp2 = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp2 === 0) {
        cmp2 = this.toLocalDateTime().compareTo(other.toLocalDateTime());
        if (cmp2 === 0) {
          cmp2 = strcmp(this.zone().id(), other.zone().id());
        }
      }
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, "other");
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, "other");
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, "other");
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ChronoZonedDateTime2) {
      return this.compareTo(other) === 0;
    }
    return false;
  };
  return ChronoZonedDateTime2;
}(Temporal);
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
var ZonedDateTime = function(_ChronoZonedDateTime) {
  _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
  ZonedDateTime2.now = function now2(clockOrZone) {
    var clock;
    if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
    }
    return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
  };
  ZonedDateTime2.of = function of() {
    if (arguments.length <= 2) {
      return ZonedDateTime2.of2.apply(this, arguments);
    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
      return ZonedDateTime2.of3.apply(this, arguments);
    } else {
      return ZonedDateTime2.of8.apply(this, arguments);
    }
  };
  ZonedDateTime2.of3 = function of3(date2, time2, zone) {
    return ZonedDateTime2.of2(LocalDateTime.of(date2, time2), zone);
  };
  ZonedDateTime2.of2 = function of2(localDateTime, zone) {
    return ZonedDateTime2.ofLocal(localDateTime, zone, null);
  };
  ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return ZonedDateTime2.ofLocal(dt, zone, null);
  };
  ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
    requireNonNull(localDateTime, "localDateTime");
    requireNonNull(zone, "zone");
    if (zone instanceof ZoneOffset) {
      return new ZonedDateTime2(localDateTime, zone, zone);
    }
    var offset = null;
    var rules = zone.rules();
    var validOffsets = rules.validOffsets(localDateTime);
    if (validOffsets.length === 1) {
      offset = validOffsets[0];
    } else if (validOffsets.length === 0) {
      var trans = rules.transition(localDateTime);
      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
      offset = trans.offsetAfter();
    } else {
      if (preferredOffset != null && validOffsets.some(function(validOffset) {
        return validOffset.equals(preferredOffset);
      })) {
        offset = preferredOffset;
      } else {
        offset = requireNonNull(validOffsets[0], "offset");
      }
    }
    return new ZonedDateTime2(localDateTime, offset, zone);
  };
  ZonedDateTime2.ofInstant = function ofInstant() {
    if (arguments.length === 2) {
      return ZonedDateTime2.ofInstant2.apply(this, arguments);
    } else {
      return ZonedDateTime2.ofInstant3.apply(this, arguments);
    }
  };
  ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
    requireNonNull(instant, "instant");
    requireNonNull(zone, "zone");
    return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
  };
  ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
    requireNonNull(localDateTime, "localDateTime");
    requireNonNull(offset, "offset");
    requireNonNull(zone, "zone");
    return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
  };
  ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
    var rules = zone.rules();
    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
    return new ZonedDateTime2(ldt, offset, zone);
  };
  ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
    requireNonNull(localDateTime, "localDateTime");
    requireNonNull(offset, "offset");
    requireNonNull(zone, "zone");
    var rules = zone.rules();
    if (rules.isValidOffset(localDateTime, offset) === false) {
      var trans = rules.transition(localDateTime);
      if (trans != null && trans.isGap()) {
        throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
      }
      throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
    }
    return new ZonedDateTime2(localDateTime, offset, zone);
  };
  ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
    requireNonNull(localDateTime, "localDateTime");
    requireNonNull(offset, "offset");
    requireNonNull(zone, "zone");
    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
      throw new IllegalArgumentException("ZoneId must match ZoneOffset");
    }
    return new ZonedDateTime2(localDateTime, offset, zone);
  };
  ZonedDateTime2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    if (temporal instanceof ZonedDateTime2) {
      return temporal;
    }
    var zone = ZoneId.from(temporal);
    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
      var zdt = ZonedDateTime2._from(temporal, zone);
      if (zdt != null) return zdt;
    }
    var ldt = LocalDateTime.from(temporal);
    return ZonedDateTime2.of2(ldt, zone);
  };
  ZonedDateTime2._from = function _from(temporal, zone) {
    try {
      return ZonedDateTime2.__from(temporal, zone);
    } catch (ex) {
      if (!(ex instanceof DateTimeException)) throw ex;
    }
  };
  ZonedDateTime2.__from = function __from(temporal, zone) {
    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
    return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
  };
  ZonedDateTime2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
    }
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, ZonedDateTime2.FROM);
  };
  function ZonedDateTime2(dateTime, offset, zone) {
    var _this;
    requireNonNull(dateTime, "dateTime");
    requireNonNull(offset, "offset");
    requireNonNull(zone, "zone");
    _this = _ChronoZonedDateTime.call(this) || this;
    _this._dateTime = dateTime;
    _this._offset = offset;
    _this._zone = zone;
    return _this;
  }
  var _proto = ZonedDateTime2.prototype;
  _proto._resolveLocal = function _resolveLocal(newDateTime) {
    requireNonNull(newDateTime, "newDateTime");
    return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
  };
  _proto._resolveInstant = function _resolveInstant(newDateTime) {
    return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
  };
  _proto._resolveOffset = function _resolveOffset(offset) {
    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
      return new ZonedDateTime2(this._dateTime, offset, this._zone);
    }
    return this;
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return true;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get3(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this._offset.totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    requireNonNull(field, "field");
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this._dateTime);
    if (trans != null && trans.isOverlap()) {
      var earlierOffset = trans.offsetBefore();
      if (earlierOffset.equals(this._offset) === false) {
        return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
      }
    }
    return this;
  };
  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this.toLocalDateTime());
    if (trans != null) {
      var laterOffset = trans.offsetAfter();
      if (laterOffset.equals(this._offset) === false) {
        return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
      }
    }
    return this;
  };
  _proto.zone = function zone() {
    return this._zone;
  };
  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
    requireNonNull(zone, "zone");
    return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
    requireNonNull(zone, "zone");
    return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
  };
  _proto.withFixedOffsetZone = function withFixedOffsetZone() {
    return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    if (adjuster instanceof LocalDate) {
      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
    } else if (adjuster instanceof LocalTime) {
      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
    } else if (adjuster instanceof LocalDateTime) {
      return this._resolveLocal(adjuster);
    } else if (adjuster instanceof Instant) {
      var instant = adjuster;
      return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
    } else if (adjuster instanceof ZoneOffset) {
      return this._resolveOffset(adjuster);
    }
    return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return ZonedDateTime2._create(newValue, this.nano(), this._zone);
        case ChronoField.OFFSET_SECONDS: {
          var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
          return this._resolveOffset(offset);
        }
      }
      return this._resolveLocal(this._dateTime.with(field, newValue));
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._resolveLocal(this._dateTime.withYear(year));
  };
  _proto.withMonth = function withMonth(month) {
    return this._resolveLocal(this._dateTime.withMonth(month));
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
  };
  _proto.withHour = function withHour(hour) {
    return this._resolveLocal(this._dateTime.withHour(hour));
  };
  _proto.withMinute = function withMinute(minute) {
    return this._resolveLocal(this._dateTime.withMinute(minute));
  };
  _proto.withSecond = function withSecond(second) {
    return this._resolveLocal(this._dateTime.withSecond(second));
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._resolveLocal(this._dateTime.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      if (unit.isDateBased()) {
        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
      } else {
        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
      }
    }
    requireNonNull(unit, "unit");
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._resolveLocal(this._dateTime.plusYears(years));
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._resolveLocal(this._dateTime.plusMonths(months));
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._resolveLocal(this._dateTime.plusWeeks(weeks));
  };
  _proto.plusDays = function plusDays(days) {
    return this._resolveLocal(this._dateTime.plusDays(days));
  };
  _proto.plusHours = function plusHours(hours) {
    return this._resolveInstant(this._dateTime.plusHours(hours));
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._resolveInstant(this._dateTime.plusMinutes(minutes));
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._resolveInstant(this._dateTime.plusSeconds(seconds));
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._resolveInstant(this._dateTime.plusNanos(nanos));
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this.plusHours(-1 * hours);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this.plusMinutes(-1 * minutes);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this.plusSeconds(-1 * seconds);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this.plusNanos(-1 * nanos);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    requireNonNull(_query, "query");
    return _ChronoZonedDateTime.prototype.query.call(this, _query);
  };
  _proto.until = function until(endExclusive, unit) {
    var end3 = ZonedDateTime2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end3 = end3.withZoneSameInstant(this._zone);
      if (unit.isDateBased()) {
        return this._dateTime.until(end3._dateTime, unit);
      } else {
        var difference = this._offset.totalSeconds() - end3._offset.totalSeconds();
        var adjustedEnd = end3._dateTime.plusSeconds(difference);
        return this._dateTime.until(adjustedEnd, unit);
      }
    }
    return unit.between(this, end3);
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetDateTime = function toOffsetDateTime() {
    return OffsetDateTime.of(this._dateTime, this._offset);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZonedDateTime2) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
  };
  _proto.toString = function toString4() {
    var str = this._dateTime.toString() + this._offset.toString();
    if (this._offset !== this._zone) {
      str += "[" + this._zone.toString() + "]";
    }
    return str;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    return _ChronoZonedDateTime.prototype.format.call(this, formatter);
  };
  return ZonedDateTime2;
}(ChronoZonedDateTime);
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
    return ZonedDateTime.from(temporal);
  });
}
var OffsetDateTime = function(_Temporal) {
  _inheritsLoose(OffsetDateTime2, _Temporal);
  OffsetDateTime2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    if (temporal instanceof OffsetDateTime2) {
      return temporal;
    }
    try {
      var offset = ZoneOffset.from(temporal);
      try {
        var ldt = LocalDateTime.from(temporal);
        return OffsetDateTime2.of(ldt, offset);
      } catch (_2) {
        var instant = Instant.from(temporal);
        return OffsetDateTime2.ofInstant(instant, offset);
      }
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  OffsetDateTime2.now = function now2(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetDateTime2.now(Clock.systemDefaultZone());
    } else {
      requireNonNull(clockOrZone, "clockOrZone");
      if (clockOrZone instanceof ZoneId) {
        return OffsetDateTime2.now(Clock.system(clockOrZone));
      } else if (clockOrZone instanceof Clock) {
        var now3 = clockOrZone.instant();
        return OffsetDateTime2.ofInstant(now3, clockOrZone.zone().rules().offset(now3));
      } else {
        throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
      }
    }
  };
  OffsetDateTime2.of = function of() {
    if (arguments.length <= 2) {
      return OffsetDateTime2.ofDateTime.apply(this, arguments);
    } else if (arguments.length === 3) {
      return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
    } else {
      return OffsetDateTime2.ofNumbers.apply(this, arguments);
    }
  };
  OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
    return new OffsetDateTime2(dateTime, offset);
  };
  OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date2, time2, offset) {
    var dt = LocalDateTime.of(date2, time2);
    return new OffsetDateTime2(dt, offset);
  };
  OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return new OffsetDateTime2(dt, offset);
  };
  OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, "instant");
    requireNonNull(zone, "zone");
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
    return new OffsetDateTime2(ldt, offset);
  };
  OffsetDateTime2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
    }
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, OffsetDateTime2.FROM);
  };
  function OffsetDateTime2(dateTime, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(dateTime, "dateTime");
    requireInstance(dateTime, LocalDateTime, "dateTime");
    requireNonNull(offset, "offset");
    requireInstance(offset, ZoneOffset, "offset");
    _this._dateTime = dateTime;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetDateTime2.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.until = function until(endExclusive, unit) {
    var end3 = OffsetDateTime2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end3 = end3.withOffsetSameInstant(this._offset);
      return this._dateTime.until(end3._dateTime, unit);
    }
    return unit.between(this, end3);
  };
  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
  };
  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.get = function get3(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          throw new DateTimeException("Field too large for an int: " + field);
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.get(field);
    }
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetTime = function toOffsetTime() {
    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
  };
  _proto.toZonedDateTime = function toZonedDateTime() {
    return ZonedDateTime.of(this._dateTime, this._offset);
  };
  _proto.toInstant = function toInstant() {
    return this._dateTime.toInstant(this._offset);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._dateTime.toEpochSecond(this._offset);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster);
    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
    } else if (adjuster instanceof Instant) {
      return OffsetDateTime2.ofInstant(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withDateTimeOffset(this._dateTime, adjuster);
    } else if (adjuster instanceof OffsetDateTime2) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field);
    if (field instanceof ChronoField) {
      var f = field;
      switch (f) {
        case ChronoField.INSTANT_SECONDS:
          return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
        case ChronoField.OFFSET_SECONDS: {
          return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
        }
      }
      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
    if (this._dateTime === dateTime && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetDateTime2(dateTime, offset);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
  };
  _proto.withHour = function withHour(hour) {
    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    requireNonNull(offset, "offset");
    return this._withDateTimeOffset(this._dateTime, offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, "offset");
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._dateTime.plusSeconds(difference);
    return new OffsetDateTime2(adjusted, offset);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, "amount");
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
  };
  _proto.plusDays = function plusDays(days) {
    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
  };
  _proto.minusDays = function minusDays(days) {
    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, OffsetDateTime2, "other");
    if (this.offset().equals(other.offset())) {
      return this.toLocalDateTime().compareTo(other.toLocalDateTime());
    }
    var cmp2 = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp2 === 0) {
      cmp2 = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp2 === 0) {
        cmp2 = this.toLocalDateTime().compareTo(other.toLocalDateTime());
      }
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, "other");
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, "other");
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, "other");
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetDateTime2) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._dateTime.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString4() {
    return this._dateTime.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this);
  };
  return OffsetDateTime2;
}(Temporal);
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
    return OffsetDateTime.from(temporal);
  });
}
var DAYS_PER_CYCLE = 146097;
var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
var LocalDate = function(_ChronoLocalDate) {
  _inheritsLoose(LocalDate2, _ChronoLocalDate);
  LocalDate2.now = function now2(clockOrZone) {
    var clock;
    if (clockOrZone == null) {
      clock = Clock.systemDefaultZone();
    } else if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone;
    }
    return LocalDate2.ofInstant(clock.instant(), clock.zone());
  };
  LocalDate2.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, "instant");
    var offset = zone.rules().offset(instant);
    var epochSec = instant.epochSecond() + offset.totalSeconds();
    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
    return LocalDate2.ofEpochDay(epochDay);
  };
  LocalDate2.of = function of(year, month, dayOfMonth) {
    return new LocalDate2(year, month, dayOfMonth);
  };
  LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
    ChronoField.YEAR.checkValidValue(year);
    var leap = IsoChronology.isLeapYear(year);
    if (dayOfYear === 366 && leap === false) {
      assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
    }
    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
    if (dayOfYear > monthEnd) {
      moy = moy.plus(1);
    }
    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
    return new LocalDate2(year, moy.value(), dom);
  };
  LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
    if (epochDay === void 0) {
      epochDay = 0;
    }
    var adjust, adjustCycles, doyEst, yearEst, zeroDay;
    zeroDay = epochDay + DAYS_0000_TO_1970;
    zeroDay -= 60;
    adjust = 0;
    if (zeroDay < 0) {
      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
      adjust = adjustCycles * 400;
      zeroDay += -adjustCycles * DAYS_PER_CYCLE;
    }
    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    if (doyEst < 0) {
      yearEst--;
      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    }
    yearEst += adjust;
    var marchDoy0 = doyEst;
    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
    var month = (marchMonth0 + 2) % 12 + 1;
    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
    yearEst += MathUtil.intDiv(marchMonth0, 10);
    var year = yearEst;
    return new LocalDate2(year, month, dom);
  };
  LocalDate2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    var date2 = temporal.query(TemporalQueries.localDate());
    if (date2 == null) {
      throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
    return date2;
  };
  LocalDate2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE;
    }
    assert(formatter != null, "formatter", NullPointerException);
    return formatter.parse(text2, LocalDate2.FROM);
  };
  LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
    switch (month) {
      case 2:
        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
        break;
      case 4:
      case 6:
      case 9:
      case 11:
        day = Math.min(day, 30);
        break;
    }
    return LocalDate2.of(year, month, day);
  };
  function LocalDate2(year, month, dayOfMonth) {
    var _this;
    _this = _ChronoLocalDate.call(this) || this;
    requireNonNull(year, "year");
    requireNonNull(month, "month");
    requireNonNull(dayOfMonth, "dayOfMonth");
    if (month instanceof Month) {
      month = month.value();
    }
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    LocalDate2._validate(_this._year, _this._month, _this._day);
    return _this;
  }
  LocalDate2._validate = function _validate(year, month, dayOfMonth) {
    var dom;
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > 28) {
      dom = 31;
      switch (month) {
        case 2:
          dom = IsoChronology.isLeapYear(year) ? 29 : 28;
          break;
        case 4:
        case 6:
        case 9:
        case 11:
          dom = 30;
      }
      if (dayOfMonth > dom) {
        if (dayOfMonth === 29) {
          assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
        } else {
          assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
        }
      }
    }
  };
  var _proto = LocalDate2.prototype;
  _proto.isSupported = function isSupported(field) {
    return _ChronoLocalDate.prototype.isSupported.call(this, field);
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      if (field.isDateBased()) {
        switch (field) {
          case ChronoField.DAY_OF_MONTH:
            return ValueRange.of(1, this.lengthOfMonth());
          case ChronoField.DAY_OF_YEAR:
            return ValueRange.of(1, this.lengthOfYear());
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
          case ChronoField.YEAR_OF_ERA:
            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get3(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    assert(field != null, "", NullPointerException);
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.DAY_OF_WEEK:
        return this.dayOfWeek().value();
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
        return MathUtil.intMod(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.DAY_OF_MONTH:
        return this._day;
      case ChronoField.DAY_OF_YEAR:
        return this.dayOfYear();
      case ChronoField.EPOCH_DAY:
        return this.toEpochDay();
      case ChronoField.ALIGNED_WEEK_OF_MONTH:
        return MathUtil.intDiv(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_WEEK_OF_YEAR:
        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.MONTH_OF_YEAR:
        return this._month;
      case ChronoField.PROLEPTIC_MONTH:
        return this._prolepticMonth();
      case ChronoField.YEAR_OF_ERA:
        return this._year >= 1 ? this._year : 1 - this._year;
      case ChronoField.YEAR:
        return this._year;
      case ChronoField.ERA:
        return this._year >= 1 ? 1 : 0;
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto._prolepticMonth = function _prolepticMonth() {
    return this._year * 12 + (this._month - 1);
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.dayOfYear = function dayOfYear() {
    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
  };
  _proto.dayOfWeek = function dayOfWeek() {
    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
    return DayOfWeek.of(dow0 + 1);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    switch (this._month) {
      case 2:
        return this.isLeapYear() ? 29 : 28;
      case 4:
      case 6:
      case 9:
      case 11:
        return 30;
      default:
        return 31;
    }
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, "adjuster");
    if (adjuster instanceof LocalDate2) {
      return adjuster;
    }
    return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    assert(field != null, "field", NullPointerException);
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.DAY_OF_WEEK:
          return this.plusDays(newValue - this.dayOfWeek().value());
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
        case ChronoField.DAY_OF_MONTH:
          return this.withDayOfMonth(newValue);
        case ChronoField.DAY_OF_YEAR:
          return this.withDayOfYear(newValue);
        case ChronoField.EPOCH_DAY:
          return LocalDate2.ofEpochDay(newValue);
        case ChronoField.ALIGNED_WEEK_OF_MONTH:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
        case ChronoField.ALIGNED_WEEK_OF_YEAR:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    if (this._year === year) {
      return this;
    }
    ChronoField.YEAR.checkValidValue(year);
    return LocalDate2._resolvePreviousValid(year, this._month, this._day);
  };
  _proto.withMonth = function withMonth(month) {
    var m = month instanceof Month ? month.value() : month;
    if (this._month === m) {
      return this;
    }
    ChronoField.MONTH_OF_YEAR.checkValidValue(m);
    return LocalDate2._resolvePreviousValid(this._year, m, this._day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (this._day === dayOfMonth) {
      return this;
    }
    return LocalDate2.of(this._year, this._month, dayOfMonth);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    if (this.dayOfYear() === dayOfYear) {
      return this;
    }
    return LocalDate2.ofYearDay(this._year, dayOfYear);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, "amountToAdd");
    requireNonNull(unit, "unit");
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.plusDays(amountToAdd);
        case ChronoUnit.WEEKS:
          return this.plusWeeks(amountToAdd);
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
  };
  _proto.plusWeeks = function plusWeeks(weeksToAdd) {
    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
    return LocalDate2.ofEpochDay(mjDay);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, "amountToSubtract");
    requireNonNull(unit, "unit");
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(yearsToSubtract * -1);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(monthsToSubtract * -1);
  };
  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
    return this.plusWeeks(weeksToSubtract * -1);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(daysToSubtract * -1);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.localDate()) {
      return this;
    }
    return _ChronoLocalDate.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(p1, p2) {
    if (arguments.length < 2) {
      return this.until1(p1);
    } else {
      return this.until2(p1, p2);
    }
  };
  _proto.until2 = function until2(endExclusive, unit) {
    var end3 = LocalDate2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.daysUntil(end3);
        case ChronoUnit.WEEKS:
          return MathUtil.intDiv(this.daysUntil(end3), 7);
        case ChronoUnit.MONTHS:
          return this._monthsUntil(end3);
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(this._monthsUntil(end3), 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(this._monthsUntil(end3), 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(this._monthsUntil(end3), 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(this._monthsUntil(end3), 12e3);
        case ChronoUnit.ERAS:
          return end3.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  _proto.daysUntil = function daysUntil(end3) {
    return end3.toEpochDay() - this.toEpochDay();
  };
  _proto._monthsUntil = function _monthsUntil(end3) {
    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
    var packed2 = end3._prolepticMonth() * 32 + end3.dayOfMonth();
    return MathUtil.intDiv(packed2 - packed1, 32);
  };
  _proto.until1 = function until1(endDate) {
    var end3 = LocalDate2.from(endDate);
    var totalMonths = end3._prolepticMonth() - this._prolepticMonth();
    var days = end3._day - this._day;
    if (totalMonths > 0 && days < 0) {
      totalMonths--;
      var calcDate = this.plusMonths(totalMonths);
      days = end3.toEpochDay() - calcDate.toEpochDay();
    } else if (totalMonths < 0 && days > 0) {
      totalMonths++;
      days -= end3.lengthOfMonth();
    }
    var years = MathUtil.intDiv(totalMonths, 12);
    var months = MathUtil.intMod(totalMonths, 12);
    return Period.of(years, months, days);
  };
  _proto.atTime = function atTime() {
    if (arguments.length === 1) {
      return this.atTime1.apply(this, arguments);
    } else {
      return this.atTime4.apply(this, arguments);
    }
  };
  _proto.atTime1 = function atTime1(time2) {
    requireNonNull(time2, "time");
    if (time2 instanceof LocalTime) {
      return LocalDateTime.of(this, time2);
    } else if (time2 instanceof OffsetTime) {
      return this._atTimeOffsetTime(time2);
    } else {
      throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time2 && time2.constructor && time2.constructor.name ? ", but is " + time2.constructor.name : ""));
    }
  };
  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
  };
  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time2) {
    return OffsetDateTime.of(LocalDateTime.of(this, time2.toLocalTime()), time2.offset());
  };
  _proto.atStartOfDay = function atStartOfDay(zone) {
    if (zone != null) {
      return this._atStartOfDayWithZone(zone);
    } else {
      return LocalDateTime.of(this, LocalTime.MIDNIGHT);
    }
  };
  _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
    requireNonNull(zone, "zone");
    var ldt = this.atTime(LocalTime.MIDNIGHT);
    if (zone instanceof ZoneOffset === false) {
      var trans = zone.rules().transition(ldt);
      if (trans != null && trans.isGap()) {
        ldt = trans.dateTimeAfter();
      }
    }
    return ZonedDateTime.of(ldt, zone);
  };
  _proto.toEpochDay = function toEpochDay() {
    var y = this._year;
    var m = this._month;
    var total = 0;
    total += 365 * y;
    if (y >= 0) {
      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
    } else {
      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
    }
    total += MathUtil.intDiv(367 * m - 362, 12);
    total += this.dayOfMonth() - 1;
    if (m > 2) {
      total--;
      if (!IsoChronology.isLeapYear(y)) {
        total--;
      }
    }
    return total - DAYS_0000_TO_1970;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, LocalDate2, "other");
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(otherDate) {
    var cmp2 = this._year - otherDate._year;
    if (cmp2 === 0) {
      cmp2 = this._month - otherDate._month;
      if (cmp2 === 0) {
        cmp2 = this._day - otherDate._day;
      }
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDate2) {
      return this._compareTo0(other) === 0;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
  };
  _proto.toString = function toString4() {
    var dayString, monthString, yearString;
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    var absYear = Math.abs(yearValue);
    if (absYear < 1e3) {
      if (yearValue < 0) {
        yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
      } else {
        yearString = ("" + (yearValue + 1e4)).slice(-4);
      }
    } else {
      if (yearValue > 9999) {
        yearString = "+" + yearValue;
      } else {
        yearString = "" + yearValue;
      }
    }
    if (monthValue < 10) {
      monthString = "-0" + monthValue;
    } else {
      monthString = "-" + monthValue;
    }
    if (dayValue < 10) {
      dayString = "-0" + dayValue;
    } else {
      dayString = "-" + dayValue;
    }
    return yearString + monthString + dayString;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    requireInstance(formatter, DateTimeFormatter, "formatter");
    return _ChronoLocalDate.prototype.format.call(this, formatter);
  };
  return LocalDate2;
}(ChronoLocalDate);
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
    return LocalDate.from(temporal);
  });
}
var ChronoLocalDateTime = function(_Temporal) {
  _inheritsLoose(ChronoLocalDateTime2, _Temporal);
  function ChronoLocalDateTime2() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDateTime2.prototype;
  _proto.chronology = function chronology() {
    return this.toLocalDate().chronology();
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
  };
  _proto.toInstant = function toInstant(offset) {
    requireInstance(offset, ZoneOffset, "zoneId");
    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond(offset) {
    requireNonNull(offset, "offset");
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= offset.totalSeconds();
    return MathUtil.safeToInt(secs);
  };
  return ChronoLocalDateTime2;
}(Temporal);
var LocalDateTime = function(_ChronoLocalDateTime) {
  _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
  LocalDateTime2.now = function now2(clockOrZone) {
    if (clockOrZone == null) {
      return LocalDateTime2._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalDateTime2._now(clockOrZone);
    } else {
      return LocalDateTime2._now(Clock.system(clockOrZone));
    }
  };
  LocalDateTime2._now = function _now(clock) {
    requireNonNull(clock, "clock");
    return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
  };
  LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
    var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
    var date2 = LocalDate.ofEpochDay(localEpochDay);
    var time2 = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime2(date2, time2);
  };
  LocalDateTime2.of = function of() {
    if (arguments.length <= 2) {
      return LocalDateTime2.ofDateAndTime.apply(this, arguments);
    } else {
      return LocalDateTime2.ofNumbers.apply(this, arguments);
    }
  };
  LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var date2 = LocalDate.of(year, month, dayOfMonth);
    var time2 = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new LocalDateTime2(date2, time2);
  };
  LocalDateTime2.ofDateAndTime = function ofDateAndTime(date2, time2) {
    requireNonNull(date2, "date");
    requireNonNull(time2, "time");
    return new LocalDateTime2(date2, time2);
  };
  LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, "instant");
    requireInstance(instant, Instant, "instant");
    requireNonNull(zone, "zone");
    var offset = zone.rules().offset(instant);
    return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
  };
  LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
    if (epochSecond === void 0) {
      epochSecond = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
      offset = nanoOfSecond;
      nanoOfSecond = 0;
    }
    requireNonNull(offset, "offset");
    var localSecond = epochSecond + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var date2 = LocalDate.ofEpochDay(localEpochDay);
    var time2 = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime2(date2, time2);
  };
  LocalDateTime2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    if (temporal instanceof LocalDateTime2) {
      return temporal;
    } else if (temporal instanceof ZonedDateTime) {
      return temporal.toLocalDateTime();
    }
    try {
      var date2 = LocalDate.from(temporal);
      var time2 = LocalTime.from(temporal);
      return new LocalDateTime2(date2, time2);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
  };
  LocalDateTime2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    }
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, LocalDateTime2.FROM);
  };
  function LocalDateTime2(date2, time2) {
    var _this;
    _this = _ChronoLocalDateTime.call(this) || this;
    requireInstance(date2, LocalDate, "date");
    requireInstance(time2, LocalTime, "time");
    _this._date = date2;
    _this._time = time2;
    return _this;
  }
  var _proto = LocalDateTime2.prototype;
  _proto._withDateTime = function _withDateTime(newDate, newTime) {
    if (this._date.equals(newDate) && this._time.equals(newTime)) {
      return this;
    }
    return new LocalDateTime2(newDate, newTime);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get3(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
    }
    return _ChronoLocalDateTime.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.year = function year() {
    return this._date.year();
  };
  _proto.monthValue = function monthValue() {
    return this._date.monthValue();
  };
  _proto.month = function month() {
    return this._date.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._date.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._date.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._date.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, "adjuster");
    if (adjuster instanceof LocalDate) {
      return this._withDateTime(adjuster, this._time);
    } else if (adjuster instanceof LocalTime) {
      return this._withDateTime(this._date, adjuster);
    } else if (adjuster instanceof LocalDateTime2) {
      return adjuster;
    }
    return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      if (field.isTimeBased()) {
        return this._withDateTime(this._date, this._time.with(field, newValue));
      } else {
        return this._withDateTime(this._date.with(field, newValue), this._time);
      }
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTime(this._date.withYear(year), this._time);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTime(this._date.withMonth(month), this._time);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
  };
  _proto.withHour = function withHour(hour) {
    var newTime = this._time.withHour(hour);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withMinute = function withMinute(minute) {
    var newTime = this._time.withMinute(minute);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withSecond = function withSecond(second) {
    var newTime = this._time.withSecond(second);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    var newTime = this._time.withNano(nanoOfSecond);
    return this._withDateTime(this._date, newTime);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTime(this._date, this._time.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, "unit");
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
        case ChronoUnit.MILLIS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
      }
      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    var newDate = this._date.plusYears(years);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusMonths = function plusMonths(months) {
    var newDate = this._date.plusMonths(months);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    var newDate = this._date.plusWeeks(weeks);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusDays = function plusDays(days) {
    var newDate = this._date.plusDays(days);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, "unit");
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
  };
  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign4) {
    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
      return this._withDateTime(newDate, this._time);
    }
    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
    totDays *= sign4;
    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
    var curNoD = this._time.toNanoOfDay();
    totNanos = totNanos * sign4 + curNoD;
    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
    return this._withDateTime(newDate.plusDays(totDays), newTime);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    return _ChronoLocalDateTime.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, "endExclusive");
    requireNonNull(unit, "unit");
    var end3 = LocalDateTime2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      if (unit.isTimeBased()) {
        var daysUntil = this._date.daysUntil(end3._date);
        var timeUntil = end3._time.toNanoOfDay() - this._time.toNanoOfDay();
        if (daysUntil > 0 && timeUntil < 0) {
          daysUntil--;
          timeUntil += LocalTime.NANOS_PER_DAY;
        } else if (daysUntil < 0 && timeUntil > 0) {
          daysUntil++;
          timeUntil -= LocalTime.NANOS_PER_DAY;
        }
        var amount = daysUntil;
        switch (unit) {
          case ChronoUnit.NANOS:
            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
            return MathUtil.safeAdd(amount, timeUntil);
          case ChronoUnit.MICROS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
          case ChronoUnit.MILLIS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
          case ChronoUnit.SECONDS:
            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
          case ChronoUnit.MINUTES:
            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
          case ChronoUnit.HOURS:
            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
          case ChronoUnit.HALF_DAYS:
            amount = MathUtil.safeMultiply(amount, 2);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      }
      var endDate = end3._date;
      var endTime = end3._time;
      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
        endDate = endDate.minusDays(1);
      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
        endDate = endDate.plusDays(1);
      }
      return this._date.until(endDate, unit);
    }
    return unit.between(this, end3);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.of(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.of(this, zone);
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._date;
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, LocalDateTime2, "other");
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(other) {
    var cmp2 = this._date.compareTo(other.toLocalDate());
    if (cmp2 === 0) {
      cmp2 = this._time.compareTo(other.toLocalTime());
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDateTime2) {
      return this._date.equals(other._date) && this._time.equals(other._time);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._date.hashCode() ^ this._time.hashCode();
  };
  _proto.toString = function toString4() {
    return this._date.toString() + "T" + this._time.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this);
  };
  return LocalDateTime2;
}(ChronoLocalDateTime);
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
    return LocalDateTime.from(temporal);
  });
}
var LocalTime = function(_Temporal) {
  _inheritsLoose(LocalTime2, _Temporal);
  LocalTime2.now = function now2(clockOrZone) {
    if (clockOrZone == null) {
      return LocalTime2._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalTime2._now(clockOrZone);
    } else {
      return LocalTime2._now(Clock.system(clockOrZone));
    }
  };
  LocalTime2._now = function _now(clock) {
    if (clock === void 0) {
      clock = Clock.systemDefaultZone();
    }
    requireNonNull(clock, "clock");
    return LocalTime2.ofInstant(clock.instant(), clock.zone());
  };
  LocalTime2.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    var offset = zone.rules().offset(instant);
    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
    if (secsOfDay < 0) {
      secsOfDay += LocalTime2.SECONDS_PER_DAY;
    }
    return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
  };
  LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
    return new LocalTime2(hour, minute, second, nanoOfSecond);
  };
  LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
    if (secondOfDay === void 0) {
      secondOfDay = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
    var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
    secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
    var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
    secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
    return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
  };
  LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
    if (nanoOfDay === void 0) {
      nanoOfDay = 0;
    }
    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
    var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
    nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
    nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
    nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
    return new LocalTime2(hours, minutes, seconds, nanoOfDay);
  };
  LocalTime2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    var time2 = temporal.query(TemporalQueries.localTime());
    if (time2 == null) {
      throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
    return time2;
  };
  LocalTime2.parse = function parse2(text2, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_TIME;
    }
    requireNonNull(formatter, "formatter");
    return formatter.parse(text2, LocalTime2.FROM);
  };
  function LocalTime2(hour, minute, second, nanoOfSecond) {
    var _this;
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    _this = _Temporal.call(this) || this;
    var _hour = MathUtil.safeToInt(hour);
    var _minute = MathUtil.safeToInt(minute);
    var _second = MathUtil.safeToInt(second);
    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
    LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
      if (!LocalTime2.HOURS[_hour]) {
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
      }
      return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
    }
    _this._hour = _hour;
    _this._minute = _minute;
    _this._second = _second;
    _this._nano = _nanoOfSecond;
    return _this;
  }
  LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
    ChronoField.HOUR_OF_DAY.checkValidValue(hour);
    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
  };
  var _proto = LocalTime2.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    requireNonNull(field);
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get3(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.NANO_OF_SECOND:
        return this._nano;
      case ChronoField.NANO_OF_DAY:
        return this.toNanoOfDay();
      case ChronoField.MICRO_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1e3);
      case ChronoField.MICRO_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
      case ChronoField.MILLI_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1e6);
      case ChronoField.MILLI_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
      case ChronoField.SECOND_OF_MINUTE:
        return this._second;
      case ChronoField.SECOND_OF_DAY:
        return this.toSecondOfDay();
      case ChronoField.MINUTE_OF_HOUR:
        return this._minute;
      case ChronoField.MINUTE_OF_DAY:
        return this._hour * 60 + this._minute;
      case ChronoField.HOUR_OF_AMPM:
        return MathUtil.intMod(this._hour, 12);
      case ChronoField.CLOCK_HOUR_OF_AMPM: {
        var ham = MathUtil.intMod(this._hour, 12);
        return ham % 12 === 0 ? 12 : ham;
      }
      case ChronoField.HOUR_OF_DAY:
        return this._hour;
      case ChronoField.CLOCK_HOUR_OF_DAY:
        return this._hour === 0 ? 24 : this._hour;
      case ChronoField.AMPM_OF_DAY:
        return MathUtil.intDiv(this._hour, 12);
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto.hour = function hour() {
    return this._hour;
  };
  _proto.minute = function minute() {
    return this._minute;
  };
  _proto.second = function second() {
    return this._second;
  };
  _proto.nano = function nano() {
    return this._nano;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, "adjuster");
    if (adjuster instanceof LocalTime2) {
      return adjuster;
    }
    return _Temporal.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    requireInstance(field, TemporalField, "field");
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this.withNano(newValue);
        case ChronoField.NANO_OF_DAY:
          return LocalTime2.ofNanoOfDay(newValue);
        case ChronoField.MICRO_OF_SECOND:
          return this.withNano(newValue * 1e3);
        case ChronoField.MICRO_OF_DAY:
          return LocalTime2.ofNanoOfDay(newValue * 1e3);
        case ChronoField.MILLI_OF_SECOND:
          return this.withNano(newValue * 1e6);
        case ChronoField.MILLI_OF_DAY:
          return LocalTime2.ofNanoOfDay(newValue * 1e6);
        case ChronoField.SECOND_OF_MINUTE:
          return this.withSecond(newValue);
        case ChronoField.SECOND_OF_DAY:
          return this.plusSeconds(newValue - this.toSecondOfDay());
        case ChronoField.MINUTE_OF_HOUR:
          return this.withMinute(newValue);
        case ChronoField.MINUTE_OF_DAY:
          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
        case ChronoField.HOUR_OF_AMPM:
          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
        case ChronoField.CLOCK_HOUR_OF_AMPM:
          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
        case ChronoField.HOUR_OF_DAY:
          return this.withHour(newValue);
        case ChronoField.CLOCK_HOUR_OF_DAY:
          return this.withHour(newValue === 24 ? 0 : newValue);
        case ChronoField.AMPM_OF_DAY:
          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withHour = function withHour(hour) {
    if (hour === void 0) {
      hour = 0;
    }
    if (this._hour === hour) {
      return this;
    }
    return new LocalTime2(hour, this._minute, this._second, this._nano);
  };
  _proto.withMinute = function withMinute(minute) {
    if (minute === void 0) {
      minute = 0;
    }
    if (this._minute === minute) {
      return this;
    }
    return new LocalTime2(this._hour, minute, this._second, this._nano);
  };
  _proto.withSecond = function withSecond(second) {
    if (second === void 0) {
      second = 0;
    }
    if (this._second === second) {
      return this;
    }
    return new LocalTime2(this._hour, this._minute, second, this._nano);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (this._nano === nanoOfSecond) {
      return this;
    }
    return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, "unit");
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
      throw new DateTimeException("Unit is too large to be used for truncation");
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException("Unit must divide into a standard day without remainder");
    }
    var nod = this.toNanoOfDay();
    return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, "unit");
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
        case ChronoUnit.MILLIS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    if (hoursToAdd === 0) {
      return this;
    }
    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
    return new LocalTime2(newHour, this._minute, this._second, this._nano);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    if (minutesToAdd === 0) {
      return this;
    }
    var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
    if (mofd === newMofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
    var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
    return new LocalTime2(newHour, newMinute, this._second, this._nano);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    if (secondsToAdd === 0) {
      return this;
    }
    var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
    if (sofd === newSofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
    return new LocalTime2(newHour, newMinute, newSecond, this._nano);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    if (nanosToAdd === 0) {
      return this;
    }
    var nofd = this.toNanoOfDay();
    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
    if (nofd === newNofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
    var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
    return new LocalTime2(newHour, newMinute, newSecond, newNano);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, "unit");
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localTime()) {
      return this;
    }
    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, "endExclusive");
    requireNonNull(unit, "unit");
    var end3 = LocalTime2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end3.toNanoOfDay() - this.toNanoOfDay();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1e3);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1e6);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  _proto.atDate = function atDate(date2) {
    return LocalDateTime.of(date2, this);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetTime.of(this, offset);
  };
  _proto.toSecondOfDay = function toSecondOfDay() {
    var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
    total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
    total += this._second;
    return total;
  };
  _proto.toNanoOfDay = function toNanoOfDay() {
    var total = this._hour * LocalTime2.NANOS_PER_HOUR;
    total += this._minute * LocalTime2.NANOS_PER_MINUTE;
    total += this._second * LocalTime2.NANOS_PER_SECOND;
    total += this._nano;
    return total;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, "other");
    requireInstance(other, LocalTime2, "other");
    var cmp2 = MathUtil.compareNumbers(this._hour, other._hour);
    if (cmp2 === 0) {
      cmp2 = MathUtil.compareNumbers(this._minute, other._minute);
      if (cmp2 === 0) {
        cmp2 = MathUtil.compareNumbers(this._second, other._second);
        if (cmp2 === 0) {
          cmp2 = MathUtil.compareNumbers(this._nano, other._nano);
        }
      }
    }
    return cmp2;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalTime2) {
      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var nod = this.toNanoOfDay();
    return MathUtil.hash(nod);
  };
  _proto.toString = function toString4() {
    var buf = "";
    var hourValue = this._hour;
    var minuteValue = this._minute;
    var secondValue = this._second;
    var nanoValue = this._nano;
    buf += hourValue < 10 ? "0" : "";
    buf += hourValue;
    buf += minuteValue < 10 ? ":0" : ":";
    buf += minuteValue;
    if (secondValue > 0 || nanoValue > 0) {
      buf += secondValue < 10 ? ":0" : ":";
      buf += secondValue;
      if (nanoValue > 0) {
        buf += ".";
        if (MathUtil.intMod(nanoValue, 1e6) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
        } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
        } else {
          buf += ("" + (nanoValue + 1e9)).substring(1);
        }
      }
    }
    return buf;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, "formatter");
    return formatter.format(this);
  };
  return LocalTime2;
}(Temporal);
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
    return LocalTime.from(temporal);
  });
}
LocalTime.HOURS_PER_DAY = 24;
LocalTime.MINUTES_PER_HOUR = 60;
LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.SECONDS_PER_MINUTE = 60;
LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
LocalTime.NANOS_PER_SECOND = 1e9;
LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
var NANOS_PER_MILLI = 1e6;
var Instant = function(_Temporal) {
  _inheritsLoose(Instant2, _Temporal);
  Instant2.now = function now2(clock) {
    if (clock === void 0) {
      clock = Clock.systemUTC();
    }
    return clock.instant();
  };
  Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Instant2._create(secs, nos);
  };
  Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
    var secs = MathUtil.floorDiv(epochMilli, 1e3);
    var mos = MathUtil.floorMod(epochMilli, 1e3);
    return Instant2._create(secs, mos * 1e6);
  };
  Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
    var secs = MathUtil.floorDiv(epochMicro, 1e6);
    var mos = MathUtil.floorMod(epochMicro, 1e6);
    return Instant2._create(secs, mos * 1e3);
  };
  Instant2.from = function from(temporal) {
    try {
      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
      return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
    }
  };
  Instant2.parse = function parse2(text2) {
    return DateTimeFormatter.ISO_INSTANT.parse(text2, Instant2.FROM);
  };
  Instant2._create = function _create(seconds, nanoOfSecond) {
    if (seconds === 0 && nanoOfSecond === 0) {
      return Instant2.EPOCH;
    }
    return new Instant2(seconds, nanoOfSecond);
  };
  Instant2._validate = function _validate(seconds, nanoOfSecond) {
    if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
      throw new DateTimeException("Instant exceeds minimum or maximum instant");
    }
    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
      throw new DateTimeException("Instant exceeds minimum or maximum instant");
    }
  };
  function Instant2(seconds, nanoOfSecond) {
    var _this;
    _this = _Temporal.call(this) || this;
    Instant2._validate(seconds, nanoOfSecond);
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanoOfSecond);
    return _this;
  }
  var _proto = Instant2.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range2(field) {
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get3(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this._nanos;
        case ChronoField.MICRO_OF_SECOND:
          return MathUtil.intDiv(this._nanos, 1e3);
        case ChronoField.MILLI_OF_SECOND:
          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
        case ChronoField.INSTANT_SECONDS:
          return this._seconds;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.epochSecond = function epochSecond() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, "field");
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.MILLI_OF_SECOND: {
          var nval = newValue * NANOS_PER_MILLI;
          return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
        }
        case ChronoField.MICRO_OF_SECOND: {
          var _nval = newValue * 1e3;
          return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
        }
        case ChronoField.NANO_OF_SECOND:
          return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
        case ChronoField.INSTANT_SECONDS:
          return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, "unit");
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException("Unit is too large to be used for truncation");
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException("Unit must divide into a standard day without remainder");
    }
    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
    var result = MathUtil.intDiv(nod, dur) * dur;
    return this.plusNanos(result - nod);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, "amountToAdd");
    requireNonNull(unit, "unit");
    requireInstance(unit, TemporalUnit);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusMicros(amountToAdd);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
        case ChronoUnit.HOURS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
        case ChronoUnit.HALF_DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
        case ChronoUnit.DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this._plus(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this._plus(0, nanosToAdd);
  };
  _proto.plusMicros = function plusMicros(microsToAdd) {
    return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
  };
  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = this._seconds + secondsToAdd;
    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
    return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(secondsToSubtract * -1);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return this.plusMillis(-1 * millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * nanosToSubtract);
  };
  _proto.minusMicros = function minusMicros(microsToSubtract) {
    return this.plusMicros(-1 * microsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, "query");
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    }
    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, "temporal");
    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, "endExclusive");
    requireNonNull(unit, "unit");
    var end3 = Instant2.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this._nanosUntil(end3);
        case ChronoUnit.MICROS:
          return this._microsUntil(end3);
        case ChronoUnit.MILLIS:
          return MathUtil.safeSubtract(end3.toEpochMilli(), this.toEpochMilli());
        case ChronoUnit.SECONDS:
          return this._secondsUntil(end3);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(this._secondsUntil(end3), LocalTime.SECONDS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(this._secondsUntil(end3), LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(this._secondsUntil(end3), 12 * LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.DAYS:
          return MathUtil.intDiv(this._secondsUntil(end3), LocalTime.SECONDS_PER_DAY);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end3);
  };
  _proto._microsUntil = function _microsUntil(end3) {
    var secsDiff = MathUtil.safeSubtract(end3.epochSecond(), this.epochSecond());
    var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
    return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end3.nano() - this.nano(), 1e3));
  };
  _proto._nanosUntil = function _nanosUntil(end3) {
    var secsDiff = MathUtil.safeSubtract(end3.epochSecond(), this.epochSecond());
    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
    return MathUtil.safeAdd(totalNanos, end3.nano() - this.nano());
  };
  _proto._secondsUntil = function _secondsUntil(end3) {
    var secsDiff = MathUtil.safeSubtract(end3.epochSecond(), this.epochSecond());
    var nanosDiff = end3.nano() - this.nano();
    if (secsDiff > 0 && nanosDiff < 0) {
      secsDiff--;
    } else if (secsDiff < 0 && nanosDiff > 0) {
      secsDiff++;
    }
    return secsDiff;
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.ofInstant(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.ofInstant(this, zone);
  };
  _proto.toEpochMilli = function toEpochMilli() {
    var millis = MathUtil.safeMultiply(this._seconds, 1e3);
    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
  };
  _proto.compareTo = function compareTo(otherInstant) {
    requireNonNull(otherInstant, "otherInstant");
    requireInstance(otherInstant, Instant2, "otherInstant");
    var cmp2 = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
    if (cmp2 !== 0) {
      return cmp2;
    }
    return this._nanos - otherInstant._nanos;
  };
  _proto.isAfter = function isAfter(otherInstant) {
    return this.compareTo(otherInstant) > 0;
  };
  _proto.isBefore = function isBefore(otherInstant) {
    return this.compareTo(otherInstant) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Instant2) {
      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._seconds, this._nanos);
  };
  _proto.toString = function toString4() {
    return DateTimeFormatter.ISO_INSTANT.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Instant2;
}(Temporal);
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
    return Instant.from(temporal);
  });
}
var Clock = function() {
  function Clock2() {
  }
  Clock2.systemUTC = function systemUTC() {
    return new SystemClock(ZoneOffset.UTC);
  };
  Clock2.systemDefaultZone = function systemDefaultZone() {
    return new SystemClock(ZoneId.systemDefault());
  };
  Clock2.system = function system(zone) {
    return new SystemClock(zone);
  };
  Clock2.fixed = function fixed(fixedInstant, zoneId) {
    return new FixedClock(fixedInstant, zoneId);
  };
  Clock2.offset = function offset(baseClock, duration2) {
    return new OffsetClock(baseClock, duration2);
  };
  var _proto = Clock2.prototype;
  _proto.millis = function millis() {
    abstractMethodFail("Clock.millis");
  };
  _proto.instant = function instant() {
    abstractMethodFail("Clock.instant");
  };
  _proto.zone = function zone() {
    abstractMethodFail("Clock.zone");
  };
  _proto.withZone = function withZone() {
    abstractMethodFail("Clock.withZone");
  };
  return Clock2;
}();
var SystemClock = function(_Clock) {
  _inheritsLoose(SystemClock2, _Clock);
  function SystemClock2(zone) {
    var _this;
    requireNonNull(zone, "zone");
    _this = _Clock.call(this) || this;
    _this._zone = zone;
    return _this;
  }
  var _proto2 = SystemClock2.prototype;
  _proto2.zone = function zone() {
    return this._zone;
  };
  _proto2.millis = function millis() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  _proto2.instant = function instant() {
    return Instant.ofEpochMilli(this.millis());
  };
  _proto2.equals = function equals(obj2) {
    if (obj2 instanceof SystemClock2) {
      return this._zone.equals(obj2._zone);
    }
    return false;
  };
  _proto2.withZone = function withZone(zone) {
    if (zone.equals(this._zone)) {
      return this;
    }
    return new SystemClock2(zone);
  };
  _proto2.toString = function toString4() {
    return "SystemClock[" + this._zone.toString() + "]";
  };
  return SystemClock2;
}(Clock);
var FixedClock = function(_Clock2) {
  _inheritsLoose(FixedClock2, _Clock2);
  function FixedClock2(fixedInstant, zoneId) {
    var _this2;
    _this2 = _Clock2.call(this) || this;
    _this2._instant = fixedInstant;
    _this2._zoneId = zoneId;
    return _this2;
  }
  var _proto3 = FixedClock2.prototype;
  _proto3.instant = function instant() {
    return this._instant;
  };
  _proto3.millis = function millis() {
    return this._instant.toEpochMilli();
  };
  _proto3.zone = function zone() {
    return this._zoneId;
  };
  _proto3.toString = function toString4() {
    return "FixedClock[]";
  };
  _proto3.equals = function equals(obj2) {
    if (obj2 instanceof FixedClock2) {
      return this._instant.equals(obj2._instant) && this._zoneId.equals(obj2._zoneId);
    }
    return false;
  };
  _proto3.withZone = function withZone(zone) {
    if (zone.equals(this._zoneId)) {
      return this;
    }
    return new FixedClock2(this._instant, zone);
  };
  return FixedClock2;
}(Clock);
var OffsetClock = function(_Clock3) {
  _inheritsLoose(OffsetClock2, _Clock3);
  function OffsetClock2(baseClock, offset) {
    var _this3;
    _this3 = _Clock3.call(this) || this;
    _this3._baseClock = baseClock;
    _this3._offset = offset;
    return _this3;
  }
  var _proto4 = OffsetClock2.prototype;
  _proto4.zone = function zone() {
    return this._baseClock.zone();
  };
  _proto4.withZone = function withZone(zone) {
    if (zone.equals(this._baseClock.zone())) {
      return this;
    }
    return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
  };
  _proto4.millis = function millis() {
    return this._baseClock.millis() + this._offset.toMillis();
  };
  _proto4.instant = function instant() {
    return this._baseClock.instant().plus(this._offset);
  };
  _proto4.equals = function equals(obj2) {
    if (obj2 instanceof OffsetClock2) {
      return this._baseClock.equals(obj2._baseClock) && this._offset.equals(obj2._offset);
    }
    return false;
  };
  _proto4.toString = function toString4() {
    return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
  };
  return OffsetClock2;
}(Clock);
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneOffsetTransition = function() {
  ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
    return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
  };
  function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
    requireNonNull(transition, "transition");
    requireNonNull(offsetBefore, "offsetBefore");
    requireNonNull(offsetAfter, "offsetAfter");
    if (offsetBefore.equals(offsetAfter)) {
      throw new IllegalArgumentException("Offsets must not be equal");
    }
    if (transition.nano() !== 0) {
      throw new IllegalArgumentException("Nano-of-second must be zero");
    }
    if (transition instanceof LocalDateTime) {
      this._transition = transition;
    } else {
      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
    }
    this._offsetBefore = offsetBefore;
    this._offsetAfter = offsetAfter;
  }
  var _proto = ZoneOffsetTransition2.prototype;
  _proto.instant = function instant() {
    return this._transition.toInstant(this._offsetBefore);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._transition.toEpochSecond(this._offsetBefore);
  };
  _proto.dateTimeBefore = function dateTimeBefore() {
    return this._transition;
  };
  _proto.dateTimeAfter = function dateTimeAfter() {
    return this._transition.plusSeconds(this.durationSeconds());
  };
  _proto.offsetBefore = function offsetBefore() {
    return this._offsetBefore;
  };
  _proto.offsetAfter = function offsetAfter() {
    return this._offsetAfter;
  };
  _proto.duration = function duration2() {
    return Duration.ofSeconds(this.durationSeconds());
  };
  _proto.durationSeconds = function durationSeconds() {
    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
  };
  _proto.isGap = function isGap() {
    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
  };
  _proto.isOverlap = function isOverlap() {
    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
  };
  _proto.isValidOffset = function isValidOffset(offset) {
    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
  };
  _proto.validOffsets = function validOffsets() {
    if (this.isGap()) {
      return [];
    } else {
      return [this._offsetBefore, this._offsetAfter];
    }
  };
  _proto.compareTo = function compareTo(transition) {
    return this.instant().compareTo(transition.instant());
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ZoneOffsetTransition2) {
      var d = other;
      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
  };
  _proto.toString = function toString4() {
    return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
  };
  return ZoneOffsetTransition2;
}();
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}
var SystemDefaultZoneRules = function(_ZoneRules) {
  _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
  function SystemDefaultZoneRules2() {
    return _ZoneRules.apply(this, arguments) || this;
  }
  var _proto = SystemDefaultZoneRules2.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    return false;
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    return [this.offsetOfLocalDateTime(localDateTime)];
  };
  _proto.transition = function transition() {
    return null;
  };
  _proto.standardOffset = function standardOffset(instant) {
    return this.offsetOfInstant(instant);
  };
  _proto.daylightSavings = function daylightSavings() {
    this._throwNotSupported();
  };
  _proto.isDaylightSavings = function isDaylightSavings() {
    this._throwNotSupported();
  };
  _proto.isValidOffset = function isValidOffset(dateTime, offset) {
    return this.offsetOfLocalDateTime(dateTime).equals(offset);
  };
  _proto.nextTransition = function nextTransition() {
    this._throwNotSupported();
  };
  _proto.previousTransition = function previousTransition() {
    this._throwNotSupported();
  };
  _proto.transitions = function transitions() {
    this._throwNotSupported();
  };
  _proto.transitionRules = function transitionRules() {
    this._throwNotSupported();
  };
  _proto._throwNotSupported = function _throwNotSupported() {
    throw new DateTimeException("not supported operation");
  };
  _proto.equals = function equals(other) {
    if (this === other || other instanceof SystemDefaultZoneRules2) {
      return true;
    } else {
      return false;
    }
  };
  _proto.toString = function toString4() {
    return "SYSTEM";
  };
  return SystemDefaultZoneRules2;
}(ZoneRules);
var SystemDefaultZoneId = function(_ZoneId) {
  _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
  function SystemDefaultZoneId2() {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._rules = new SystemDefaultZoneRules();
    return _this;
  }
  var _proto = SystemDefaultZoneId2.prototype;
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    return false;
  };
  _proto.id = function id() {
    return "SYSTEM";
  };
  return SystemDefaultZoneId2;
}(ZoneId);
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdFactory = function() {
  function ZoneIdFactory2() {
  }
  ZoneIdFactory2.systemDefault = function systemDefault() {
    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  };
  ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
    return ZoneRulesProvider.getAvailableZoneIds();
  };
  ZoneIdFactory2.of = function of(zoneId) {
    requireNonNull(zoneId, "zoneId");
    if (zoneId === "Z") {
      return ZoneOffset.UTC;
    }
    if (zoneId.length === 1) {
      throw new DateTimeException("Invalid zone: " + zoneId);
    }
    if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
      return ZoneOffset.of(zoneId);
    }
    if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
    }
    if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
      var offset = ZoneOffset.of(zoneId.substring(3));
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
      }
      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
    }
    if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
      var _offset2 = ZoneOffset.of(zoneId.substring(2));
      if (_offset2.totalSeconds() === 0) {
        return new ZoneRegion("UT", _offset2.rules());
      }
      return new ZoneRegion("UT" + _offset2.id(), _offset2.rules());
    }
    if (zoneId === "SYSTEM") {
      return ZoneId.systemDefault();
    }
    return ZoneRegion.ofId(zoneId);
  };
  ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
    requireNonNull(prefix, "prefix");
    requireNonNull(offset, "offset");
    if (prefix.length === 0) {
      return offset;
    }
    if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(prefix, offset.rules());
      }
      return new ZoneRegion(prefix + offset.id(), offset.rules());
    }
    throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
  };
  ZoneIdFactory2.from = function from(temporal) {
    requireNonNull(temporal, "temporal");
    var obj2 = temporal.query(TemporalQueries.zone());
    if (obj2 == null) {
      throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
    }
    return obj2;
  };
  return ZoneIdFactory2;
}();
var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
function _init2() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var isInit = false;
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init2();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
init();
/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ToNativeJsConverter = function() {
  function ToNativeJsConverter2(temporal, zone) {
    var zonedDateTime;
    if (temporal instanceof Instant) {
      this.instant = temporal;
      return;
    } else if (temporal instanceof LocalDate) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atStartOfDay(zone);
    } else if (temporal instanceof LocalDateTime) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atZone(zone);
    } else if (temporal instanceof ZonedDateTime) {
      if (zone == null) {
        zonedDateTime = temporal;
      } else {
        zonedDateTime = temporal.withZoneSameInstant(zone);
      }
    } else {
      throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
    }
    this.instant = zonedDateTime.toInstant();
  }
  var _proto = ToNativeJsConverter2.prototype;
  _proto.toDate = function toDate() {
    return new Date(this.instant.toEpochMilli());
  };
  _proto.toEpochMilli = function toEpochMilli() {
    return this.instant.toEpochMilli();
  };
  return ToNativeJsConverter2;
}();
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}
/*
 * @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function nativeJs(date2, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date2, "date");
  requireNonNull(zone, "zone");
  if (date2 instanceof Date) {
    return Instant.ofEpochMilli(date2.getTime()).atZone(zone);
  } else if (typeof date2.toDate === "function" && date2.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date2.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
}
function bindUse(jsJoda) {
  var used = [];
  return function use2(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}
/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var _ = {
  assert: assert$1,
  DateTimeBuilder,
  DateTimeParseContext,
  DateTimePrintContext,
  MathUtil,
  StringUtil,
  StringBuilder
};
var jsJodaExports = {
  _,
  convert,
  nativeJs,
  ArithmeticException,
  DateTimeException,
  DateTimeParseException,
  IllegalArgumentException,
  IllegalStateException,
  UnsupportedTemporalTypeException,
  NullPointerException,
  Clock,
  DayOfWeek,
  Duration,
  Instant,
  LocalDate,
  LocalTime,
  LocalDateTime,
  OffsetTime,
  OffsetDateTime,
  Month,
  MonthDay,
  ParsePosition,
  Period,
  Year,
  YearConstants,
  YearMonth,
  ZonedDateTime,
  ZoneOffset,
  ZoneId,
  ZoneRegion,
  ZoneOffsetTransition,
  ZoneRules,
  ZoneRulesProvider,
  ChronoLocalDate,
  ChronoLocalDateTime,
  ChronoZonedDateTime,
  IsoChronology,
  ChronoField,
  ChronoUnit,
  IsoFields,
  Temporal,
  TemporalAccessor,
  TemporalAdjuster,
  TemporalAdjusters,
  TemporalAmount,
  TemporalField,
  TemporalQueries,
  TemporalQuery,
  TemporalUnit,
  ValueRange,
  DateTimeFormatter,
  DateTimeFormatterBuilder,
  DecimalStyle,
  ResolverStyle,
  SignStyle,
  TextStyle
};
var use = bindUse(jsJodaExports);
jsJodaExports.use = use;
const jsJoda_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArithmeticException,
  ChronoField,
  ChronoLocalDate,
  ChronoLocalDateTime,
  ChronoUnit,
  ChronoZonedDateTime,
  Clock,
  DateTimeException,
  DateTimeFormatter,
  DateTimeFormatterBuilder,
  DateTimeParseException,
  DayOfWeek,
  DecimalStyle,
  Duration,
  IllegalArgumentException,
  IllegalStateException,
  Instant,
  IsoChronology,
  IsoFields,
  LocalDate,
  LocalDateTime,
  LocalTime,
  Month,
  MonthDay,
  NullPointerException,
  OffsetDateTime,
  OffsetTime,
  ParsePosition,
  Period,
  ResolverStyle,
  SignStyle,
  Temporal,
  TemporalAccessor,
  TemporalAdjuster,
  TemporalAdjusters,
  TemporalAmount,
  TemporalField,
  TemporalQueries,
  TemporalQuery,
  TemporalUnit,
  TextStyle,
  UnsupportedTemporalTypeException,
  ValueRange,
  Year,
  YearConstants,
  YearMonth,
  ZoneId,
  ZoneOffset,
  ZoneOffsetTransition,
  ZoneRegion,
  ZoneRules,
  ZoneRulesProvider,
  ZonedDateTime,
  _,
  convert,
  nativeJs,
  use
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(jsJoda_esm);
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _datetimen2 = _interopRequireDefault2(datetimenExports);
  var _core = require$$0$1;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([8]);
  const DateTime = {
    id: 61,
    type: "DATETIME",
    name: "DateTime",
    declaration: function() {
      return "datetime";
    },
    generateTypeInfo() {
      return Buffer.from([_datetimen2.default.id, 8]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    generateParameterData: function* (parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value;
      let date2;
      if (options.useUTC) {
        date2 = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
      } else {
        date2 = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
      }
      let days = EPOCH_DATE.until(date2, _core.ChronoUnit.DAYS);
      let milliseconds, threeHundredthsOfSecond;
      if (options.useUTC) {
        let seconds = value.getUTCHours() * 60 * 60;
        seconds += value.getUTCMinutes() * 60;
        seconds += value.getUTCSeconds();
        milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
      } else {
        let seconds = value.getHours() * 60 * 60;
        seconds += value.getMinutes() * 60;
        seconds += value.getSeconds();
        milliseconds = seconds * 1e3 + value.getMilliseconds();
      }
      threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
      threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
      if (threeHundredthsOfSecond === 2592e4) {
        days += 1;
        threeHundredthsOfSecond = 0;
      }
      const buffer2 = Buffer.alloc(8);
      buffer2.writeInt32LE(days, 0);
      buffer2.writeUInt32LE(threeHundredthsOfSecond, 4);
      yield buffer2;
    },
    // TODO: type 'any' needs to be revisited.
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof Date)) {
        value = new Date(Date.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid date.");
      }
      return value;
    }
  };
  var _default2 = DateTime;
  exports$1.default = _default2;
  module2.exports = DateTime;
})(datetime, datetime.exports);
var datetimeExports = datetime.exports;
var float = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _floatn2 = _interopRequireDefault2(floatnExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const Float = {
    id: 62,
    type: "FLT8",
    name: "Float",
    declaration: function() {
      return "float";
    },
    generateTypeInfo() {
      return Buffer.from([_floatn2.default.id, 8]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return Buffer.from([8]);
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(8);
      buffer2.writeDoubleLE(parseFloat(parameter.value), 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      return value;
    }
  };
  var _default2 = Float;
  exports$1.default = _default2;
  module2.exports = Float;
})(float, float.exports);
var floatExports = float.exports;
var decimal = { exports: {} };
var decimaln = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const DecimalN = {
    id: 106,
    type: "DECIMALN",
    name: "DecimalN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = DecimalN;
  exports$1.default = _default2;
  module2.exports = DecimalN;
})(decimaln, decimaln.exports);
var decimalnExports = decimaln.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _decimaln2 = _interopRequireDefault2(decimalnExports);
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const Decimal = {
    id: 55,
    type: "DECIMAL",
    name: "Decimal",
    declaration: function(parameter) {
      return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
    },
    resolvePrecision: function(parameter) {
      if (parameter.precision != null) {
        return parameter.precision;
      } else if (parameter.value === null) {
        return 1;
      } else {
        return 18;
      }
    },
    resolveScale: function(parameter) {
      if (parameter.scale != null) {
        return parameter.scale;
      } else {
        return 0;
      }
    },
    generateTypeInfo(parameter, _options) {
      let precision;
      if (parameter.precision <= 9) {
        precision = 5;
      } else if (parameter.precision <= 19) {
        precision = 9;
      } else if (parameter.precision <= 28) {
        precision = 13;
      } else {
        precision = 17;
      }
      return Buffer.from([_decimaln2.default.id, precision, parameter.precision, parameter.scale]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const precision = parameter.precision;
      if (precision <= 9) {
        return Buffer.from([5]);
      } else if (precision <= 19) {
        return Buffer.from([9]);
      } else if (precision <= 28) {
        return Buffer.from([13]);
      } else {
        return Buffer.from([17]);
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const sign4 = parameter.value < 0 ? 0 : 1;
      const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
      const precision = parameter.precision;
      if (precision <= 9) {
        const buffer2 = Buffer.alloc(5);
        buffer2.writeUInt8(sign4, 0);
        buffer2.writeUInt32LE(value, 1);
        yield buffer2;
      } else if (precision <= 19) {
        const buffer2 = new _writableTrackingBuffer2.default(9);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        yield buffer2.data;
      } else if (precision <= 28) {
        const buffer2 = new _writableTrackingBuffer2.default(13);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        buffer2.writeUInt32LE(0);
        yield buffer2.data;
      } else {
        const buffer2 = new _writableTrackingBuffer2.default(17);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        buffer2.writeUInt32LE(0);
        buffer2.writeUInt32LE(0);
        yield buffer2.data;
      }
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      return value;
    }
  };
  var _default2 = Decimal;
  exports$1.default = _default2;
  module2.exports = Decimal;
})(decimal, decimal.exports);
var decimalExports = decimal.exports;
var numeric = { exports: {} };
var numericn = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const NumericN = {
    id: 108,
    type: "NUMERICN",
    name: "NumericN",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = NumericN;
  exports$1.default = _default2;
  module2.exports = NumericN;
})(numericn, numericn.exports);
var numericnExports = numericn.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _numericn2 = _interopRequireDefault2(numericnExports);
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const Numeric = {
    id: 63,
    type: "NUMERIC",
    name: "Numeric",
    declaration: function(parameter) {
      return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
    },
    resolvePrecision: function(parameter) {
      if (parameter.precision != null) {
        return parameter.precision;
      } else if (parameter.value === null) {
        return 1;
      } else {
        return 18;
      }
    },
    resolveScale: function(parameter) {
      if (parameter.scale != null) {
        return parameter.scale;
      } else {
        return 0;
      }
    },
    generateTypeInfo(parameter) {
      let precision;
      if (parameter.precision <= 9) {
        precision = 5;
      } else if (parameter.precision <= 19) {
        precision = 9;
      } else if (parameter.precision <= 28) {
        precision = 13;
      } else {
        precision = 17;
      }
      return Buffer.from([_numericn2.default.id, precision, parameter.precision, parameter.scale]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const precision = parameter.precision;
      if (precision <= 9) {
        return Buffer.from([5]);
      } else if (precision <= 19) {
        return Buffer.from([9]);
      } else if (precision <= 28) {
        return Buffer.from([13]);
      } else {
        return Buffer.from([17]);
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const sign4 = parameter.value < 0 ? 0 : 1;
      const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
      if (parameter.precision <= 9) {
        const buffer2 = Buffer.alloc(5);
        buffer2.writeUInt8(sign4, 0);
        buffer2.writeUInt32LE(value, 1);
        yield buffer2;
      } else if (parameter.precision <= 19) {
        const buffer2 = new _writableTrackingBuffer2.default(10);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        yield buffer2.data;
      } else if (parameter.precision <= 28) {
        const buffer2 = new _writableTrackingBuffer2.default(14);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        buffer2.writeUInt32LE(0);
        yield buffer2.data;
      } else {
        const buffer2 = new _writableTrackingBuffer2.default(18);
        buffer2.writeUInt8(sign4);
        buffer2.writeUInt64LE(value);
        buffer2.writeUInt32LE(0);
        buffer2.writeUInt32LE(0);
        yield buffer2.data;
      }
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      return value;
    }
  };
  var _default2 = Numeric;
  exports$1.default = _default2;
  module2.exports = Numeric;
})(numeric, numeric.exports);
var numericExports = numeric.exports;
var smallmoney = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _moneyn2 = _interopRequireDefault2(moneynExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const DATA_LENGTH = Buffer.from([4]);
  const NULL_LENGTH = Buffer.from([0]);
  const SmallMoney = {
    id: 122,
    type: "MONEY4",
    name: "SmallMoney",
    declaration: function() {
      return "smallmoney";
    },
    generateTypeInfo: function() {
      return Buffer.from([_moneyn2.default.id, 4]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeInt32LE(parameter.value * 1e4, 0);
      yield buffer2;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      value = parseFloat(value);
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      if (value < -214748.3648 || value > 214748.3647) {
        throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
      }
      return value;
    }
  };
  var _default2 = SmallMoney;
  exports$1.default = _default2;
  module2.exports = SmallMoney;
})(smallmoney, smallmoney.exports);
var smallmoneyExports = smallmoney.exports;
var bigint = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _intn2 = _interopRequireDefault2(intnExports);
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const DATA_LENGTH = Buffer.from([8]);
  const NULL_LENGTH = Buffer.from([0]);
  const BigInt2 = {
    id: 127,
    type: "INT8",
    name: "BigInt",
    declaration: function() {
      return "bigint";
    },
    generateTypeInfo() {
      return Buffer.from([_intn2.default.id, 8]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = new _writableTrackingBuffer2.default(8);
      buffer2.writeInt64LE(Number(parameter.value));
      yield buffer2.data;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "number") {
        value = Number(value);
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid number.");
      }
      if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError(`Value must be between ${Number.MIN_SAFE_INTEGER} and ${Number.MAX_SAFE_INTEGER}, inclusive.  For smaller or bigger numbers, use VarChar type.`);
      }
      return value;
    }
  };
  var _default2 = BigInt2;
  exports$1.default = _default2;
  module2.exports = BigInt2;
})(bigint, bigint.exports);
var bigintExports = bigint.exports;
var image = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
  const Image = {
    id: 34,
    type: "IMAGE",
    name: "Image",
    hasTableName: true,
    declaration: function() {
      return "image";
    },
    resolveLength: function(parameter) {
      if (parameter.value != null) {
        const value = parameter.value;
        return value.length;
      } else {
        return -1;
      }
    },
    generateTypeInfo(parameter) {
      const buffer2 = Buffer.alloc(5);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeInt32LE(parameter.length, 1);
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeInt32LE(parameter.value.length, 0);
      return buffer2;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield parameter.value;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!Buffer.isBuffer(value)) {
        throw new TypeError("Invalid buffer.");
      }
      return value;
    }
  };
  var _default2 = Image;
  exports$1.default = _default2;
  module2.exports = Image;
})(image, image.exports);
var imageExports = image.exports;
var text = { exports: {} };
var lib = { exports: {} };
var buffer = require$$0$5;
var Buffer$1 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer$1) {
  if (!Buffer$1.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer$1[key];
}
safer.Buffer.prototype = Buffer$1.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$1(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$1(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var bomHandling = {};
var BOMChar = "\uFEFF";
bomHandling.PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options) {
  this.encoder = encoder;
  this.addBOM = true;
}
PrependBOMWrapper.prototype.write = function(str) {
  if (this.addBOM) {
    str = BOMChar + str;
    this.addBOM = false;
  }
  return this.encoder.write(str);
};
PrependBOMWrapper.prototype.end = function() {
  return this.encoder.end();
};
bomHandling.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options || {};
}
StripBOMWrapper.prototype.write = function(buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res)
    return res;
  if (res[0] === BOMChar) {
    res = res.slice(1);
    if (typeof this.options.stripBOM === "function")
      this.options.stripBOM();
  }
  this.pass = true;
  return res;
};
StripBOMWrapper.prototype.end = function() {
  return this.decoder.end();
};
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = safer_1.Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$4.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = safer_1.Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src2 = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src2.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src2.length && overflow.length < 4; i++)
        overflow.push(src2[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src2.length - 3; i += 4) {
      if (isLE) {
        codepoint = src2[i] | src2[i + 1] << 8 | src2[i + 2] << 16 | src2[i + 3] << 24;
      } else {
        codepoint = src2[i + 3] | src2[i + 2] << 8 | src2[i + 1] << 16 | src2[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src2.length; i++) {
      overflow.push(src2[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = safer_1.Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = safer_1.Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = safer_1.Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = safer_1.Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node2[bytes[i2]];
      if (val == UNASSIGNED) {
        node2[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table2, val) {
    if (table2[0] > val)
      return -1;
    var l = 0, r = table2.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table2[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
const require$$2 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports$1) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module2 = modules[i];
      for (var enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports$1[enc] = module2[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = safer_1.Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
(function(module2) {
  var Buffer2 = safer_1.Buffer;
  var bomHandling$1 = bomHandling, iconv = module2.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode2(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = requireEncodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef)
            codecOptions[key2] = codecDef[key2];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling$1.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling$1.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams2 = requireStreams()(stream_module2);
    iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e) {
  }
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
})(lib);
var libExports = lib.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _iconvLite = _interopRequireDefault2(libExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
  const Text = {
    id: 35,
    type: "TEXT",
    name: "Text",
    hasTableName: true,
    declaration: function() {
      return "text";
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (value != null) {
        return value.length;
      } else {
        return -1;
      }
    },
    generateTypeInfo(parameter, _options) {
      const buffer2 = Buffer.alloc(10);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeInt32LE(parameter.length, 1);
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 5, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      const value = parameter.value;
      if (value == null) {
        return NULL_LENGTH;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeInt32LE(value.length, 0);
      return buffer2;
    },
    generateParameterData: function* (parameter, options) {
      const value = parameter.value;
      if (value == null) {
        return;
      }
      yield value;
    },
    validate: function(value, collation2) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      if (!collation2) {
        throw new Error("No collation was set by the server for the current connection.");
      }
      if (!collation2.codepage) {
        throw new Error("The collation set by the server has no associated encoding.");
      }
      return _iconvLite.default.encode(value, collation2.codepage);
    }
  };
  var _default2 = Text;
  exports$1.default = _default2;
  module2.exports = Text;
})(text, text.exports);
var textExports = text.exports;
var uniqueidentifier = { exports: {} };
var guidParser = {};
Object.defineProperty(guidParser, "__esModule", {
  value: true
});
guidParser.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
guidParser.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
guidParser.guidToArray = guidToArray;
const UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
const LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function bufferToUpperCaseGuid(buffer2) {
  return UPPER_CASE_MAP[buffer2[3]] + UPPER_CASE_MAP[buffer2[2]] + UPPER_CASE_MAP[buffer2[1]] + UPPER_CASE_MAP[buffer2[0]] + "-" + UPPER_CASE_MAP[buffer2[5]] + UPPER_CASE_MAP[buffer2[4]] + "-" + UPPER_CASE_MAP[buffer2[7]] + UPPER_CASE_MAP[buffer2[6]] + "-" + UPPER_CASE_MAP[buffer2[8]] + UPPER_CASE_MAP[buffer2[9]] + "-" + UPPER_CASE_MAP[buffer2[10]] + UPPER_CASE_MAP[buffer2[11]] + UPPER_CASE_MAP[buffer2[12]] + UPPER_CASE_MAP[buffer2[13]] + UPPER_CASE_MAP[buffer2[14]] + UPPER_CASE_MAP[buffer2[15]];
}
function bufferToLowerCaseGuid(buffer2) {
  return LOWER_CASE_MAP[buffer2[3]] + LOWER_CASE_MAP[buffer2[2]] + LOWER_CASE_MAP[buffer2[1]] + LOWER_CASE_MAP[buffer2[0]] + "-" + LOWER_CASE_MAP[buffer2[5]] + LOWER_CASE_MAP[buffer2[4]] + "-" + LOWER_CASE_MAP[buffer2[7]] + LOWER_CASE_MAP[buffer2[6]] + "-" + LOWER_CASE_MAP[buffer2[8]] + LOWER_CASE_MAP[buffer2[9]] + "-" + LOWER_CASE_MAP[buffer2[10]] + LOWER_CASE_MAP[buffer2[11]] + LOWER_CASE_MAP[buffer2[12]] + LOWER_CASE_MAP[buffer2[13]] + LOWER_CASE_MAP[buffer2[14]] + LOWER_CASE_MAP[buffer2[15]];
}
const CHARCODEMAP = {};
const hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
for (let i = 0; i < hexDigits.length; i++) {
  const map = CHARCODEMAP[hexDigits[i]] = {};
  for (let j = 0; j < hexDigits.length; j++) {
    const hex = String.fromCharCode(hexDigits[i], hexDigits[j]);
    const value = parseInt(hex, 16);
    map[hexDigits[j]] = value;
  }
}
function guidToArray(guid) {
  return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
}
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _guidParser = guidParser;
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([16]);
  const UniqueIdentifier = {
    id: 36,
    type: "GUIDN",
    name: "UniqueIdentifier",
    declaration: function() {
      return "uniqueidentifier";
    },
    resolveLength: function() {
      return 16;
    },
    generateTypeInfo() {
      return Buffer.from([this.id, 16]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    generateParameterData: function* (parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
        throw new TypeError("Invalid GUID.");
      }
      return value;
    }
  };
  var _default2 = UniqueIdentifier;
  exports$1.default = _default2;
  module2.exports = UniqueIdentifier;
})(uniqueidentifier, uniqueidentifier.exports);
var uniqueidentifierExports = uniqueidentifier.exports;
var ntext = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
  const NText = {
    id: 99,
    type: "NTEXT",
    name: "NText",
    hasTableName: true,
    declaration: function() {
      return "ntext";
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (value != null) {
        return value.length;
      } else {
        return -1;
      }
    },
    generateTypeInfo(parameter, _options) {
      const buffer2 = Buffer.alloc(10);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeInt32LE(parameter.length, 1);
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 5, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const buffer2 = Buffer.alloc(4);
      buffer2.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
      return buffer2;
    },
    generateParameterData: function* (parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield Buffer.from(parameter.value.toString(), "ucs2");
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      return value;
    }
  };
  var _default2 = NText;
  exports$1.default = _default2;
  module2.exports = NText;
})(ntext, ntext.exports);
var ntextExports = ntext.exports;
var varbinary = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const MAX2 = (1 << 16) - 1;
  const UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
  const PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
  const NULL_LENGTH = Buffer.from([255, 255]);
  const MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
  const VarBinary = {
    id: 165,
    type: "BIGVARBIN",
    name: "VarBinary",
    maximumLength: 8e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (value != null) {
        length = value.length || 1;
      } else if (value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      if (length <= this.maximumLength) {
        return "varbinary(" + length + ")";
      } else {
        return "varbinary(max)";
      }
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (parameter.length != null) {
        return parameter.length;
      } else if (value != null) {
        return value.length;
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo: function(parameter) {
      const buffer2 = Buffer.alloc(3);
      buffer2.writeUInt8(this.id, 0);
      if (parameter.length <= this.maximumLength) {
        buffer2.writeUInt16LE(parameter.length, 1);
      } else {
        buffer2.writeUInt16LE(MAX2, 1);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        if (parameter.length <= this.maximumLength) {
          return NULL_LENGTH;
        } else {
          return MAX_NULL_LENGTH;
        }
      }
      let value = parameter.value;
      if (!Buffer.isBuffer(value)) {
        value = value.toString();
      }
      const length = Buffer.byteLength(value, "ucs2");
      if (parameter.length <= this.maximumLength) {
        const buffer2 = Buffer.alloc(2);
        buffer2.writeUInt16LE(length, 0);
        return buffer2;
      } else {
        return UNKNOWN_PLP_LEN;
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      let value = parameter.value;
      if (parameter.length <= this.maximumLength) {
        if (Buffer.isBuffer(value)) {
          yield value;
        } else {
          yield Buffer.from(value.toString(), "ucs2");
        }
      } else {
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (length > 0) {
          const buffer2 = Buffer.alloc(4);
          buffer2.writeUInt32LE(length, 0);
          yield buffer2;
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value, "ucs2");
          }
        }
        yield PLP_TERMINATOR;
      }
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!Buffer.isBuffer(value)) {
        throw new TypeError("Invalid buffer.");
      }
      return value;
    }
  };
  var _default2 = VarBinary;
  exports$1.default = _default2;
  module2.exports = VarBinary;
})(varbinary, varbinary.exports);
var varbinaryExports = varbinary.exports;
var varchar = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _iconvLite = _interopRequireDefault2(libExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const MAX2 = (1 << 16) - 1;
  const UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
  const PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
  const NULL_LENGTH = Buffer.from([255, 255]);
  const MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
  const VarChar = {
    id: 167,
    type: "BIGVARCHR",
    name: "VarChar",
    maximumLength: 8e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (value != null) {
        length = value.length || 1;
      } else if (value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      if (length <= this.maximumLength) {
        return "varchar(" + length + ")";
      } else {
        return "varchar(max)";
      }
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (parameter.length != null) {
        return parameter.length;
      } else if (value != null) {
        return value.length || 1;
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo(parameter) {
      const buffer2 = Buffer.alloc(8);
      buffer2.writeUInt8(this.id, 0);
      if (parameter.length <= this.maximumLength) {
        buffer2.writeUInt16LE(parameter.length, 1);
      } else {
        buffer2.writeUInt16LE(MAX2, 1);
      }
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 3, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      const value = parameter.value;
      if (value == null) {
        if (parameter.length <= this.maximumLength) {
          return NULL_LENGTH;
        } else {
          return MAX_NULL_LENGTH;
        }
      }
      if (parameter.length <= this.maximumLength) {
        const buffer2 = Buffer.alloc(2);
        buffer2.writeUInt16LE(value.length, 0);
        return buffer2;
      } else {
        return UNKNOWN_PLP_LEN;
      }
    },
    *generateParameterData(parameter, options) {
      const value = parameter.value;
      if (value == null) {
        return;
      }
      if (parameter.length <= this.maximumLength) {
        yield value;
      } else {
        if (value.length > 0) {
          const buffer2 = Buffer.alloc(4);
          buffer2.writeUInt32LE(value.length, 0);
          yield buffer2;
          yield value;
        }
        yield PLP_TERMINATOR;
      }
    },
    validate: function(value, collation2) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      if (!collation2) {
        throw new Error("No collation was set by the server for the current connection.");
      }
      if (!collation2.codepage) {
        throw new Error("The collation set by the server has no associated encoding.");
      }
      return _iconvLite.default.encode(value, collation2.codepage);
    }
  };
  var _default2 = VarChar;
  exports$1.default = _default2;
  module2.exports = VarChar;
})(varchar, varchar.exports);
var varcharExports = varchar.exports;
var binary = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const NULL_LENGTH = Buffer.from([255, 255]);
  const Binary = {
    id: 173,
    type: "BIGBinary",
    name: "Binary",
    maximumLength: 8e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (value != null) {
        length = value.length || 1;
      } else if (value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      return "binary(" + length + ")";
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (value != null) {
        return value.length;
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo(parameter) {
      const buffer2 = Buffer.alloc(3);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeUInt16LE(parameter.length, 1);
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const buffer2 = Buffer.alloc(2);
      buffer2.writeUInt16LE(parameter.length, 0);
      return buffer2;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!Buffer.isBuffer(value)) {
        throw new TypeError("Invalid buffer.");
      }
      return value;
    }
  };
  var _default2 = Binary;
  exports$1.default = _default2;
  module2.exports = Binary;
})(binary, binary.exports);
var binaryExports = binary.exports;
var char = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _iconvLite = _interopRequireDefault2(libExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([255, 255]);
  const Char = {
    id: 175,
    type: "BIGCHAR",
    name: "Char",
    maximumLength: 8e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (value != null) {
        length = value.length || 1;
      } else if (value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      if (length < this.maximumLength) {
        return "char(" + length + ")";
      } else {
        return "char(" + this.maximumLength + ")";
      }
    },
    // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (parameter.length != null) {
        return parameter.length;
      } else if (value != null) {
        return value.length || 1;
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo(parameter) {
      const buffer2 = Buffer.alloc(8);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeUInt16LE(parameter.length, 1);
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 3, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      const value = parameter.value;
      if (value == null) {
        return NULL_LENGTH;
      }
      const buffer2 = Buffer.alloc(2);
      buffer2.writeUInt16LE(value.length, 0);
      return buffer2;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      yield Buffer.from(parameter.value, "ascii");
    },
    validate: function(value, collation2) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      if (!collation2) {
        throw new Error("No collation was set by the server for the current connection.");
      }
      if (!collation2.codepage) {
        throw new Error("The collation set by the server has no associated encoding.");
      }
      return _iconvLite.default.encode(value, collation2.codepage);
    }
  };
  var _default2 = Char;
  exports$1.default = _default2;
  module2.exports = Char;
})(char, char.exports);
var charExports = char.exports;
var nvarchar = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const MAX2 = (1 << 16) - 1;
  const UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
  const PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
  const NULL_LENGTH = Buffer.from([255, 255]);
  const MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
  const NVarChar = {
    id: 231,
    type: "NVARCHAR",
    name: "NVarChar",
    maximumLength: 4e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (value != null) {
        length = value.toString().length || 1;
      } else if (value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      if (length <= this.maximumLength) {
        return "nvarchar(" + length + ")";
      } else {
        return "nvarchar(max)";
      }
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (parameter.length != null) {
        return parameter.length;
      } else if (value != null) {
        if (Buffer.isBuffer(value)) {
          return value.length / 2 || 1;
        } else {
          return value.toString().length || 1;
        }
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo(parameter) {
      const buffer2 = Buffer.alloc(8);
      buffer2.writeUInt8(this.id, 0);
      if (parameter.length <= this.maximumLength) {
        buffer2.writeUInt16LE(parameter.length * 2, 1);
      } else {
        buffer2.writeUInt16LE(MAX2, 1);
      }
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 3, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        if (parameter.length <= this.maximumLength) {
          return NULL_LENGTH;
        } else {
          return MAX_NULL_LENGTH;
        }
      }
      let value = parameter.value;
      if (parameter.length <= this.maximumLength) {
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, "ucs2");
        }
        const buffer2 = Buffer.alloc(2);
        buffer2.writeUInt16LE(length, 0);
        return buffer2;
      } else {
        return UNKNOWN_PLP_LEN;
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      let value = parameter.value;
      if (parameter.length <= this.maximumLength) {
        if (value instanceof Buffer) {
          yield value;
        } else {
          value = value.toString();
          yield Buffer.from(value, "ucs2");
        }
      } else {
        if (value instanceof Buffer) {
          const length = value.length;
          if (length > 0) {
            const buffer2 = Buffer.alloc(4);
            buffer2.writeUInt32LE(length, 0);
            yield buffer2;
            yield value;
          }
        } else {
          value = value.toString();
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer2 = Buffer.alloc(4);
            buffer2.writeUInt32LE(length, 0);
            yield buffer2;
            yield Buffer.from(value, "ucs2");
          }
        }
        yield PLP_TERMINATOR;
      }
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      return value;
    }
  };
  var _default2 = NVarChar;
  exports$1.default = _default2;
  module2.exports = NVarChar;
})(nvarchar, nvarchar.exports);
var nvarcharExports = nvarchar.exports;
var nchar = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const NULL_LENGTH = Buffer.from([255, 255]);
  const NChar = {
    id: 239,
    type: "NCHAR",
    name: "NChar",
    maximumLength: 4e3,
    declaration: function(parameter) {
      const value = parameter.value;
      let length;
      if (parameter.length) {
        length = parameter.length;
      } else if (parameter.value != null) {
        length = value.toString().length || 1;
      } else if (parameter.value === null && !parameter.output) {
        length = 1;
      } else {
        length = this.maximumLength;
      }
      if (length < this.maximumLength) {
        return "nchar(" + length + ")";
      } else {
        return "nchar(" + this.maximumLength + ")";
      }
    },
    resolveLength: function(parameter) {
      const value = parameter.value;
      if (parameter.length != null) {
        return parameter.length;
      } else if (parameter.value != null) {
        if (Buffer.isBuffer(parameter.value)) {
          return parameter.value.length / 2 || 1;
        } else {
          return value.toString().length || 1;
        }
      } else {
        return this.maximumLength;
      }
    },
    generateTypeInfo: function(parameter) {
      const buffer2 = Buffer.alloc(8);
      buffer2.writeUInt8(this.id, 0);
      buffer2.writeUInt16LE(parameter.length * 2, 1);
      if (parameter.collation) {
        parameter.collation.toBuffer().copy(buffer2, 3, 0, 5);
      }
      return buffer2;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const {
        value
      } = parameter;
      if (value instanceof Buffer) {
        const length = value.length;
        const buffer2 = Buffer.alloc(2);
        buffer2.writeUInt16LE(length, 0);
        return buffer2;
      } else {
        const length = Buffer.byteLength(value.toString(), "ucs2");
        const buffer2 = Buffer.alloc(2);
        buffer2.writeUInt16LE(length, 0);
        return buffer2;
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value;
      if (value instanceof Buffer) {
        yield value;
      } else {
        yield Buffer.from(value, "ucs2");
      }
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "string") {
        throw new TypeError("Invalid string.");
      }
      return value;
    }
  };
  var _default2 = NChar;
  exports$1.default = _default2;
  module2.exports = NChar;
})(nchar, nchar.exports);
var ncharExports = nchar.exports;
var xml = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const XML = {
    id: 241,
    type: "XML",
    name: "Xml",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = XML;
  exports$1.default = _default2;
  module2.exports = XML;
})(xml, xml.exports);
var xmlExports = xml.exports;
var time = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL_LENGTH = Buffer.from([0]);
  const Time = {
    id: 41,
    type: "TIMEN",
    name: "Time",
    declaration: function(parameter) {
      return "time(" + this.resolveScale(parameter) + ")";
    },
    resolveScale: function(parameter) {
      if (parameter.scale != null) {
        return parameter.scale;
      } else if (parameter.value === null) {
        return 0;
      } else {
        return 7;
      }
    },
    generateTypeInfo(parameter) {
      return Buffer.from([this.id, parameter.scale]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      switch (parameter.scale) {
        case 0:
        case 1:
        case 2:
          return Buffer.from([3]);
        case 3:
        case 4:
          return Buffer.from([4]);
        case 5:
        case 6:
        case 7:
          return Buffer.from([5]);
        default:
          throw new Error("invalid scale");
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const buffer2 = new _writableTrackingBuffer2.default(16);
      const time2 = parameter.value;
      let timestamp;
      if (options.useUTC) {
        timestamp = ((time2.getUTCHours() * 60 + time2.getUTCMinutes()) * 60 + time2.getUTCSeconds()) * 1e3 + time2.getUTCMilliseconds();
      } else {
        timestamp = ((time2.getHours() * 60 + time2.getMinutes()) * 60 + time2.getSeconds()) * 1e3 + time2.getMilliseconds();
      }
      timestamp = timestamp * Math.pow(10, parameter.scale - 3);
      timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
      timestamp = Math.round(timestamp);
      switch (parameter.scale) {
        case 0:
        case 1:
        case 2:
          buffer2.writeUInt24LE(timestamp);
          break;
        case 3:
        case 4:
          buffer2.writeUInt32LE(timestamp);
          break;
        case 5:
        case 6:
        case 7:
          buffer2.writeUInt40LE(timestamp);
      }
      yield buffer2.data;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof Date)) {
        value = new Date(Date.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid time.");
      }
      return value;
    }
  };
  var _default2 = Time;
  exports$1.default = _default2;
  module2.exports = Time;
})(time, time.exports);
var timeExports = time.exports;
var date = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _core = require$$0$1;
  const globalDate = commonjsGlobal.Date;
  const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
  const NULL_LENGTH = Buffer.from([0]);
  const DATA_LENGTH = Buffer.from([3]);
  const Date2 = {
    id: 40,
    type: "DATEN",
    name: "Date",
    declaration: function() {
      return "date";
    },
    generateTypeInfo: function() {
      return Buffer.from([this.id]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      return DATA_LENGTH;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value;
      let date2;
      if (options.useUTC) {
        date2 = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
      } else {
        date2 = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
      }
      const days = EPOCH_DATE.until(date2, _core.ChronoUnit.DAYS);
      const buffer2 = Buffer.alloc(3);
      buffer2.writeUIntLE(days, 0, 3);
      yield buffer2;
    },
    // TODO: value is techincally of type 'unknown'.
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof globalDate)) {
        value = new globalDate(globalDate.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid date.");
      }
      return value;
    }
  };
  var _default2 = Date2;
  exports$1.default = _default2;
  module2.exports = Date2;
})(date, date.exports);
var dateExports = date.exports;
var datetime2 = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _core = require$$0$1;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
  const NULL_LENGTH = Buffer.from([0]);
  const DateTime2 = {
    id: 42,
    type: "DATETIME2N",
    name: "DateTime2",
    declaration: function(parameter) {
      return "datetime2(" + this.resolveScale(parameter) + ")";
    },
    resolveScale: function(parameter) {
      if (parameter.scale != null) {
        return parameter.scale;
      } else if (parameter.value === null) {
        return 0;
      } else {
        return 7;
      }
    },
    generateTypeInfo(parameter, _options) {
      return Buffer.from([this.id, parameter.scale]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      switch (parameter.scale) {
        case 0:
        case 1:
        case 2:
          return Buffer.from([6]);
        case 3:
        case 4:
          return Buffer.from([7]);
        case 5:
        case 6:
        case 7:
          return Buffer.from([8]);
        default:
          throw new Error("invalid scale");
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value;
      let scale = parameter.scale;
      const buffer2 = new _writableTrackingBuffer2.default(16);
      scale = scale;
      let timestamp;
      if (options.useUTC) {
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
      } else {
        timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
      }
      timestamp = timestamp * Math.pow(10, scale - 3);
      timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
      timestamp = Math.round(timestamp);
      switch (scale) {
        case 0:
        case 1:
        case 2:
          buffer2.writeUInt24LE(timestamp);
          break;
        case 3:
        case 4:
          buffer2.writeUInt32LE(timestamp);
          break;
        case 5:
        case 6:
        case 7:
          buffer2.writeUInt40LE(timestamp);
      }
      let date2;
      if (options.useUTC) {
        date2 = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
      } else {
        date2 = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
      }
      const days = EPOCH_DATE.until(date2, _core.ChronoUnit.DAYS);
      buffer2.writeUInt24LE(days);
      yield buffer2.data;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof Date)) {
        value = new Date(Date.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid date.");
      }
      return value;
    }
  };
  var _default2 = DateTime2;
  exports$1.default = _default2;
  module2.exports = DateTime2;
})(datetime2, datetime2.exports);
var datetime2Exports = datetime2.exports;
var datetimeoffset = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _core = require$$0$1;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
  const NULL_LENGTH = Buffer.from([0]);
  const DateTimeOffset = {
    id: 43,
    type: "DATETIMEOFFSETN",
    name: "DateTimeOffset",
    declaration: function(parameter) {
      return "datetimeoffset(" + this.resolveScale(parameter) + ")";
    },
    resolveScale: function(parameter) {
      if (parameter.scale != null) {
        return parameter.scale;
      } else if (parameter.value === null) {
        return 0;
      } else {
        return 7;
      }
    },
    generateTypeInfo(parameter) {
      return Buffer.from([this.id, parameter.scale]);
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      switch (parameter.scale) {
        case 0:
        case 1:
        case 2:
          return Buffer.from([8]);
        case 3:
        case 4:
          return Buffer.from([9]);
        case 5:
        case 6:
        case 7:
          return Buffer.from([10]);
        default:
          throw new Error("invalid scale");
      }
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        return;
      }
      const value = parameter.value;
      let scale = parameter.scale;
      const buffer2 = new _writableTrackingBuffer2.default(16);
      scale = scale;
      let timestamp;
      timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
      timestamp = timestamp * Math.pow(10, scale - 3);
      timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
      timestamp = Math.round(timestamp);
      switch (scale) {
        case 0:
        case 1:
        case 2:
          buffer2.writeUInt24LE(timestamp);
          break;
        case 3:
        case 4:
          buffer2.writeUInt32LE(timestamp);
          break;
        case 5:
        case 6:
        case 7:
          buffer2.writeUInt40LE(timestamp);
      }
      const date2 = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
      const days = EPOCH_DATE.until(date2, _core.ChronoUnit.DAYS);
      buffer2.writeUInt24LE(days);
      const offset = -value.getTimezoneOffset();
      buffer2.writeInt16LE(offset);
      yield buffer2.data;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (!(value instanceof Date)) {
        value = new Date(Date.parse(value));
      }
      if (isNaN(value)) {
        throw new TypeError("Invalid date.");
      }
      return value;
    }
  };
  var _default2 = DateTimeOffset;
  exports$1.default = _default2;
  module2.exports = DateTimeOffset;
})(datetimeoffset, datetimeoffset.exports);
var datetimeoffsetExports = datetimeoffset.exports;
var udt$1 = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const UDT2 = {
    id: 240,
    type: "UDTTYPE",
    name: "UDT",
    declaration() {
      throw new Error("not implemented");
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = UDT2;
  exports$1.default = _default2;
  module2.exports = UDT2;
})(udt$1, udt$1.exports);
var udtExports = udt$1.exports;
var tvp = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _writableTrackingBuffer2 = _interopRequireDefault2(writableTrackingBufferExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const TVP_ROW_TOKEN = Buffer.from([1]);
  const TVP_END_TOKEN = Buffer.from([0]);
  const NULL_LENGTH = Buffer.from([255, 255]);
  const TVP = {
    id: 243,
    type: "TVPTYPE",
    name: "TVP",
    declaration: function(parameter) {
      const value = parameter.value;
      return value.name + " readonly";
    },
    generateTypeInfo(parameter) {
      var _parameter$value, _parameter$value2;
      const databaseName = "";
      const schema = ((_parameter$value = parameter.value) === null || _parameter$value === void 0 ? void 0 : _parameter$value.schema) ?? "";
      const typeName = ((_parameter$value2 = parameter.value) === null || _parameter$value2 === void 0 ? void 0 : _parameter$value2.name) ?? "";
      const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
      const buffer2 = new _writableTrackingBuffer2.default(bufferLength, "ucs2");
      buffer2.writeUInt8(this.id);
      buffer2.writeBVarchar(databaseName);
      buffer2.writeBVarchar(schema);
      buffer2.writeBVarchar(typeName);
      return buffer2.data;
    },
    generateParameterLength(parameter, options) {
      if (parameter.value == null) {
        return NULL_LENGTH;
      }
      const {
        columns
      } = parameter.value;
      const buffer2 = Buffer.alloc(2);
      buffer2.writeUInt16LE(columns.length, 0);
      return buffer2;
    },
    *generateParameterData(parameter, options) {
      if (parameter.value == null) {
        yield TVP_END_TOKEN;
        yield TVP_END_TOKEN;
        return;
      }
      const {
        columns,
        rows
      } = parameter.value;
      for (let i = 0, len = columns.length; i < len; i++) {
        const column = columns[i];
        const buff = Buffer.alloc(6);
        buff.writeUInt32LE(0, 0);
        buff.writeUInt16LE(0, 4);
        yield buff;
        yield column.type.generateTypeInfo(column);
        yield Buffer.from([0]);
      }
      yield TVP_END_TOKEN;
      for (let i = 0, length = rows.length; i < length; i++) {
        yield TVP_ROW_TOKEN;
        const row = rows[i];
        for (let k = 0, len2 = row.length; k < len2; k++) {
          const column = columns[k];
          const value = row[k];
          const param = {
            value: column.type.validate(value, parameter.collation),
            length: column.length,
            scale: column.scale,
            precision: column.precision
          };
          yield column.type.generateParameterLength(param, options);
          yield* column.type.generateParameterData(param, options);
        }
      }
      yield TVP_END_TOKEN;
    },
    validate: function(value) {
      if (value == null) {
        return null;
      }
      if (typeof value !== "object") {
        throw new TypeError("Invalid table.");
      }
      if (!Array.isArray(value.columns)) {
        throw new TypeError("Invalid table.");
      }
      if (!Array.isArray(value.rows)) {
        throw new TypeError("Invalid table.");
      }
      return value;
    }
  };
  var _default2 = TVP;
  exports$1.default = _default2;
  module2.exports = TVP;
})(tvp, tvp.exports);
var tvpExports = tvp.exports;
var sqlVariant = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  const Variant = {
    id: 98,
    type: "SSVARIANTTYPE",
    name: "Variant",
    declaration: function() {
      return "sql_variant";
    },
    generateTypeInfo() {
      throw new Error("not implemented");
    },
    generateParameterLength() {
      throw new Error("not implemented");
    },
    generateParameterData() {
      throw new Error("not implemented");
    },
    validate() {
      throw new Error("not implemented");
    }
  };
  var _default2 = Variant;
  exports$1.default = _default2;
  module2.exports = Variant;
})(sqlVariant, sqlVariant.exports);
var sqlVariantExports = sqlVariant.exports;
Object.defineProperty(dataType, "__esModule", {
  value: true
});
dataType.typeByName = dataType.TYPES = dataType.TYPE = void 0;
var _null = _interopRequireDefault$4(_nullExports);
var _tinyint = _interopRequireDefault$4(tinyintExports);
var _bit = _interopRequireDefault$4(bitExports);
var _smallint = _interopRequireDefault$4(smallintExports);
var _int = _interopRequireDefault$4(intExports);
var _smalldatetime = _interopRequireDefault$4(smalldatetimeExports);
var _real = _interopRequireDefault$4(realExports);
var _money = _interopRequireDefault$4(moneyExports);
var _datetime = _interopRequireDefault$4(datetimeExports);
var _float = _interopRequireDefault$4(floatExports);
var _decimal = _interopRequireDefault$4(decimalExports);
var _numeric = _interopRequireDefault$4(numericExports);
var _smallmoney = _interopRequireDefault$4(smallmoneyExports);
var _bigint = _interopRequireDefault$4(bigintExports);
var _image = _interopRequireDefault$4(imageExports);
var _text = _interopRequireDefault$4(textExports);
var _uniqueidentifier = _interopRequireDefault$4(uniqueidentifierExports);
var _intn = _interopRequireDefault$4(intnExports);
var _ntext = _interopRequireDefault$4(ntextExports);
var _bitn = _interopRequireDefault$4(bitnExports);
var _decimaln = _interopRequireDefault$4(decimalnExports);
var _numericn = _interopRequireDefault$4(numericnExports);
var _floatn = _interopRequireDefault$4(floatnExports);
var _moneyn = _interopRequireDefault$4(moneynExports);
var _datetimen = _interopRequireDefault$4(datetimenExports);
var _varbinary = _interopRequireDefault$4(varbinaryExports);
var _varchar = _interopRequireDefault$4(varcharExports);
var _binary = _interopRequireDefault$4(binaryExports);
var _char = _interopRequireDefault$4(charExports);
var _nvarchar = _interopRequireDefault$4(nvarcharExports);
var _nchar = _interopRequireDefault$4(ncharExports);
var _xml = _interopRequireDefault$4(xmlExports);
var _time = _interopRequireDefault$4(timeExports);
var _date = _interopRequireDefault$4(dateExports);
var _datetime2 = _interopRequireDefault$4(datetime2Exports);
var _datetimeoffset = _interopRequireDefault$4(datetimeoffsetExports);
var _udt = _interopRequireDefault$4(udtExports);
var _tvp = _interopRequireDefault$4(tvpExports);
var _sqlVariant = _interopRequireDefault$4(sqlVariantExports);
function _interopRequireDefault$4(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
const TYPE = {
  [_null.default.id]: _null.default,
  [_tinyint.default.id]: _tinyint.default,
  [_bit.default.id]: _bit.default,
  [_smallint.default.id]: _smallint.default,
  [_int.default.id]: _int.default,
  [_smalldatetime.default.id]: _smalldatetime.default,
  [_real.default.id]: _real.default,
  [_money.default.id]: _money.default,
  [_datetime.default.id]: _datetime.default,
  [_float.default.id]: _float.default,
  [_decimal.default.id]: _decimal.default,
  [_numeric.default.id]: _numeric.default,
  [_smallmoney.default.id]: _smallmoney.default,
  [_bigint.default.id]: _bigint.default,
  [_image.default.id]: _image.default,
  [_text.default.id]: _text.default,
  [_uniqueidentifier.default.id]: _uniqueidentifier.default,
  [_intn.default.id]: _intn.default,
  [_ntext.default.id]: _ntext.default,
  [_bitn.default.id]: _bitn.default,
  [_decimaln.default.id]: _decimaln.default,
  [_numericn.default.id]: _numericn.default,
  [_floatn.default.id]: _floatn.default,
  [_moneyn.default.id]: _moneyn.default,
  [_datetimen.default.id]: _datetimen.default,
  [_varbinary.default.id]: _varbinary.default,
  [_varchar.default.id]: _varchar.default,
  [_binary.default.id]: _binary.default,
  [_char.default.id]: _char.default,
  [_nvarchar.default.id]: _nvarchar.default,
  [_nchar.default.id]: _nchar.default,
  [_xml.default.id]: _xml.default,
  [_time.default.id]: _time.default,
  [_date.default.id]: _date.default,
  [_datetime2.default.id]: _datetime2.default,
  [_datetimeoffset.default.id]: _datetimeoffset.default,
  [_udt.default.id]: _udt.default,
  [_tvp.default.id]: _tvp.default,
  [_sqlVariant.default.id]: _sqlVariant.default
};
dataType.TYPE = TYPE;
const TYPES$1 = {
  TinyInt: _tinyint.default,
  Bit: _bit.default,
  SmallInt: _smallint.default,
  Int: _int.default,
  SmallDateTime: _smalldatetime.default,
  Real: _real.default,
  Money: _money.default,
  DateTime: _datetime.default,
  Float: _float.default,
  Decimal: _decimal.default,
  Numeric: _numeric.default,
  SmallMoney: _smallmoney.default,
  BigInt: _bigint.default,
  Image: _image.default,
  Text: _text.default,
  UniqueIdentifier: _uniqueidentifier.default,
  NText: _ntext.default,
  VarBinary: _varbinary.default,
  VarChar: _varchar.default,
  Binary: _binary.default,
  Char: _char.default,
  NVarChar: _nvarchar.default,
  NChar: _nchar.default,
  Xml: _xml.default,
  Time: _time.default,
  Date: _date.default,
  DateTime2: _datetime2.default,
  DateTimeOffset: _datetimeoffset.default,
  UDT: _udt.default,
  TVP: _tvp.default,
  Variant: _sqlVariant.default
};
dataType.TYPES = TYPES$1;
const typeByName = TYPES$1;
dataType.typeByName = typeByName;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  exports$1.readCollation = readCollation;
  var _collation = collation;
  var _dataType = dataType;
  var _sprintfJs2 = sprintf;
  function readCollation(parser, callback) {
    parser.readBuffer(5, (collationData) => {
      callback(_collation.Collation.fromBuffer(collationData));
    });
  }
  function readSchema(parser, callback) {
    parser.readUInt8((schemaPresent) => {
      if (schemaPresent === 1) {
        parser.readBVarChar((dbname) => {
          parser.readBVarChar((owningSchema) => {
            parser.readUsVarChar((xmlSchemaCollection) => {
              callback({
                dbname,
                owningSchema,
                xmlSchemaCollection
              });
            });
          });
        });
      } else {
        callback(void 0);
      }
    });
  }
  function readUDTInfo(parser, callback) {
    parser.readUInt16LE((maxByteSize) => {
      parser.readBVarChar((dbname) => {
        parser.readBVarChar((owningSchema) => {
          parser.readBVarChar((typeName) => {
            parser.readUsVarChar((assemblyName) => {
              callback({
                maxByteSize,
                dbname,
                owningSchema,
                typeName,
                assemblyName
              });
            });
          });
        });
      });
    });
  }
  function metadataParse(parser, options, callback) {
    (options.tdsVersion < "7_2" ? parser.readUInt16LE : parser.readUInt32LE).call(parser, (userType) => {
      parser.readUInt16LE((flags) => {
        parser.readUInt8((typeNumber) => {
          const type2 = _dataType.TYPE[typeNumber];
          if (!type2) {
            throw new Error((0, _sprintfJs2.sprintf)("Unrecognised data type 0x%02X", typeNumber));
          }
          switch (type2.name) {
            case "Null":
            case "TinyInt":
            case "SmallInt":
            case "Int":
            case "BigInt":
            case "Real":
            case "Float":
            case "SmallMoney":
            case "Money":
            case "Bit":
            case "SmallDateTime":
            case "DateTime":
            case "Date":
              return callback({
                userType,
                flags,
                type: type2,
                collation: void 0,
                precision: void 0,
                scale: void 0,
                dataLength: void 0,
                schema: void 0,
                udtInfo: void 0
              });
            case "IntN":
            case "FloatN":
            case "MoneyN":
            case "BitN":
            case "UniqueIdentifier":
            case "DateTimeN":
              return parser.readUInt8((dataLength) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength,
                  schema: void 0,
                  udtInfo: void 0
                });
              });
            case "Variant":
              return parser.readUInt32LE((dataLength) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength,
                  schema: void 0,
                  udtInfo: void 0
                });
              });
            case "VarChar":
            case "Char":
            case "NVarChar":
            case "NChar":
              return parser.readUInt16LE((dataLength) => {
                readCollation(parser, (collation2) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: collation2,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              });
            case "Text":
            case "NText":
              return parser.readUInt32LE((dataLength) => {
                readCollation(parser, (collation2) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: collation2,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              });
            case "VarBinary":
            case "Binary":
              return parser.readUInt16LE((dataLength) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength,
                  schema: void 0,
                  udtInfo: void 0
                });
              });
            case "Image":
              return parser.readUInt32LE((dataLength) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength,
                  schema: void 0,
                  udtInfo: void 0
                });
              });
            case "Xml":
              return readSchema(parser, (schema) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength: void 0,
                  schema,
                  udtInfo: void 0
                });
              });
            case "Time":
            case "DateTime2":
            case "DateTimeOffset":
              return parser.readUInt8((scale) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale,
                  dataLength: void 0,
                  schema: void 0,
                  udtInfo: void 0
                });
              });
            case "NumericN":
            case "DecimalN":
              return parser.readUInt8((dataLength) => {
                parser.readUInt8((precision) => {
                  parser.readUInt8((scale) => {
                    callback({
                      userType,
                      flags,
                      type: type2,
                      collation: void 0,
                      precision,
                      scale,
                      dataLength,
                      schema: void 0,
                      udtInfo: void 0
                    });
                  });
                });
              });
            case "UDT":
              return readUDTInfo(parser, (udtInfo) => {
                callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength: void 0,
                  schema: void 0,
                  udtInfo
                });
              });
            default:
              throw new Error((0, _sprintfJs2.sprintf)("Unrecognised type %s", type2.name));
          }
        });
      });
    });
  }
  var _default2 = metadataParse;
  exports$1.default = _default2;
  module2.exports = metadataParse;
  module2.exports.readCollation = readCollation;
})(metadataParser, metadataParser.exports);
var metadataParserExports = metadataParser.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _metadataParser = _interopRequireDefault2(metadataParserExports);
  var _token2 = token;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function readTableName(parser, options, metadata, callback) {
    if (metadata.type.hasTableName) {
      if (options.tdsVersion >= "7_2") {
        parser.readUInt8((numberOfTableNameParts) => {
          const tableName = [];
          let i = 0;
          function next(done) {
            if (numberOfTableNameParts === i) {
              return done();
            }
            parser.readUsVarChar((part) => {
              tableName.push(part);
              i++;
              next(done);
            });
          }
          next(() => {
            callback(tableName);
          });
        });
      } else {
        parser.readUsVarChar(callback);
      }
    } else {
      callback(void 0);
    }
  }
  function readColumnName(parser, options, index, metadata, callback) {
    parser.readBVarChar((colName) => {
      if (options.columnNameReplacer) {
        callback(options.columnNameReplacer(colName, index, metadata));
      } else if (options.camelCaseColumns) {
        callback(colName.replace(/^[A-Z]/, function(s) {
          return s.toLowerCase();
        }));
      } else {
        callback(colName);
      }
    });
  }
  function readColumn(parser, options, index, callback) {
    (0, _metadataParser.default)(parser, options, (metadata) => {
      readTableName(parser, options, metadata, (tableName) => {
        readColumnName(parser, options, index, metadata, (colName) => {
          callback({
            userType: metadata.userType,
            flags: metadata.flags,
            type: metadata.type,
            collation: metadata.collation,
            precision: metadata.precision,
            scale: metadata.scale,
            udtInfo: metadata.udtInfo,
            dataLength: metadata.dataLength,
            schema: metadata.schema,
            colName,
            tableName
          });
        });
      });
    });
  }
  async function colMetadataParser(parser) {
    while (parser.buffer.length - parser.position < 2) {
      await parser.streamBuffer.waitForChunk();
    }
    const columnCount = parser.buffer.readUInt16LE(parser.position);
    parser.position += 2;
    const columns = [];
    for (let i = 0; i < columnCount; i++) {
      let column;
      readColumn(parser, parser.options, i, (c) => {
        column = c;
      });
      while (parser.suspended) {
        await parser.streamBuffer.waitForChunk();
        parser.suspended = false;
        const next = parser.next;
        next();
      }
      columns.push(column);
    }
    return new _token2.ColMetadataToken(columns);
  }
  var _default2 = colMetadataParser;
  exports$1.default = _default2;
  module2.exports = colMetadataParser;
})(colmetadataTokenParser, colmetadataTokenParser.exports);
var colmetadataTokenParserExports = colmetadataTokenParser.exports;
var doneTokenParser = {};
Object.defineProperty(doneTokenParser, "__esModule", {
  value: true
});
doneTokenParser.doneInProcParser = doneInProcParser;
doneTokenParser.doneParser = doneParser;
doneTokenParser.doneProcParser = doneProcParser;
var _token$1 = token;
const STATUS = {
  MORE: 1,
  ERROR: 2,
  COUNT: 16,
  ATTN: 32,
  SRVERROR: 256
};
function parseToken$1(parser, options, callback) {
  parser.readUInt16LE((status) => {
    const more = !!(status & STATUS.MORE);
    const sqlError = !!(status & STATUS.ERROR);
    const rowCountValid = !!(status & STATUS.COUNT);
    const attention = !!(status & STATUS.ATTN);
    const serverError = !!(status & STATUS.SRVERROR);
    parser.readUInt16LE((curCmd) => {
      const next = (rowCount) => {
        callback({
          more,
          sqlError,
          attention,
          serverError,
          rowCount: rowCountValid ? rowCount : void 0,
          curCmd
        });
      };
      if (options.tdsVersion < "7_2") {
        parser.readUInt32LE(next);
      } else {
        parser.readBigUInt64LE((rowCount) => {
          next(Number(rowCount));
        });
      }
    });
  });
}
function doneParser(parser, options, callback) {
  parseToken$1(parser, options, (data) => {
    callback(new _token$1.DoneToken(data));
  });
}
function doneInProcParser(parser, options, callback) {
  parseToken$1(parser, options, (data) => {
    callback(new _token$1.DoneInProcToken(data));
  });
}
function doneProcParser(parser, options, callback) {
  parseToken$1(parser, options, (data) => {
    callback(new _token$1.DoneProcToken(data));
  });
}
var envChangeTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _collation = collation;
  var _token2 = token;
  const types2 = {
    1: {
      name: "DATABASE",
      event: "databaseChange"
    },
    2: {
      name: "LANGUAGE",
      event: "languageChange"
    },
    3: {
      name: "CHARSET",
      event: "charsetChange"
    },
    4: {
      name: "PACKET_SIZE",
      event: "packetSizeChange"
    },
    7: {
      name: "SQL_COLLATION",
      event: "sqlCollationChange"
    },
    8: {
      name: "BEGIN_TXN",
      event: "beginTransaction"
    },
    9: {
      name: "COMMIT_TXN",
      event: "commitTransaction"
    },
    10: {
      name: "ROLLBACK_TXN",
      event: "rollbackTransaction"
    },
    13: {
      name: "DATABASE_MIRRORING_PARTNER",
      event: "partnerNode"
    },
    17: {
      name: "TXN_ENDED"
    },
    18: {
      name: "RESET_CONNECTION",
      event: "resetConnection"
    },
    20: {
      name: "ROUTING_CHANGE",
      event: "routingChange"
    }
  };
  function readNewAndOldValue(parser, length, type2, callback) {
    switch (type2.name) {
      case "DATABASE":
      case "LANGUAGE":
      case "CHARSET":
      case "PACKET_SIZE":
      case "DATABASE_MIRRORING_PARTNER":
        return parser.readBVarChar((newValue) => {
          parser.readBVarChar((oldValue) => {
            switch (type2.name) {
              case "PACKET_SIZE":
                return callback(new _token2.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)));
              case "DATABASE":
                return callback(new _token2.DatabaseEnvChangeToken(newValue, oldValue));
              case "LANGUAGE":
                return callback(new _token2.LanguageEnvChangeToken(newValue, oldValue));
              case "CHARSET":
                return callback(new _token2.CharsetEnvChangeToken(newValue, oldValue));
              case "DATABASE_MIRRORING_PARTNER":
                return callback(new _token2.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue));
            }
          });
        });
      case "SQL_COLLATION":
      case "BEGIN_TXN":
      case "COMMIT_TXN":
      case "ROLLBACK_TXN":
      case "RESET_CONNECTION":
        return parser.readBVarByte((newValue) => {
          parser.readBVarByte((oldValue) => {
            switch (type2.name) {
              case "SQL_COLLATION": {
                const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
                const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
                return callback(new _token2.CollationChangeToken(newCollation, oldCollation));
              }
              case "BEGIN_TXN":
                return callback(new _token2.BeginTransactionEnvChangeToken(newValue, oldValue));
              case "COMMIT_TXN":
                return callback(new _token2.CommitTransactionEnvChangeToken(newValue, oldValue));
              case "ROLLBACK_TXN":
                return callback(new _token2.RollbackTransactionEnvChangeToken(newValue, oldValue));
              case "RESET_CONNECTION":
                return callback(new _token2.ResetConnectionEnvChangeToken(newValue, oldValue));
            }
          });
        });
      case "ROUTING_CHANGE":
        return parser.readUInt16LE((valueLength) => {
          parser.readBuffer(valueLength, (routePacket) => {
            const protocol = routePacket.readUInt8(0);
            if (protocol !== 0) {
              throw new Error("Unknown protocol byte in routing change event");
            }
            const port = routePacket.readUInt16LE(1);
            const serverLen = routePacket.readUInt16LE(3);
            const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
            const newValue = {
              protocol,
              port,
              server
            };
            parser.readUInt16LE((oldValueLength) => {
              parser.readBuffer(oldValueLength, (oldValue) => {
                callback(new _token2.RoutingEnvChangeToken(newValue, oldValue));
              });
            });
          });
        });
      default:
        console.error("Tedious > Unsupported ENVCHANGE type " + type2.name);
        parser.readBuffer(length - 1, () => {
          callback(void 0);
        });
    }
  }
  function envChangeParser(parser, _options, callback) {
    parser.readUInt16LE((length) => {
      parser.readUInt8((typeNumber) => {
        const type2 = types2[typeNumber];
        if (!type2) {
          console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
          return parser.readBuffer(length - 1, () => {
            callback(void 0);
          });
        }
        readNewAndOldValue(parser, length, type2, (token2) => {
          callback(token2);
        });
      });
    });
  }
  var _default2 = envChangeParser;
  exports$1.default = _default2;
  module2.exports = envChangeParser;
})(envChangeTokenParser, envChangeTokenParser.exports);
var envChangeTokenParserExports = envChangeTokenParser.exports;
var infoerrorTokenParser = {};
Object.defineProperty(infoerrorTokenParser, "__esModule", {
  value: true
});
infoerrorTokenParser.errorParser = errorParser;
infoerrorTokenParser.infoParser = infoParser;
var _token = token;
function parseToken(parser, options, callback) {
  parser.readUInt16LE(() => {
    parser.readUInt32LE((number) => {
      parser.readUInt8((state2) => {
        parser.readUInt8((clazz) => {
          parser.readUsVarChar((message2) => {
            parser.readBVarChar((serverName) => {
              parser.readBVarChar((procName) => {
                (options.tdsVersion < "7_2" ? parser.readUInt16LE : parser.readUInt32LE).call(parser, (lineNumber) => {
                  callback({
                    "number": number,
                    "state": state2,
                    "class": clazz,
                    "message": message2,
                    "serverName": serverName,
                    "procName": procName,
                    "lineNumber": lineNumber
                  });
                });
              });
            });
          });
        });
      });
    });
  });
}
function infoParser(parser, options, callback) {
  parseToken(parser, options, (data) => {
    callback(new _token.InfoMessageToken(data));
  });
}
function errorParser(parser, options, callback) {
  parseToken(parser, options, (data) => {
    callback(new _token.ErrorMessageToken(data));
  });
}
var fedauthInfoParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  const FEDAUTHINFOID = {
    STSURL: 1,
    SPN: 2
  };
  function fedAuthInfoParser(parser, _options, callback) {
    parser.readUInt32LE((tokenLength) => {
      parser.readBuffer(tokenLength, (data) => {
        let spn, stsurl;
        let offset = 0;
        const countOfInfoIDs = data.readUInt32LE(offset);
        offset += 4;
        for (let i = 0; i < countOfInfoIDs; i++) {
          const fedauthInfoID = data.readUInt8(offset);
          offset += 1;
          const fedAuthInfoDataLen = data.readUInt32LE(offset);
          offset += 4;
          const fedAuthInfoDataOffset = data.readUInt32LE(offset);
          offset += 4;
          switch (fedauthInfoID) {
            case FEDAUTHINFOID.SPN:
              spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
              break;
            case FEDAUTHINFOID.STSURL:
              stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
              break;
          }
        }
        callback(new _token2.FedAuthInfoToken(spn, stsurl));
      });
    });
  }
  var _default2 = fedAuthInfoParser;
  exports$1.default = _default2;
  module2.exports = fedAuthInfoParser;
})(fedauthInfoParser, fedauthInfoParser.exports);
var fedauthInfoParserExports = fedauthInfoParser.exports;
var featureExtAckParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  const FEATURE_ID = {
    FEDAUTH: 2,
    UTF8_SUPPORT: 10,
    TERMINATOR: 255
  };
  function featureExtAckParser2(parser, _options, callback) {
    let fedAuth;
    let utf8Support;
    function next() {
      parser.readUInt8((featureId) => {
        if (featureId === FEATURE_ID.TERMINATOR) {
          return callback(new _token2.FeatureExtAckToken(fedAuth, utf8Support));
        }
        parser.readUInt32LE((featureAckDataLen) => {
          parser.readBuffer(featureAckDataLen, (featureData) => {
            switch (featureId) {
              case FEATURE_ID.FEDAUTH:
                fedAuth = featureData;
                break;
              case FEATURE_ID.UTF8_SUPPORT:
                utf8Support = !!featureData[0];
                break;
            }
            next();
          });
        });
      });
    }
    next();
  }
  var _default2 = featureExtAckParser2;
  exports$1.default = _default2;
  module2.exports = featureExtAckParser2;
})(featureExtAckParser, featureExtAckParser.exports);
var featureExtAckParserExports = featureExtAckParser.exports;
var loginackTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  var _tdsVersions = tdsVersions;
  const interfaceTypes = {
    0: "SQL_DFLT",
    1: "SQL_TSQL"
  };
  function loginAckParser(parser, _options, callback) {
    parser.readUInt16LE(() => {
      parser.readUInt8((interfaceNumber) => {
        const interfaceType = interfaceTypes[interfaceNumber];
        parser.readUInt32BE((tdsVersionNumber) => {
          const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
          parser.readBVarChar((progName) => {
            parser.readUInt8((major2) => {
              parser.readUInt8((minor2) => {
                parser.readUInt8((buildNumHi) => {
                  parser.readUInt8((buildNumLow) => {
                    callback(new _token2.LoginAckToken({
                      interface: interfaceType,
                      tdsVersion,
                      progName,
                      progVersion: {
                        major: major2,
                        minor: minor2,
                        buildNumHi,
                        buildNumLow
                      }
                    }));
                  });
                });
              });
            });
          });
        });
      });
    });
  }
  var _default2 = loginAckParser;
  exports$1.default = _default2;
  module2.exports = loginAckParser;
})(loginackTokenParser, loginackTokenParser.exports);
var loginackTokenParserExports = loginackTokenParser.exports;
var orderTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  function orderParser(parser, _options, callback) {
    parser.readUInt16LE((length) => {
      const columnCount = length / 2;
      const orderColumns = [];
      let i = 0;
      function next(done) {
        if (i === columnCount) {
          return done();
        }
        parser.readUInt16LE((column) => {
          orderColumns.push(column);
          i++;
          next(done);
        });
      }
      next(() => {
        callback(new _token2.OrderToken(orderColumns));
      });
    });
  }
  var _default2 = orderParser;
  exports$1.default = _default2;
  module2.exports = orderParser;
})(orderTokenParser, orderTokenParser.exports);
var orderTokenParserExports = orderTokenParser.exports;
var returnstatusTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  function returnStatusParser(parser, _options, callback) {
    parser.readInt32LE((value) => {
      callback(new _token2.ReturnStatusToken(value));
    });
  }
  var _default2 = returnStatusParser;
  exports$1.default = _default2;
  module2.exports = returnStatusParser;
})(returnstatusTokenParser, returnstatusTokenParser.exports);
var returnstatusTokenParserExports = returnstatusTokenParser.exports;
var returnvalueTokenParser = { exports: {} };
var valueParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _metadataParser = metadataParserExports;
  var _dataType = dataType;
  var _iconvLite = _interopRequireDefault2(libExports);
  var _sprintfJs2 = sprintf;
  var _guidParser = guidParser;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const NULL = (1 << 16) - 1;
  const MAX2 = (1 << 16) - 1;
  const THREE_AND_A_THIRD = 3 + 1 / 3;
  const MONEY_DIVISOR = 1e4;
  const PLP_NULL = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
  const UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
  const DEFAULT_ENCODING = "utf8";
  function readTinyInt(parser, callback) {
    parser.readUInt8(callback);
  }
  function readSmallInt(parser, callback) {
    parser.readInt16LE(callback);
  }
  function readInt(parser, callback) {
    parser.readInt32LE(callback);
  }
  function readBigInt(parser, callback) {
    parser.readBigInt64LE((value) => {
      callback(value.toString());
    });
  }
  function readReal(parser, callback) {
    parser.readFloatLE(callback);
  }
  function readFloat(parser, callback) {
    parser.readDoubleLE(callback);
  }
  function readSmallMoney(parser, callback) {
    parser.readInt32LE((value) => {
      callback(value / MONEY_DIVISOR);
    });
  }
  function readMoney(parser, callback) {
    parser.readInt32LE((high) => {
      parser.readUInt32LE((low) => {
        callback((low + 4294967296 * high) / MONEY_DIVISOR);
      });
    });
  }
  function readBit(parser, callback) {
    parser.readUInt8((value) => {
      callback(!!value);
    });
  }
  function valueParse(parser, metadata, options, callback) {
    const type2 = metadata.type;
    switch (type2.name) {
      case "Null":
        return callback(null);
      case "TinyInt":
        return readTinyInt(parser, callback);
      case "SmallInt":
        return readSmallInt(parser, callback);
      case "Int":
        return readInt(parser, callback);
      case "BigInt":
        return readBigInt(parser, callback);
      case "IntN":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 1:
              return readTinyInt(parser, callback);
            case 2:
              return readSmallInt(parser, callback);
            case 4:
              return readInt(parser, callback);
            case 8:
              return readBigInt(parser, callback);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for IntN");
          }
        });
      case "Real":
        return readReal(parser, callback);
      case "Float":
        return readFloat(parser, callback);
      case "FloatN":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 4:
              return readReal(parser, callback);
            case 8:
              return readFloat(parser, callback);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
          }
        });
      case "SmallMoney":
        return readSmallMoney(parser, callback);
      case "Money":
        return readMoney(parser, callback);
      case "MoneyN":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 4:
              return readSmallMoney(parser, callback);
            case 8:
              return readMoney(parser, callback);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
          }
        });
      case "Bit":
        return readBit(parser, callback);
      case "BitN":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 1:
              return readBit(parser, callback);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for BitN");
          }
        });
      case "VarChar":
      case "Char":
        const codepage = metadata.collation.codepage;
        if (metadata.dataLength === MAX2) {
          return readMaxChars(parser, codepage, callback);
        } else {
          return parser.readUInt16LE((dataLength) => {
            if (dataLength === NULL) {
              return callback(null);
            }
            readChars(parser, dataLength, codepage, callback);
          });
        }
      case "NVarChar":
      case "NChar":
        if (metadata.dataLength === MAX2) {
          return readMaxNChars(parser, callback);
        } else {
          return parser.readUInt16LE((dataLength) => {
            if (dataLength === NULL) {
              return callback(null);
            }
            readNChars(parser, dataLength, callback);
          });
        }
      case "VarBinary":
      case "Binary":
        if (metadata.dataLength === MAX2) {
          return readMaxBinary(parser, callback);
        } else {
          return parser.readUInt16LE((dataLength) => {
            if (dataLength === NULL) {
              return callback(null);
            }
            readBinary(parser, dataLength, callback);
          });
        }
      case "Text":
        return parser.readUInt8((textPointerLength) => {
          if (textPointerLength === 0) {
            return callback(null);
          }
          parser.readBuffer(textPointerLength, (_textPointer) => {
            parser.readBuffer(8, (_timestamp) => {
              parser.readUInt32LE((dataLength) => {
                readChars(parser, dataLength, metadata.collation.codepage, callback);
              });
            });
          });
        });
      case "NText":
        return parser.readUInt8((textPointerLength) => {
          if (textPointerLength === 0) {
            return callback(null);
          }
          parser.readBuffer(textPointerLength, (_textPointer) => {
            parser.readBuffer(8, (_timestamp) => {
              parser.readUInt32LE((dataLength) => {
                readNChars(parser, dataLength, callback);
              });
            });
          });
        });
      case "Image":
        return parser.readUInt8((textPointerLength) => {
          if (textPointerLength === 0) {
            return callback(null);
          }
          parser.readBuffer(textPointerLength, (_textPointer) => {
            parser.readBuffer(8, (_timestamp) => {
              parser.readUInt32LE((dataLength) => {
                readBinary(parser, dataLength, callback);
              });
            });
          });
        });
      case "Xml":
        return readMaxNChars(parser, callback);
      case "SmallDateTime":
        return readSmallDateTime(parser, options.useUTC, callback);
      case "DateTime":
        return readDateTime(parser, options.useUTC, callback);
      case "DateTimeN":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 4:
              return readSmallDateTime(parser, options.useUTC, callback);
            case 8:
              return readDateTime(parser, options.useUTC, callback);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
          }
        });
      case "Time":
        return parser.readUInt8((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          } else {
            return readTime(parser, dataLength, metadata.scale, options.useUTC, callback);
          }
        });
      case "Date":
        return parser.readUInt8((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          } else {
            return readDate(parser, options.useUTC, callback);
          }
        });
      case "DateTime2":
        return parser.readUInt8((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          } else {
            return readDateTime2(parser, dataLength, metadata.scale, options.useUTC, callback);
          }
        });
      case "DateTimeOffset":
        return parser.readUInt8((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          } else {
            return readDateTimeOffset(parser, dataLength, metadata.scale, callback);
          }
        });
      case "NumericN":
      case "DecimalN":
        return parser.readUInt8((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          } else {
            return readNumeric(parser, dataLength, metadata.precision, metadata.scale, callback);
          }
        });
      case "UniqueIdentifier":
        return parser.readUInt8((dataLength) => {
          switch (dataLength) {
            case 0:
              return callback(null);
            case 16:
              return readUniqueIdentifier(parser, options, callback);
            default:
              throw new Error((0, _sprintfJs2.sprintf)("Unsupported guid size %d", dataLength - 1));
          }
        });
      case "UDT":
        return readMaxBinary(parser, callback);
      case "Variant":
        return parser.readUInt32LE((dataLength) => {
          if (dataLength === 0) {
            return callback(null);
          }
          readVariant(parser, options, dataLength, callback);
        });
      default:
        throw new Error((0, _sprintfJs2.sprintf)("Unrecognised type %s", type2.name));
    }
  }
  function readUniqueIdentifier(parser, options, callback) {
    parser.readBuffer(16, (data) => {
      callback(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data));
    });
  }
  function readNumeric(parser, dataLength, _precision, scale, callback) {
    parser.readUInt8((sign4) => {
      sign4 = sign4 === 1 ? 1 : -1;
      let readValue;
      if (dataLength === 5) {
        readValue = parser.readUInt32LE;
      } else if (dataLength === 9) {
        readValue = parser.readUNumeric64LE;
      } else if (dataLength === 13) {
        readValue = parser.readUNumeric96LE;
      } else if (dataLength === 17) {
        readValue = parser.readUNumeric128LE;
      } else {
        throw new Error((0, _sprintfJs2.sprintf)("Unsupported numeric dataLength %d", dataLength));
      }
      readValue.call(parser, (value) => {
        callback(value * sign4 / Math.pow(10, scale));
      });
    });
  }
  function readVariant(parser, options, dataLength, callback) {
    return parser.readUInt8((baseType) => {
      const type2 = _dataType.TYPE[baseType];
      return parser.readUInt8((propBytes) => {
        dataLength = dataLength - propBytes - 2;
        switch (type2.name) {
          case "UniqueIdentifier":
            return readUniqueIdentifier(parser, options, callback);
          case "Bit":
            return readBit(parser, callback);
          case "TinyInt":
            return readTinyInt(parser, callback);
          case "SmallInt":
            return readSmallInt(parser, callback);
          case "Int":
            return readInt(parser, callback);
          case "BigInt":
            return readBigInt(parser, callback);
          case "SmallDateTime":
            return readSmallDateTime(parser, options.useUTC, callback);
          case "DateTime":
            return readDateTime(parser, options.useUTC, callback);
          case "Real":
            return readReal(parser, callback);
          case "Float":
            return readFloat(parser, callback);
          case "SmallMoney":
            return readSmallMoney(parser, callback);
          case "Money":
            return readMoney(parser, callback);
          case "Date":
            return readDate(parser, options.useUTC, callback);
          case "Time":
            return parser.readUInt8((scale) => {
              return readTime(parser, dataLength, scale, options.useUTC, callback);
            });
          case "DateTime2":
            return parser.readUInt8((scale) => {
              return readDateTime2(parser, dataLength, scale, options.useUTC, callback);
            });
          case "DateTimeOffset":
            return parser.readUInt8((scale) => {
              return readDateTimeOffset(parser, dataLength, scale, callback);
            });
          case "VarBinary":
          case "Binary":
            return parser.readUInt16LE((_maxLength) => {
              readBinary(parser, dataLength, callback);
            });
          case "NumericN":
          case "DecimalN":
            return parser.readUInt8((precision) => {
              parser.readUInt8((scale) => {
                readNumeric(parser, dataLength, precision, scale, callback);
              });
            });
          case "VarChar":
          case "Char":
            return parser.readUInt16LE((_maxLength) => {
              (0, _metadataParser.readCollation)(parser, (collation2) => {
                readChars(parser, dataLength, collation2.codepage, callback);
              });
            });
          case "NVarChar":
          case "NChar":
            return parser.readUInt16LE((_maxLength) => {
              (0, _metadataParser.readCollation)(parser, (_collation) => {
                readNChars(parser, dataLength, callback);
              });
            });
          default:
            throw new Error("Invalid type!");
        }
      });
    });
  }
  function readBinary(parser, dataLength, callback) {
    return parser.readBuffer(dataLength, callback);
  }
  function readChars(parser, dataLength, codepage, callback) {
    if (codepage == null) {
      codepage = DEFAULT_ENCODING;
    }
    return parser.readBuffer(dataLength, (data) => {
      callback(_iconvLite.default.decode(data, codepage));
    });
  }
  function readNChars(parser, dataLength, callback) {
    parser.readBuffer(dataLength, (data) => {
      callback(data.toString("ucs2"));
    });
  }
  function readMaxBinary(parser, callback) {
    return readMax(parser, callback);
  }
  function readMaxChars(parser, codepage, callback) {
    if (codepage == null) {
      codepage = DEFAULT_ENCODING;
    }
    readMax(parser, (data) => {
      if (data) {
        callback(_iconvLite.default.decode(data, codepage));
      } else {
        callback(null);
      }
    });
  }
  function readMaxNChars(parser, callback) {
    readMax(parser, (data) => {
      if (data) {
        callback(data.toString("ucs2"));
      } else {
        callback(null);
      }
    });
  }
  function readMax(parser, callback) {
    parser.readBuffer(8, (type2) => {
      if (type2.equals(PLP_NULL)) {
        return callback(null);
      } else if (type2.equals(UNKNOWN_PLP_LEN)) {
        return readMaxUnknownLength(parser, callback);
      } else {
        const low = type2.readUInt32LE(0);
        const high = type2.readUInt32LE(4);
        if (high >= 2 << 53 - 32) {
          console.warn("Read UInt64LE > 53 bits : high=" + high + ", low=" + low);
        }
        const expectedLength = low + 4294967296 * high;
        return readMaxKnownLength(parser, expectedLength, callback);
      }
    });
  }
  function readMaxKnownLength(parser, totalLength, callback) {
    const data = Buffer.alloc(totalLength, 0);
    let offset = 0;
    function next(done) {
      parser.readUInt32LE((chunkLength) => {
        if (!chunkLength) {
          return done();
        }
        parser.readBuffer(chunkLength, (chunk) => {
          chunk.copy(data, offset);
          offset += chunkLength;
          next(done);
        });
      });
    }
    next(() => {
      if (offset !== totalLength) {
        throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + totalLength + ", but got " + offset + " bytes");
      }
      callback(data);
    });
  }
  function readMaxUnknownLength(parser, callback) {
    const chunks = [];
    let length = 0;
    function next(done) {
      parser.readUInt32LE((chunkLength) => {
        if (!chunkLength) {
          return done();
        }
        parser.readBuffer(chunkLength, (chunk) => {
          chunks.push(chunk);
          length += chunkLength;
          next(done);
        });
      });
    }
    next(() => {
      callback(Buffer.concat(chunks, length));
    });
  }
  function readSmallDateTime(parser, useUTC, callback) {
    parser.readUInt16LE((days) => {
      parser.readUInt16LE((minutes) => {
        let value;
        if (useUTC) {
          value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
        } else {
          value = new Date(1900, 0, 1 + days, 0, minutes);
        }
        callback(value);
      });
    });
  }
  function readDateTime(parser, useUTC, callback) {
    parser.readInt32LE((days) => {
      parser.readUInt32LE((threeHundredthsOfSecond) => {
        const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
        let value;
        if (useUTC) {
          value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
        } else {
          value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
        }
        callback(value);
      });
    });
  }
  function readTime(parser, dataLength, scale, useUTC, callback) {
    let readValue;
    switch (dataLength) {
      case 3:
        readValue = parser.readUInt24LE;
        break;
      case 4:
        readValue = parser.readUInt32LE;
        break;
      case 5:
        readValue = parser.readUInt40LE;
    }
    readValue.call(parser, (value) => {
      if (scale < 7) {
        for (let i = scale; i < 7; i++) {
          value *= 10;
        }
      }
      let date2;
      if (useUTC) {
        date2 = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
      } else {
        date2 = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
      }
      Object.defineProperty(date2, "nanosecondsDelta", {
        enumerable: false,
        value: value % 1e4 / Math.pow(10, 7)
      });
      callback(date2);
    });
  }
  function readDate(parser, useUTC, callback) {
    parser.readUInt24LE((days) => {
      if (useUTC) {
        callback(new Date(Date.UTC(2e3, 0, days - 730118)));
      } else {
        callback(new Date(2e3, 0, days - 730118));
      }
    });
  }
  function readDateTime2(parser, dataLength, scale, useUTC, callback) {
    readTime(parser, dataLength - 3, scale, useUTC, (time2) => {
      parser.readUInt24LE((days) => {
        let date2;
        if (useUTC) {
          date2 = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time2));
        } else {
          date2 = new Date(2e3, 0, days - 730118, time2.getHours(), time2.getMinutes(), time2.getSeconds(), time2.getMilliseconds());
        }
        Object.defineProperty(date2, "nanosecondsDelta", {
          enumerable: false,
          value: time2.nanosecondsDelta
        });
        callback(date2);
      });
    });
  }
  function readDateTimeOffset(parser, dataLength, scale, callback) {
    readTime(parser, dataLength - 5, scale, true, (time2) => {
      parser.readUInt24LE((days) => {
        parser.readInt16LE(() => {
          const date2 = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time2));
          Object.defineProperty(date2, "nanosecondsDelta", {
            enumerable: false,
            value: time2.nanosecondsDelta
          });
          callback(date2);
        });
      });
    });
  }
  var _default2 = valueParse;
  exports$1.default = _default2;
  module2.exports = valueParse;
})(valueParser, valueParser.exports);
var valueParserExports = valueParser.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  var _metadataParser = _interopRequireDefault2(metadataParserExports);
  var _valueParser = _interopRequireDefault2(valueParserExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function returnParser(parser, options, callback) {
    parser.readUInt16LE((paramOrdinal) => {
      parser.readBVarChar((paramName) => {
        if (paramName.charAt(0) === "@") {
          paramName = paramName.slice(1);
        }
        parser.readUInt8(() => {
          (0, _metadataParser.default)(parser, options, (metadata) => {
            (0, _valueParser.default)(parser, metadata, options, (value) => {
              callback(new _token2.ReturnValueToken({
                paramOrdinal,
                paramName,
                metadata,
                value
              }));
            });
          });
        });
      });
    });
  }
  var _default2 = returnParser;
  exports$1.default = _default2;
  module2.exports = returnParser;
})(returnvalueTokenParser, returnvalueTokenParser.exports);
var returnvalueTokenParserExports = returnvalueTokenParser.exports;
var rowTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  var _valueParser = _interopRequireDefault2(valueParserExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  async function rowParser(parser) {
    const colMetadata = parser.colMetadata;
    const length = colMetadata.length;
    const columns = [];
    for (let i = 0; i < length; i++) {
      const currColMetadata = colMetadata[i];
      let value;
      (0, _valueParser.default)(parser, currColMetadata, parser.options, (v) => {
        value = v;
      });
      while (parser.suspended) {
        await parser.streamBuffer.waitForChunk();
        parser.suspended = false;
        const next = parser.next;
        next();
      }
      columns.push({
        value,
        metadata: currColMetadata
      });
    }
    if (parser.options.useColumnNames) {
      const columnsMap = /* @__PURE__ */ Object.create(null);
      columns.forEach((column) => {
        const colName = column.metadata.colName;
        if (columnsMap[colName] == null) {
          columnsMap[colName] = column;
        }
      });
      return new _token2.RowToken(columnsMap);
    } else {
      return new _token2.RowToken(columns);
    }
  }
  var _default2 = rowParser;
  exports$1.default = _default2;
  module2.exports = rowParser;
})(rowTokenParser, rowTokenParser.exports);
var rowTokenParserExports = rowTokenParser.exports;
var nbcrowTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  var _valueParser = _interopRequireDefault2(valueParserExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function nullHandler(_parser, _columnMetadata, _options, callback) {
    callback(null);
  }
  async function nbcRowParser(parser) {
    const colMetadata = parser.colMetadata;
    const bitmapByteLength = Math.ceil(colMetadata.length / 8);
    const columns = [];
    const bitmap = [];
    while (parser.buffer.length - parser.position < bitmapByteLength) {
      await parser.streamBuffer.waitForChunk();
    }
    const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
    parser.position += bitmapByteLength;
    for (let i = 0, len = bytes.length; i < len; i++) {
      const byte = bytes[i];
      bitmap.push(byte & 1 ? true : false);
      bitmap.push(byte & 2 ? true : false);
      bitmap.push(byte & 4 ? true : false);
      bitmap.push(byte & 8 ? true : false);
      bitmap.push(byte & 16 ? true : false);
      bitmap.push(byte & 32 ? true : false);
      bitmap.push(byte & 64 ? true : false);
      bitmap.push(byte & 128 ? true : false);
    }
    for (let i = 0; i < colMetadata.length; i++) {
      const currColMetadata = colMetadata[i];
      let value;
      (bitmap[i] ? nullHandler : _valueParser.default)(parser, currColMetadata, parser.options, (v) => {
        value = v;
      });
      while (parser.suspended) {
        await parser.streamBuffer.waitForChunk();
        parser.suspended = false;
        const next = parser.next;
        next();
      }
      columns.push({
        value,
        metadata: currColMetadata
      });
    }
    if (parser.options.useColumnNames) {
      const columnsMap = {};
      columns.forEach((column) => {
        const colName = column.metadata.colName;
        if (columnsMap[colName] == null) {
          columnsMap[colName] = column;
        }
      });
      return new _token2.NBCRowToken(columnsMap);
    } else {
      return new _token2.NBCRowToken(columns);
    }
  }
  var _default2 = nbcRowParser;
  exports$1.default = _default2;
  module2.exports = nbcRowParser;
})(nbcrowTokenParser, nbcrowTokenParser.exports);
var nbcrowTokenParserExports = nbcrowTokenParser.exports;
var sspiTokenParser = { exports: {} };
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  function parseChallenge(buffer2) {
    const challenge = {};
    challenge.magic = buffer2.slice(0, 8).toString("utf8");
    challenge.type = buffer2.readInt32LE(8);
    challenge.domainLen = buffer2.readInt16LE(12);
    challenge.domainMax = buffer2.readInt16LE(14);
    challenge.domainOffset = buffer2.readInt32LE(16);
    challenge.flags = buffer2.readInt32LE(20);
    challenge.nonce = buffer2.slice(24, 32);
    challenge.zeroes = buffer2.slice(32, 40);
    challenge.targetLen = buffer2.readInt16LE(40);
    challenge.targetMax = buffer2.readInt16LE(42);
    challenge.targetOffset = buffer2.readInt32LE(44);
    challenge.oddData = buffer2.slice(48, 56);
    challenge.domain = buffer2.slice(56, 56 + challenge.domainLen).toString("ucs2");
    challenge.target = buffer2.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
    return challenge;
  }
  function sspiParser(parser, _options, callback) {
    parser.readUsVarByte((buffer2) => {
      callback(new _token2.SSPIToken(parseChallenge(buffer2), buffer2));
    });
  }
  var _default2 = sspiParser;
  exports$1.default = _default2;
  module2.exports = sspiParser;
})(sspiTokenParser, sspiTokenParser.exports);
var sspiTokenParserExports = sspiTokenParser.exports;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _token2 = token;
  var _colmetadataTokenParser = _interopRequireDefault2(colmetadataTokenParserExports);
  var _doneTokenParser = doneTokenParser;
  var _envChangeTokenParser = _interopRequireDefault2(envChangeTokenParserExports);
  var _infoerrorTokenParser = infoerrorTokenParser;
  var _fedauthInfoParser = _interopRequireDefault2(fedauthInfoParserExports);
  var _featureExtAckParser = _interopRequireDefault2(featureExtAckParserExports);
  var _loginackTokenParser = _interopRequireDefault2(loginackTokenParserExports);
  var _orderTokenParser = _interopRequireDefault2(orderTokenParserExports);
  var _returnstatusTokenParser = _interopRequireDefault2(returnstatusTokenParserExports);
  var _returnvalueTokenParser = _interopRequireDefault2(returnvalueTokenParserExports);
  var _rowTokenParser = _interopRequireDefault2(rowTokenParserExports);
  var _nbcrowTokenParser = _interopRequireDefault2(nbcrowTokenParserExports);
  var _sspiTokenParser = _interopRequireDefault2(sspiTokenParserExports);
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const tokenParsers = {
    [_token2.TYPE.DONE]: _doneTokenParser.doneParser,
    [_token2.TYPE.DONEINPROC]: _doneTokenParser.doneInProcParser,
    [_token2.TYPE.DONEPROC]: _doneTokenParser.doneProcParser,
    [_token2.TYPE.ENVCHANGE]: _envChangeTokenParser.default,
    [_token2.TYPE.ERROR]: _infoerrorTokenParser.errorParser,
    [_token2.TYPE.FEDAUTHINFO]: _fedauthInfoParser.default,
    [_token2.TYPE.FEATUREEXTACK]: _featureExtAckParser.default,
    [_token2.TYPE.INFO]: _infoerrorTokenParser.infoParser,
    [_token2.TYPE.LOGINACK]: _loginackTokenParser.default,
    [_token2.TYPE.ORDER]: _orderTokenParser.default,
    [_token2.TYPE.RETURNSTATUS]: _returnstatusTokenParser.default,
    [_token2.TYPE.RETURNVALUE]: _returnvalueTokenParser.default,
    [_token2.TYPE.SSPI]: _sspiTokenParser.default
  };
  class StreamBuffer {
    constructor(iterable) {
      this.iterator = void 0;
      this.buffer = void 0;
      this.position = void 0;
      this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
      this.buffer = Buffer.alloc(0);
      this.position = 0;
    }
    async waitForChunk() {
      const result = await this.iterator.next();
      if (result.done) {
        throw new Error("unexpected end of data");
      }
      if (this.position === this.buffer.length) {
        this.buffer = result.value;
      } else {
        this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
      }
      this.position = 0;
    }
  }
  class Parser2 {
    static async *parseTokens(iterable, debug2, options, colMetadata = []) {
      let token2;
      const onDoneParsing = (t2) => {
        token2 = t2;
      };
      const streamBuffer = new StreamBuffer(iterable);
      const parser = new Parser2(streamBuffer, debug2, options);
      parser.colMetadata = colMetadata;
      while (true) {
        try {
          await streamBuffer.waitForChunk();
        } catch (err) {
          if (streamBuffer.position === streamBuffer.buffer.length) {
            return;
          }
          throw err;
        }
        if (parser.suspended) {
          parser.suspended = false;
          const next = parser.next;
          next();
          if (!parser.suspended && token2) {
            if (token2 instanceof _token2.ColMetadataToken) {
              parser.colMetadata = token2.columns;
            }
            yield token2;
          }
        }
        while (!parser.suspended && parser.position + 1 <= parser.buffer.length) {
          const type2 = parser.buffer.readUInt8(parser.position);
          parser.position += 1;
          if (type2 === _token2.TYPE.COLMETADATA) {
            const token3 = await (0, _colmetadataTokenParser.default)(parser);
            parser.colMetadata = token3.columns;
            yield token3;
          } else if (type2 === _token2.TYPE.ROW) {
            yield (0, _rowTokenParser.default)(parser);
          } else if (type2 === _token2.TYPE.NBCROW) {
            yield (0, _nbcrowTokenParser.default)(parser);
          } else if (tokenParsers[type2]) {
            tokenParsers[type2](parser, parser.options, onDoneParsing);
            if (!parser.suspended && token2) {
              if (token2 instanceof _token2.ColMetadataToken) {
                parser.colMetadata = token2.columns;
              }
              yield token2;
            }
          } else {
            throw new Error("Unknown type: " + type2);
          }
        }
      }
    }
    constructor(streamBuffer, debug2, options) {
      this.debug = void 0;
      this.colMetadata = void 0;
      this.options = void 0;
      this.suspended = void 0;
      this.next = void 0;
      this.streamBuffer = void 0;
      this.debug = debug2;
      this.colMetadata = [];
      this.options = options;
      this.streamBuffer = streamBuffer;
      this.suspended = false;
      this.next = void 0;
    }
    get buffer() {
      return this.streamBuffer.buffer;
    }
    get position() {
      return this.streamBuffer.position;
    }
    set position(value) {
      this.streamBuffer.position = value;
    }
    suspend(next) {
      this.suspended = true;
      this.next = next;
    }
    awaitData(length, callback) {
      if (this.position + length <= this.buffer.length) {
        callback();
      } else {
        this.suspend(() => {
          this.awaitData(length, callback);
        });
      }
    }
    readInt8(callback) {
      this.awaitData(1, () => {
        const data = this.buffer.readInt8(this.position);
        this.position += 1;
        callback(data);
      });
    }
    readUInt8(callback) {
      this.awaitData(1, () => {
        const data = this.buffer.readUInt8(this.position);
        this.position += 1;
        callback(data);
      });
    }
    readInt16LE(callback) {
      this.awaitData(2, () => {
        const data = this.buffer.readInt16LE(this.position);
        this.position += 2;
        callback(data);
      });
    }
    readInt16BE(callback) {
      this.awaitData(2, () => {
        const data = this.buffer.readInt16BE(this.position);
        this.position += 2;
        callback(data);
      });
    }
    readUInt16LE(callback) {
      this.awaitData(2, () => {
        const data = this.buffer.readUInt16LE(this.position);
        this.position += 2;
        callback(data);
      });
    }
    readUInt16BE(callback) {
      this.awaitData(2, () => {
        const data = this.buffer.readUInt16BE(this.position);
        this.position += 2;
        callback(data);
      });
    }
    readInt32LE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readInt32LE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readInt32BE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readInt32BE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readUInt32LE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readUInt32LE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readUInt32BE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readUInt32BE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readBigInt64LE(callback) {
      this.awaitData(8, () => {
        const data = this.buffer.readBigInt64LE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readInt64LE(callback) {
      this.awaitData(8, () => {
        const data = Math.pow(2, 32) * this.buffer.readInt32LE(this.position + 4) + ((this.buffer[this.position + 4] & 128) === 128 ? 1 : -1) * this.buffer.readUInt32LE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readInt64BE(callback) {
      this.awaitData(8, () => {
        const data = Math.pow(2, 32) * this.buffer.readInt32BE(this.position) + ((this.buffer[this.position] & 128) === 128 ? 1 : -1) * this.buffer.readUInt32BE(this.position + 4);
        this.position += 8;
        callback(data);
      });
    }
    readBigUInt64LE(callback) {
      this.awaitData(8, () => {
        const data = this.buffer.readBigUInt64LE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readUInt64LE(callback) {
      this.awaitData(8, () => {
        const data = Math.pow(2, 32) * this.buffer.readUInt32LE(this.position + 4) + this.buffer.readUInt32LE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readUInt64BE(callback) {
      this.awaitData(8, () => {
        const data = Math.pow(2, 32) * this.buffer.readUInt32BE(this.position) + this.buffer.readUInt32BE(this.position + 4);
        this.position += 8;
        callback(data);
      });
    }
    readFloatLE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readFloatLE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readFloatBE(callback) {
      this.awaitData(4, () => {
        const data = this.buffer.readFloatBE(this.position);
        this.position += 4;
        callback(data);
      });
    }
    readDoubleLE(callback) {
      this.awaitData(8, () => {
        const data = this.buffer.readDoubleLE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readDoubleBE(callback) {
      this.awaitData(8, () => {
        const data = this.buffer.readDoubleBE(this.position);
        this.position += 8;
        callback(data);
      });
    }
    readUInt24LE(callback) {
      this.awaitData(3, () => {
        const low = this.buffer.readUInt16LE(this.position);
        const high = this.buffer.readUInt8(this.position + 2);
        this.position += 3;
        callback(low | high << 16);
      });
    }
    readUInt40LE(callback) {
      this.awaitData(5, () => {
        const low = this.buffer.readUInt32LE(this.position);
        const high = this.buffer.readUInt8(this.position + 4);
        this.position += 5;
        callback(4294967296 * high + low);
      });
    }
    readUNumeric64LE(callback) {
      this.awaitData(8, () => {
        const low = this.buffer.readUInt32LE(this.position);
        const high = this.buffer.readUInt32LE(this.position + 4);
        this.position += 8;
        callback(4294967296 * high + low);
      });
    }
    readUNumeric96LE(callback) {
      this.awaitData(12, () => {
        const dword1 = this.buffer.readUInt32LE(this.position);
        const dword2 = this.buffer.readUInt32LE(this.position + 4);
        const dword3 = this.buffer.readUInt32LE(this.position + 8);
        this.position += 12;
        callback(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3);
      });
    }
    readUNumeric128LE(callback) {
      this.awaitData(16, () => {
        const dword1 = this.buffer.readUInt32LE(this.position);
        const dword2 = this.buffer.readUInt32LE(this.position + 4);
        const dword3 = this.buffer.readUInt32LE(this.position + 8);
        const dword4 = this.buffer.readUInt32LE(this.position + 12);
        this.position += 16;
        callback(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4);
      });
    }
    // Variable length data
    readBuffer(length, callback) {
      this.awaitData(length, () => {
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        callback(data);
      });
    }
    // Read a Unicode String (BVARCHAR)
    readBVarChar(callback) {
      this.readUInt8((length) => {
        this.readBuffer(length * 2, (data) => {
          callback(data.toString("ucs2"));
        });
      });
    }
    // Read a Unicode String (USVARCHAR)
    readUsVarChar(callback) {
      this.readUInt16LE((length) => {
        this.readBuffer(length * 2, (data) => {
          callback(data.toString("ucs2"));
        });
      });
    }
    // Read binary data (BVARBYTE)
    readBVarByte(callback) {
      this.readUInt8((length) => {
        this.readBuffer(length, callback);
      });
    }
    // Read binary data (USVARBYTE)
    readUsVarByte(callback) {
      this.readUInt16LE((length) => {
        this.readBuffer(length, callback);
      });
    }
  }
  var _default2 = Parser2;
  exports$1.default = _default2;
  module2.exports = Parser2;
})(streamParser, streamParser.exports);
var streamParserExports = streamParser.exports;
Object.defineProperty(tokenStreamParser, "__esModule", {
  value: true
});
tokenStreamParser.Parser = void 0;
var _events = require$$0$3;
var _streamParser = _interopRequireDefault$3(streamParserExports);
var _stream = require$$0$4;
function _interopRequireDefault$3(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
class Parser extends _events.EventEmitter {
  constructor(message2, debug2, handler2, options) {
    super();
    this.debug = void 0;
    this.options = void 0;
    this.parser = void 0;
    this.debug = debug2;
    this.options = options;
    this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message2, this.debug, this.options));
    this.parser.on("data", (token2) => {
      handler2[token2.handlerName](token2);
    });
    this.parser.on("drain", () => {
      this.emit("drain");
    });
    this.parser.on("end", () => {
      this.emit("end");
    });
  }
  pause() {
    return this.parser.pause();
  }
  resume() {
    return this.parser.resume();
  }
}
tokenStreamParser.Parser = Parser;
var transaction$1 = {};
Object.defineProperty(transaction$1, "__esModule", {
  value: true
});
transaction$1.Transaction = transaction$1.OPERATION_TYPE = transaction$1.ISOLATION_LEVEL = void 0;
transaction$1.assertValidIsolationLevel = assertValidIsolationLevel;
transaction$1.isolationLevelByValue = void 0;
var _writableTrackingBuffer = _interopRequireDefault$2(writableTrackingBufferExports);
var _allHeaders = allHeaders;
function _interopRequireDefault$2(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
const OPERATION_TYPE = {
  TM_GET_DTC_ADDRESS: 0,
  TM_PROPAGATE_XACT: 1,
  TM_BEGIN_XACT: 5,
  TM_PROMOTE_XACT: 6,
  TM_COMMIT_XACT: 7,
  TM_ROLLBACK_XACT: 8,
  TM_SAVE_XACT: 9
};
transaction$1.OPERATION_TYPE = OPERATION_TYPE;
const ISOLATION_LEVEL = {
  NO_CHANGE: 0,
  READ_UNCOMMITTED: 1,
  READ_COMMITTED: 2,
  REPEATABLE_READ: 3,
  SERIALIZABLE: 4,
  SNAPSHOT: 5
};
transaction$1.ISOLATION_LEVEL = ISOLATION_LEVEL;
const isolationLevelByValue = {};
transaction$1.isolationLevelByValue = isolationLevelByValue;
for (const name2 in ISOLATION_LEVEL) {
  const value = ISOLATION_LEVEL[name2];
  isolationLevelByValue[value] = name2;
}
function assertValidIsolationLevel(isolationLevel, name2) {
  if (typeof isolationLevel !== "number") {
    throw new TypeError(`The "${name2}" ${name2.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
  }
  if (!Number.isInteger(isolationLevel)) {
    throw new RangeError(`The value of "${name2}" is out of range. It must be an integer. Received: ${isolationLevel}`);
  }
  if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
    throw new RangeError(`The value of "${name2}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
  }
}
let Transaction$1 = class Transaction2 {
  constructor(name2, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
    this.name = void 0;
    this.isolationLevel = void 0;
    this.outstandingRequestCount = void 0;
    this.name = name2;
    this.isolationLevel = isolationLevel;
    this.outstandingRequestCount = 1;
  }
  beginPayload(txnDescriptor) {
    const buffer2 = new _writableTrackingBuffer.default(100, "ucs2");
    (0, _allHeaders.writeToTrackingBuffer)(buffer2, txnDescriptor, this.outstandingRequestCount);
    buffer2.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
    buffer2.writeUInt8(this.isolationLevel);
    buffer2.writeUInt8(this.name.length * 2);
    buffer2.writeString(this.name, "ucs2");
    return {
      *[Symbol.iterator]() {
        yield buffer2.data;
      },
      toString: () => {
        return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
      }
    };
  }
  commitPayload(txnDescriptor) {
    const buffer2 = new _writableTrackingBuffer.default(100, "ascii");
    (0, _allHeaders.writeToTrackingBuffer)(buffer2, txnDescriptor, this.outstandingRequestCount);
    buffer2.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
    buffer2.writeUInt8(this.name.length * 2);
    buffer2.writeString(this.name, "ucs2");
    buffer2.writeUInt8(0);
    return {
      *[Symbol.iterator]() {
        yield buffer2.data;
      },
      toString: () => {
        return "Commit Transaction: name=" + this.name;
      }
    };
  }
  rollbackPayload(txnDescriptor) {
    const buffer2 = new _writableTrackingBuffer.default(100, "ascii");
    (0, _allHeaders.writeToTrackingBuffer)(buffer2, txnDescriptor, this.outstandingRequestCount);
    buffer2.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
    buffer2.writeUInt8(this.name.length * 2);
    buffer2.writeString(this.name, "ucs2");
    buffer2.writeUInt8(0);
    return {
      *[Symbol.iterator]() {
        yield buffer2.data;
      },
      toString: () => {
        return "Rollback Transaction: name=" + this.name;
      }
    };
  }
  savePayload(txnDescriptor) {
    const buffer2 = new _writableTrackingBuffer.default(100, "ascii");
    (0, _allHeaders.writeToTrackingBuffer)(buffer2, txnDescriptor, this.outstandingRequestCount);
    buffer2.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
    buffer2.writeUInt8(this.name.length * 2);
    buffer2.writeString(this.name, "ucs2");
    return {
      *[Symbol.iterator]() {
        yield buffer2.data;
      },
      toString: () => {
        return "Save Transaction: name=" + this.name;
      }
    };
  }
  isolationLevelToTSQL() {
    switch (this.isolationLevel) {
      case ISOLATION_LEVEL.READ_UNCOMMITTED:
        return "READ UNCOMMITTED";
      case ISOLATION_LEVEL.READ_COMMITTED:
        return "READ COMMITTED";
      case ISOLATION_LEVEL.REPEATABLE_READ:
        return "REPEATABLE READ";
      case ISOLATION_LEVEL.SERIALIZABLE:
        return "SERIALIZABLE";
      case ISOLATION_LEVEL.SNAPSHOT:
        return "SNAPSHOT";
    }
    return "";
  }
};
transaction$1.Transaction = Transaction$1;
var connector = {};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$2 = Object.prototype.toString;
var max$2 = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$8 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$2.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max$2(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound2 = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$7 = implementation$8;
var functionBind = Function.prototype.bind || implementation$7;
var toStr$1 = Object.prototype.toString;
var isArguments = function isArguments2(value) {
  var str = toStr$1.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$1.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$6;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation$6;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim2 = function keys3(object) {
      var isObject3 = object !== null && typeof object === "object";
      var isFunction2 = toStr2.call(object) === "[object Function]";
      var isArguments3 = isArgs2(object);
      var isString2 = isObject3 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject3 && !isFunction2 && !isArguments3) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString2 && object.length > 0 && !has.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments3 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$6 = keysShim2;
  return implementation$6;
}
var slice2 = Array.prototype.slice;
var isArgs = isArguments;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice2.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var $defineProperty$4 = Object.defineProperty || false;
if ($defineProperty$4) {
  try {
    $defineProperty$4({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$4 = false;
  }
}
var esDefineProperty = $defineProperty$4;
var syntax = SyntaxError;
var type = TypeError;
var gOPD$4 = Object.getOwnPropertyDescriptor;
var $gOPD$2 = gOPD$4;
if ($gOPD$2) {
  try {
    $gOPD$2([], "length");
  } catch (e) {
    $gOPD$2 = null;
  }
}
var gopd$1 = $gOPD$2;
var $defineProperty$3 = esDefineProperty;
var $SyntaxError$2 = syntax;
var $TypeError$t = type;
var gopd = gopd$1;
var defineDataProperty$2 = function defineDataProperty(obj2, property, value) {
  if (!obj2 || typeof obj2 !== "object" && typeof obj2 !== "function") {
    throw new $TypeError$t("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$t("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$t("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$t("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$t("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$t("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc2 = !!gopd && gopd(obj2, property);
  if ($defineProperty$3) {
    $defineProperty$3(obj2, property, {
      configurable: nonConfigurable === null && desc2 ? desc2.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc2 ? desc2.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc2 ? desc2.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj2[property] = value;
  } else {
    throw new $SyntaxError$2("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty$2 = esDefineProperty;
var hasPropertyDescriptors$2 = function hasPropertyDescriptors() {
  return !!$defineProperty$2;
};
hasPropertyDescriptors$2.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty$2) {
    return null;
  }
  try {
    return $defineProperty$2([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$2;
var keys2 = objectKeys;
var hasSymbols$3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty$1 = defineDataProperty$2;
var isFunction = function(fn) {
  return typeof fn === "function" && toStr.call(fn) === "[object Function]";
};
var supportsDescriptors = hasPropertyDescriptors_1();
var defineProperty = function(object, name2, value, predicate) {
  if (name2 in object) {
    if (predicate === true) {
      if (object[name2] === value) {
        return;
      }
    } else if (!isFunction(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors) {
    defineDataProperty$1(object, name2, value, true);
  } else {
    defineDataProperty$1(object, name2, value);
  }
};
var defineProperties$1 = function(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys2(map);
  if (hasSymbols$3) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties$1.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties$1;
var functionsHaveNames = function functionsHaveNames2() {
  return typeof (function f() {
  }).name === "string";
};
var gOPD$3 = Object.getOwnPropertyDescriptor;
if (gOPD$3) {
  try {
    gOPD$3([], "length");
  } catch (e) {
    gOPD$3 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$3) {
    return false;
  }
  var desc2 = gOPD$3(function() {
  }, "name");
  return !!desc2 && !!desc2.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && (function f() {
  }).bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
var define$3 = defineDataProperty$2;
var hasDescriptors = hasPropertyDescriptors_1();
var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
var $TypeError$s = type;
var setFunctionName$1 = function setFunctionName(fn, name2) {
  if (typeof fn !== "function") {
    throw new $TypeError$s("`fn` is not a function");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  if (!loose || functionsHaveConfigurableNames2) {
    if (hasDescriptors) {
      define$3(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name2,
        true,
        true
      );
    } else {
      define$3(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name2
      );
    }
  }
  return fn;
};
var isObject$e = function isObject(x) {
  return !!x && (typeof x === "function" || typeof x === "object");
};
var isPropertyKey$7 = function isPropertyKey(argument) {
  return typeof argument === "string" || typeof argument === "symbol";
};
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$4 = functionBind;
var hasown = bind$4.call(call, $hasOwn);
var $TypeError$r = type;
var hasOwn$7 = hasown;
var allowed = {
  __proto__: null,
  "[[Configurable]]": true,
  "[[Enumerable]]": true,
  "[[Get]]": true,
  "[[Set]]": true,
  "[[Value]]": true,
  "[[Writable]]": true
};
var propertyDescriptor = function isPropertyDescriptor(Desc) {
  if (!Desc || typeof Desc !== "object") {
    return false;
  }
  for (var key2 in Desc) {
    if (hasOwn$7(Desc, key2) && !allowed[key2]) {
      return false;
    }
  }
  var isData = hasOwn$7(Desc, "[[Value]]") || hasOwn$7(Desc, "[[Writable]]");
  var IsAccessor = hasOwn$7(Desc, "[[Get]]") || hasOwn$7(Desc, "[[Set]]");
  if (isData && IsAccessor) {
    throw new $TypeError$r("Property Descriptors may not be both accessor and data descriptors");
  }
  return true;
};
var $TypeError$q = type;
var hasOwn$6 = hasown;
var isPropertyDescriptor$9 = propertyDescriptor;
var IsAccessorDescriptor$3 = function IsAccessorDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  if (!isPropertyDescriptor$9(Desc)) {
    throw new $TypeError$q("Assertion failed: `Desc` must be a Property Descriptor");
  }
  if (!hasOwn$6(Desc, "[[Get]]") && !hasOwn$6(Desc, "[[Set]]")) {
    return false;
  }
  return true;
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var uri = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$1 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$1 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN$2 = _isNaN;
var sign$1 = function sign2(number) {
  if ($isNaN$2(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : 1;
};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj2 = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj2[sym] = symVal;
    for (var _2 in obj2) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj2);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj2, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols$2;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$2;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$2 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$2;
}
var Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
var $Object$3 = esObjectAtoms;
var Object_getPrototypeOf = $Object$3.getPrototypeOf || null;
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
var bind$3 = functionBind;
var $apply$1 = requireFunctionApply();
var $call$2 = requireFunctionCall();
var $reflectApply = reflectApply;
var actualApply = $reflectApply || bind$3.call($call$2, $apply$1);
var bind$2 = functionBind;
var $TypeError$p = type;
var $call$1 = requireFunctionCall();
var $actualApply = actualApply;
var callBindApplyHelpers = function callBindBasic(args) {
  if (args.length < 1 || typeof args[0] !== "function") {
    throw new $TypeError$p("a function is required");
  }
  return $actualApply(bind$2, $call$1, args);
};
var callBind$2 = callBindApplyHelpers;
var gOPD$2 = gopd$1;
var hasProtoAccessor;
try {
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
  [].__proto__ === Array.prototype;
} catch (e) {
  if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
    throw e;
  }
}
var desc$1 = !!hasProtoAccessor && gOPD$2 && gOPD$2(
  Object.prototype,
  /** @type {keyof typeof Object.prototype} */
  "__proto__"
);
var $Object$2 = Object;
var $getPrototypeOf = $Object$2.getPrototypeOf;
var get2 = desc$1 && typeof desc$1.get === "function" ? callBind$2([desc$1.get]) : typeof $getPrototypeOf === "function" ? (
  /** @type {import('./get')} */
  function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object$2(value));
  }
) : false;
var reflectGetProto = Reflect_getPrototypeOf;
var originalGetProto = Object_getPrototypeOf;
var getDunderProto = get2;
var getProto$1 = reflectGetProto ? function getProto(O) {
  return reflectGetProto(O);
} : originalGetProto ? function getProto2(O) {
  if (!O || typeof O !== "object" && typeof O !== "function") {
    throw new TypeError("getProto: not an object");
  }
  return originalGetProto(O);
} : getDunderProto ? function getProto3(O) {
  return getDunderProto(O);
} : null;
var undefined$1;
var $Object$1 = esObjectAtoms;
var $Error$1 = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError$1 = syntax;
var $TypeError$o = type;
var $URIError = uri;
var abs = abs$1;
var floor = floor$1;
var max = max$1;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign3 = sign$1;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = gopd$1;
var $defineProperty$1 = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$o();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = requireHasSymbols()();
var getProto4 = getProto$1;
var $ObjectGPO = Object_getPrototypeOf;
var $ReflectGPO = Reflect_getPrototypeOf;
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto4 ? undefined$1 : getProto4(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto4 ? getProto4([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error$1,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto4 ? getProto4(getProto4([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto4 ? undefined$1 : getProto4((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object$1,
  "%Object.getOwnPropertyDescriptor%": $gOPD$1,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto4 ? undefined$1 : getProto4((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto4 ? getProto4(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$o,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty$1,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign3,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto4) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto4(getProto4(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto4) {
      value = getProto4(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn$5 = hasown;
var $concat = bind$1.call($call, Array.prototype.concat);
var $spliceApply = bind$1.call($apply, Array.prototype.splice);
var $replace = bind$1.call($call, String.prototype.replace);
var $strSlice = bind$1.call($call, String.prototype.slice);
var $exec = bind$1.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$5(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$5(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$o("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$o("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$o('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$5(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$o("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc2 = $gOPD$1(value, part);
        isOwn = !!desc2;
        if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
          value = desc2.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$5(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var isPrimitive$1;
var hasRequiredIsPrimitive;
function requireIsPrimitive() {
  if (hasRequiredIsPrimitive) return isPrimitive$1;
  hasRequiredIsPrimitive = 1;
  isPrimitive$1 = function isPrimitive2(value) {
    return value === null || typeof value !== "function" && typeof value !== "object";
  };
  return isPrimitive$1;
}
var GetIntrinsic$1 = getIntrinsic;
var $preventExtensions = GetIntrinsic$1("%Object.preventExtensions%", true);
var $isExtensible = GetIntrinsic$1("%Object.isExtensible%", true);
var isPrimitive = requireIsPrimitive();
var IsExtensible$1 = $preventExtensions ? function IsExtensible(obj2) {
  return !isPrimitive(obj2) && $isExtensible(obj2);
} : function IsExtensible2(obj2) {
  return !isPrimitive(obj2);
};
var isCallable;
var hasRequiredIsCallable$1;
function requireIsCallable$1() {
  if (hasRequiredIsCallable$1) return isCallable;
  hasRequiredIsCallable$1 = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr2 = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr2.call(all) === toStr2.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr2.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr2.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var IsCallable$3;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return IsCallable$3;
  hasRequiredIsCallable = 1;
  IsCallable$3 = requireIsCallable$1();
  return IsCallable$3;
}
var ToBoolean$4 = function ToBoolean(value) {
  return !!value;
};
var hasOwn$4 = hasown;
var $TypeError$n = type;
var isObject$d = isObject$e;
var IsCallable$2 = requireIsCallable();
var ToBoolean$3 = ToBoolean$4;
var ToPropertyDescriptor$3 = function ToPropertyDescriptor(Obj) {
  if (!isObject$d(Obj)) {
    throw new $TypeError$n("ToPropertyDescriptor requires an object");
  }
  var desc2 = {};
  if (hasOwn$4(Obj, "enumerable")) {
    desc2["[[Enumerable]]"] = ToBoolean$3(Obj.enumerable);
  }
  if (hasOwn$4(Obj, "configurable")) {
    desc2["[[Configurable]]"] = ToBoolean$3(Obj.configurable);
  }
  if (hasOwn$4(Obj, "value")) {
    desc2["[[Value]]"] = Obj.value;
  }
  if (hasOwn$4(Obj, "writable")) {
    desc2["[[Writable]]"] = ToBoolean$3(Obj.writable);
  }
  if (hasOwn$4(Obj, "get")) {
    var getter = Obj.get;
    if (typeof getter !== "undefined" && !IsCallable$2(getter)) {
      throw new $TypeError$n("getter must be a function");
    }
    desc2["[[Get]]"] = getter;
  }
  if (hasOwn$4(Obj, "set")) {
    var setter = Obj.set;
    if (typeof setter !== "undefined" && !IsCallable$2(setter)) {
      throw new $TypeError$n("setter must be a function");
    }
    desc2["[[Set]]"] = setter;
  }
  if ((hasOwn$4(desc2, "[[Get]]") || hasOwn$4(desc2, "[[Set]]")) && (hasOwn$4(desc2, "[[Value]]") || hasOwn$4(desc2, "[[Writable]]"))) {
    throw new $TypeError$n("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
  }
  return desc2;
};
var $isNaN$1 = _isNaN;
var SameValue$4 = function SameValue(x, y) {
  if (x === y) {
    if (x === 0) {
      return 1 / x === 1 / y;
    }
    return true;
  }
  return $isNaN$1(x) && $isNaN$1(y);
};
var callBound$1;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound$1;
  hasRequiredCallBound = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBindBasic2 = callBindApplyHelpers;
  var $indexOf = callBindBasic2([GetIntrinsic3("%String.prototype.indexOf%")]);
  callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic3(name2, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
      return callBindBasic2(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound$1;
}
var IsArray$1;
var hasRequiredIsArray$1;
function requireIsArray$1() {
  if (hasRequiredIsArray$1) return IsArray$1;
  hasRequiredIsArray$1 = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $Array = GetIntrinsic3("%Array%");
  var toStr2 = !$Array.isArray && requireCallBound()("Object.prototype.toString");
  IsArray$1 = $Array.isArray || function IsArray2(argument) {
    return toStr2(argument) === "[object Array]";
  };
  return IsArray$1;
}
var hasPropertyDescriptors$1 = hasPropertyDescriptors_1;
var $defineProperty = esDefineProperty;
var hasArrayLengthDefineBug2 = hasPropertyDescriptors$1.hasArrayLengthDefineBug();
var isArray = hasArrayLengthDefineBug2 && requireIsArray$1();
var callBound = requireCallBound();
var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
var DefineOwnProperty$2 = function DefineOwnProperty(IsDataDescriptor4, SameValue4, FromPropertyDescriptor4, O, P, desc2) {
  if (!$defineProperty) {
    if (!IsDataDescriptor4(desc2)) {
      return false;
    }
    if (!desc2["[[Configurable]]"] || !desc2["[[Writable]]"]) {
      return false;
    }
    if (P in O && $isEnumerable(O, P) !== !!desc2["[[Enumerable]]"]) {
      return false;
    }
    var V = desc2["[[Value]]"];
    O[P] = V;
    return SameValue4(O[P], V);
  }
  if (hasArrayLengthDefineBug2 && P === "length" && "[[Value]]" in desc2 && isArray(O) && O.length !== desc2["[[Value]]"]) {
    O.length = desc2["[[Value]]"];
    return O.length === desc2["[[Value]]"];
  }
  $defineProperty(O, P, FromPropertyDescriptor4(desc2));
  return true;
};
var isPropertyDescriptor$8 = propertyDescriptor;
var isFullyPopulatedPropertyDescriptor$1 = function isFullyPopulatedPropertyDescriptor(ES2, Desc) {
  return isPropertyDescriptor$8(Desc) && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES2.IsAccessorDescriptor(Desc) || ES2.IsDataDescriptor(Desc));
};
var fromPropertyDescriptor$2 = function fromPropertyDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return Desc;
  }
  var obj2 = {};
  if ("[[Value]]" in Desc) {
    obj2.value = Desc["[[Value]]"];
  }
  if ("[[Writable]]" in Desc) {
    obj2.writable = !!Desc["[[Writable]]"];
  }
  if ("[[Get]]" in Desc) {
    obj2.get = Desc["[[Get]]"];
  }
  if ("[[Set]]" in Desc) {
    obj2.set = Desc["[[Set]]"];
  }
  if ("[[Enumerable]]" in Desc) {
    obj2.enumerable = !!Desc["[[Enumerable]]"];
  }
  if ("[[Configurable]]" in Desc) {
    obj2.configurable = !!Desc["[[Configurable]]"];
  }
  return obj2;
};
var $TypeError$m = type;
var isPropertyDescriptor$7 = propertyDescriptor;
var fromPropertyDescriptor$1 = fromPropertyDescriptor$2;
var FromPropertyDescriptor$3 = function FromPropertyDescriptor(Desc) {
  if (typeof Desc !== "undefined" && !isPropertyDescriptor$7(Desc)) {
    throw new $TypeError$m("Assertion failed: `Desc` must be a Property Descriptor");
  }
  return fromPropertyDescriptor$1(Desc);
};
var $TypeError$l = type;
var hasOwn$3 = hasown;
var isPropertyDescriptor$6 = propertyDescriptor;
var IsDataDescriptor$4 = function IsDataDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  if (!isPropertyDescriptor$6(Desc)) {
    throw new $TypeError$l("Assertion failed: `Desc` must be a Property Descriptor");
  }
  if (!hasOwn$3(Desc, "[[Value]]") && !hasOwn$3(Desc, "[[Writable]]")) {
    return false;
  }
  return true;
};
var $TypeError$k = type;
var IsAccessorDescriptor$2 = IsAccessorDescriptor$3;
var IsDataDescriptor$3 = IsDataDescriptor$4;
var isPropertyDescriptor$5 = propertyDescriptor;
var IsGenericDescriptor$1 = function IsGenericDescriptor(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  if (!isPropertyDescriptor$5(Desc)) {
    throw new $TypeError$k("Assertion failed: `Desc` must be a Property Descriptor");
  }
  if (!IsAccessorDescriptor$2(Desc) && !IsDataDescriptor$3(Desc)) {
    return true;
  }
  return false;
};
var $TypeError$j = type;
var isObject$c = isObject$e;
var DefineOwnProperty$1 = DefineOwnProperty$2;
var isFullyPopulatedPropertyDescriptor2 = isFullyPopulatedPropertyDescriptor$1;
var isPropertyDescriptor$4 = propertyDescriptor;
var FromPropertyDescriptor$2 = FromPropertyDescriptor$3;
var IsAccessorDescriptor$1 = IsAccessorDescriptor$3;
var IsDataDescriptor$2 = IsDataDescriptor$4;
var IsGenericDescriptor2 = IsGenericDescriptor$1;
var isPropertyKey$6 = isPropertyKey$7;
var SameValue$3 = SameValue$4;
var ValidateAndApplyPropertyDescriptor$1 = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
  if (typeof O !== "undefined" && !isObject$c(O)) {
    throw new $TypeError$j("Assertion failed: O must be undefined or an Object");
  }
  if (!isPropertyKey$6(P)) {
    throw new $TypeError$j("Assertion failed: P must be a Property Key");
  }
  if (typeof extensible !== "boolean") {
    throw new $TypeError$j("Assertion failed: extensible must be a Boolean");
  }
  if (!isPropertyDescriptor$4(Desc)) {
    throw new $TypeError$j("Assertion failed: Desc must be a Property Descriptor");
  }
  if (typeof current !== "undefined" && !isPropertyDescriptor$4(current)) {
    throw new $TypeError$j("Assertion failed: current must be a Property Descriptor, or undefined");
  }
  if (typeof current === "undefined") {
    if (!extensible) {
      return false;
    }
    if (typeof O === "undefined") {
      return true;
    }
    if (IsAccessorDescriptor$1(Desc)) {
      return DefineOwnProperty$1(
        IsDataDescriptor$2,
        SameValue$3,
        FromPropertyDescriptor$2,
        O,
        P,
        Desc
      );
    }
    return DefineOwnProperty$1(
      IsDataDescriptor$2,
      SameValue$3,
      FromPropertyDescriptor$2,
      O,
      P,
      {
        "[[Configurable]]": !!Desc["[[Configurable]]"],
        "[[Enumerable]]": !!Desc["[[Enumerable]]"],
        "[[Value]]": Desc["[[Value]]"],
        "[[Writable]]": !!Desc["[[Writable]]"]
      }
    );
  }
  if (!isFullyPopulatedPropertyDescriptor2(
    {
      IsAccessorDescriptor: IsAccessorDescriptor$1,
      IsDataDescriptor: IsDataDescriptor$2
    },
    current
  )) {
    throw new $TypeError$j("`current`, when present, must be a fully populated and valid Property Descriptor");
  }
  if (!current["[[Configurable]]"]) {
    if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
      return false;
    }
    if ("[[Enumerable]]" in Desc && !SameValue$3(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
      return false;
    }
    if (!IsGenericDescriptor2(Desc) && !SameValue$3(IsAccessorDescriptor$1(Desc), IsAccessorDescriptor$1(current))) {
      return false;
    }
    if (IsAccessorDescriptor$1(current)) {
      if ("[[Get]]" in Desc && !SameValue$3(Desc["[[Get]]"], current["[[Get]]"])) {
        return false;
      }
      if ("[[Set]]" in Desc && !SameValue$3(Desc["[[Set]]"], current["[[Set]]"])) {
        return false;
      }
    } else if (!current["[[Writable]]"]) {
      if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
        return false;
      }
      if ("[[Value]]" in Desc && !SameValue$3(Desc["[[Value]]"], current["[[Value]]"])) {
        return false;
      }
    }
  }
  if (typeof O !== "undefined") {
    var configurable;
    var enumerable;
    if (IsDataDescriptor$2(current) && IsAccessorDescriptor$1(Desc)) {
      configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
      enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
      return DefineOwnProperty$1(
        IsDataDescriptor$2,
        SameValue$3,
        FromPropertyDescriptor$2,
        O,
        P,
        {
          "[[Configurable]]": !!configurable,
          "[[Enumerable]]": !!enumerable,
          "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
          "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
        }
      );
    } else if (IsAccessorDescriptor$1(current) && IsDataDescriptor$2(Desc)) {
      configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
      enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
      return DefineOwnProperty$1(
        IsDataDescriptor$2,
        SameValue$3,
        FromPropertyDescriptor$2,
        O,
        P,
        {
          "[[Configurable]]": !!configurable,
          "[[Enumerable]]": !!enumerable,
          "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
          "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
        }
      );
    }
    return DefineOwnProperty$1(
      IsDataDescriptor$2,
      SameValue$3,
      FromPropertyDescriptor$2,
      O,
      P,
      Desc
    );
  }
  return true;
};
var $gOPD = gopd$1;
var $SyntaxError = syntax;
var $TypeError$i = type;
var isObject$b = isObject$e;
var isPropertyDescriptor$3 = propertyDescriptor;
var IsAccessorDescriptor2 = IsAccessorDescriptor$3;
var IsExtensible3 = IsExtensible$1;
var isPropertyKey$5 = isPropertyKey$7;
var ToPropertyDescriptor$2 = ToPropertyDescriptor$3;
var SameValue$2 = SameValue$4;
var ValidateAndApplyPropertyDescriptor2 = ValidateAndApplyPropertyDescriptor$1;
var OrdinaryDefineOwnProperty$1 = function OrdinaryDefineOwnProperty(O, P, Desc) {
  if (!isObject$b(O)) {
    throw new $TypeError$i("Assertion failed: O must be an Object");
  }
  if (!isPropertyKey$5(P)) {
    throw new $TypeError$i("Assertion failed: P must be a Property Key");
  }
  if (!isPropertyDescriptor$3(Desc)) {
    throw new $TypeError$i("Assertion failed: Desc must be a Property Descriptor");
  }
  if (!$gOPD) {
    if (IsAccessorDescriptor2(Desc)) {
      throw new $SyntaxError("This environment does not support accessor property descriptors.");
    }
    var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
    var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
    if (creatingNormalDataProperty || settingExistingDataProperty) {
      O[P] = Desc["[[Value]]"];
      return SameValue$2(O[P], Desc["[[Value]]"]);
    }
    throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
  }
  var desc2 = $gOPD(O, P);
  var current = desc2 && ToPropertyDescriptor$2(desc2);
  var extensible = IsExtensible3(O);
  return ValidateAndApplyPropertyDescriptor2(O, P, extensible, Desc, current);
};
var $TypeError$h = type;
var isObject$a = isObject$e;
var isPropertyKey$4 = isPropertyKey$7;
var OrdinaryDefineOwnProperty2 = OrdinaryDefineOwnProperty$1;
var CreateDataProperty$1 = function CreateDataProperty(O, P, V) {
  if (!isObject$a(O)) {
    throw new $TypeError$h("Assertion failed: Type(O) is not Object");
  }
  if (!isPropertyKey$4(P)) {
    throw new $TypeError$h("Assertion failed: P is not a Property Key");
  }
  var newDesc = {
    "[[Configurable]]": true,
    "[[Enumerable]]": true,
    "[[Value]]": V,
    "[[Writable]]": true
  };
  return OrdinaryDefineOwnProperty2(O, P, newDesc);
};
var $TypeError$g = type;
var isObject$9 = isObject$e;
var CreateDataProperty2 = CreateDataProperty$1;
var isPropertyKey$3 = isPropertyKey$7;
var CreateDataPropertyOrThrow$1 = function CreateDataPropertyOrThrow(O, P, V) {
  if (!isObject$9(O)) {
    throw new $TypeError$g("Assertion failed: Type(O) is not Object");
  }
  if (!isPropertyKey$3(P)) {
    throw new $TypeError$g("Assertion failed: P is not a Property Key");
  }
  var success = CreateDataProperty2(O, P, V);
  if (!success) {
    throw new $TypeError$g("unable to create data property");
  }
};
var $TypeError$f = type;
var isPropertyDescriptor$2 = propertyDescriptor;
var fromPropertyDescriptor2 = fromPropertyDescriptor$2;
var FromPropertyDescriptor$1 = function FromPropertyDescriptor2(Desc) {
  if (typeof Desc !== "undefined" && !isPropertyDescriptor$2(Desc)) {
    throw new $TypeError$f("Assertion failed: `Desc` must be a Property Descriptor");
  }
  return fromPropertyDescriptor2(Desc);
};
var $TypeError$e = type;
var hasOwn$2 = hasown;
var isPropertyDescriptor$1 = propertyDescriptor;
var IsDataDescriptor$1 = function IsDataDescriptor2(Desc) {
  if (typeof Desc === "undefined") {
    return false;
  }
  if (!isPropertyDescriptor$1(Desc)) {
    throw new $TypeError$e("Assertion failed: `Desc` must be a Property Descriptor");
  }
  if (!hasOwn$2(Desc, "[[Value]]") && !hasOwn$2(Desc, "[[Writable]]")) {
    return false;
  }
  return true;
};
var $isNaN = _isNaN;
var SameValue$1 = function SameValue2(x, y) {
  if (x === y) {
    if (x === 0) {
      return 1 / x === 1 / y;
    }
    return true;
  }
  return $isNaN(x) && $isNaN(y);
};
var IsCallable$1 = requireIsCallable$1();
var ToBoolean$2 = function ToBoolean2(value) {
  return !!value;
};
var hasOwn$1 = hasown;
var $TypeError$d = type;
var isObject$8 = isObject$e;
var IsCallable = IsCallable$1;
var ToBoolean$1 = ToBoolean$2;
var ToPropertyDescriptor$1 = function ToPropertyDescriptor2(Obj) {
  if (!isObject$8(Obj)) {
    throw new $TypeError$d("ToPropertyDescriptor requires an object");
  }
  var desc2 = {};
  if (hasOwn$1(Obj, "enumerable")) {
    desc2["[[Enumerable]]"] = ToBoolean$1(Obj.enumerable);
  }
  if (hasOwn$1(Obj, "configurable")) {
    desc2["[[Configurable]]"] = ToBoolean$1(Obj.configurable);
  }
  if (hasOwn$1(Obj, "value")) {
    desc2["[[Value]]"] = Obj.value;
  }
  if (hasOwn$1(Obj, "writable")) {
    desc2["[[Writable]]"] = ToBoolean$1(Obj.writable);
  }
  if (hasOwn$1(Obj, "get")) {
    var getter = Obj.get;
    if (typeof getter !== "undefined" && !IsCallable(getter)) {
      throw new $TypeError$d("getter must be a function");
    }
    desc2["[[Get]]"] = getter;
  }
  if (hasOwn$1(Obj, "set")) {
    var setter = Obj.set;
    if (typeof setter !== "undefined" && !IsCallable(setter)) {
      throw new $TypeError$d("setter must be a function");
    }
    desc2["[[Set]]"] = setter;
  }
  if ((hasOwn$1(desc2, "[[Get]]") || hasOwn$1(desc2, "[[Set]]")) && (hasOwn$1(desc2, "[[Value]]") || hasOwn$1(desc2, "[[Writable]]"))) {
    throw new $TypeError$d("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
  }
  return desc2;
};
var $TypeError$c = type;
var isObject$7 = isObject$e;
var isPropertyDescriptor2 = propertyDescriptor;
var DefineOwnProperty2 = DefineOwnProperty$2;
var FromPropertyDescriptor3 = FromPropertyDescriptor$1;
var IsDataDescriptor3 = IsDataDescriptor$1;
var isPropertyKey$2 = isPropertyKey$7;
var SameValue3 = SameValue$1;
var ToPropertyDescriptor3 = ToPropertyDescriptor$1;
var DefinePropertyOrThrow$1 = function DefinePropertyOrThrow(O, P, desc2) {
  if (!isObject$7(O)) {
    throw new $TypeError$c("Assertion failed: Type(O) is not Object");
  }
  if (!isPropertyKey$2(P)) {
    throw new $TypeError$c("Assertion failed: P is not a Property Key");
  }
  var Desc = isPropertyDescriptor2(desc2) ? desc2 : ToPropertyDescriptor3(desc2);
  if (!isPropertyDescriptor2(Desc)) {
    throw new $TypeError$c("Assertion failed: Desc is not a valid Property Descriptor");
  }
  return DefineOwnProperty2(
    IsDataDescriptor3,
    SameValue3,
    FromPropertyDescriptor3,
    O,
    P,
    Desc
  );
};
var $TypeError$b = type;
var isObject$6 = isObject$e;
var DefinePropertyOrThrow2 = DefinePropertyOrThrow$1;
var isPropertyKey$1 = isPropertyKey$7;
var CreateNonEnumerableDataPropertyOrThrow$1 = function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
  if (!isObject$6(O)) {
    throw new $TypeError$b("Assertion failed: Type(O) is not Object");
  }
  if (!isPropertyKey$1(P)) {
    throw new $TypeError$b("Assertion failed: P is not a Property Key");
  }
  var newDesc = {
    "[[Configurable]]": true,
    "[[Enumerable]]": false,
    "[[Value]]": V,
    "[[Writable]]": true
  };
  return DefinePropertyOrThrow2(O, P, newDesc);
};
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$2.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString2 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace2 = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat2 = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace2.call(intStr, sepRegex, "$&_") + "." + $replace2.call($replace2.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace2.call(str, sepRegex, "$&_");
  }
  var utilInspect = requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj2, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj2 === "undefined") {
      return "undefined";
    }
    if (obj2 === null) {
      return "null";
    }
    if (typeof obj2 === "boolean") {
      return obj2 ? "true" : "false";
    }
    if (typeof obj2 === "string") {
      return inspectString(obj2, opts);
    }
    if (typeof obj2 === "number") {
      if (obj2 === 0) {
        return Infinity / obj2 > 0 ? "0" : "-0";
      }
      var str = String(obj2);
      return numericSeparator ? addNumericSeparator(obj2, str) : str;
    }
    if (typeof obj2 === "bigint") {
      var bigIntStr = String(obj2) + "n";
      return numericSeparator ? addNumericSeparator(obj2, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj2 === "object") {
      return isArray2(obj2) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj2) >= 0) {
      return "[Circular]";
    }
    function inspect2(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj2 === "function" && !isRegExp(obj2)) {
      var name2 = nameOf(obj2);
      var keys3 = arrObjKeys(obj2, inspect2);
      return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
    }
    if (isSymbol2(obj2)) {
      var symString = hasShammedSymbols ? $replace2.call(String(obj2), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj2);
      return typeof obj2 === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj2)) {
      var s = "<" + $toLowerCase.call(String(obj2.nodeName));
      var attrs = obj2.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj2.childNodes && obj2.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj2.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj2)) {
      if (obj2.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj2, inspect2);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError2(obj2)) {
      var parts = arrObjKeys(obj2, inspect2);
      if (!("cause" in Error.prototype) && "cause" in obj2 && !isEnumerable.call(obj2, "cause")) {
        return "{ [" + String(obj2) + "] " + $join.call($concat2.call("[cause]: " + inspect2(obj2.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj2) + "]";
      }
      return "{ [" + String(obj2) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj2 === "object" && customInspect) {
      if (inspectSymbol && typeof obj2[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj2, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj2.inspect === "function") {
        return obj2.inspect();
      }
    }
    if (isMap(obj2)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj2, function(value, key2) {
          mapParts.push(inspect2(key2, obj2, true) + " => " + inspect2(value, obj2));
        });
      }
      return collectionOf("Map", mapSize.call(obj2), mapParts, indent);
    }
    if (isSet(obj2)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj2, function(value) {
          setParts.push(inspect2(value, obj2));
        });
      }
      return collectionOf("Set", setSize.call(obj2), setParts, indent);
    }
    if (isWeakMap(obj2)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj2)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj2)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj2)) {
      return markBoxed(inspect2(Number(obj2)));
    }
    if (isBigInt(obj2)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj2)));
    }
    if (isBoolean2(obj2)) {
      return markBoxed(booleanValueOf.call(obj2));
    }
    if (isString2(obj2)) {
      return markBoxed(inspect2(String(obj2)));
    }
    if (typeof window !== "undefined" && obj2 === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj2 === globalThis || typeof commonjsGlobal !== "undefined" && obj2 === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj2) && !isRegExp(obj2)) {
      var ys = arrObjKeys(obj2, inspect2);
      var isPlainObject2 = gPO ? gPO(obj2) === Object.prototype : obj2 instanceof Object || obj2.constructor === Object;
      var protoTag = obj2 instanceof Object ? "" : "null prototype";
      var stringTag2 = !isPlainObject2 && toStringTag && Object(obj2) === obj2 && toStringTag in obj2 ? $slice.call(toStr2(obj2), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj2.constructor !== "function" ? "" : obj2.constructor.name ? obj2.constructor.name + " " : "";
      var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat2.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj2);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace2.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj2) {
    return !toStringTag || !(typeof obj2 === "object" && (toStringTag in obj2 || typeof obj2[toStringTag] !== "undefined"));
  }
  function isArray2(obj2) {
    return toStr2(obj2) === "[object Array]" && canTrustToString(obj2);
  }
  function isDate(obj2) {
    return toStr2(obj2) === "[object Date]" && canTrustToString(obj2);
  }
  function isRegExp(obj2) {
    return toStr2(obj2) === "[object RegExp]" && canTrustToString(obj2);
  }
  function isError2(obj2) {
    return toStr2(obj2) === "[object Error]" && canTrustToString(obj2);
  }
  function isString2(obj2) {
    return toStr2(obj2) === "[object String]" && canTrustToString(obj2);
  }
  function isNumber2(obj2) {
    return toStr2(obj2) === "[object Number]" && canTrustToString(obj2);
  }
  function isBoolean2(obj2) {
    return toStr2(obj2) === "[object Boolean]" && canTrustToString(obj2);
  }
  function isSymbol2(obj2) {
    if (hasShammedSymbols) {
      return obj2 && typeof obj2 === "object" && obj2 instanceof Symbol;
    }
    if (typeof obj2 === "symbol") {
      return true;
    }
    if (!obj2 || typeof obj2 !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj2);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj2) {
    if (!obj2 || typeof obj2 !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj2);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn2 = Object.prototype.hasOwnProperty || function(key2) {
    return key2 in this;
  };
  function has(obj2, key2) {
    return hasOwn2.call(obj2, key2);
  }
  function toStr2(obj2) {
    return objectToString2.call(obj2);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace2.call($replace2.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj2, inspect2) {
    var isArr = isArray2(obj2);
    var xs = [];
    if (isArr) {
      xs.length = obj2.length;
      for (var i = 0; i < obj2.length; i++) {
        xs[i] = has(obj2, i) ? inspect2(obj2[i], obj2) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj2) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key2 in obj2) {
      if (!has(obj2, key2)) {
        continue;
      }
      if (isArr && String(Number(key2)) === key2 && key2 < obj2.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key2)) {
        xs.push(inspect2(key2, obj2) + ": " + inspect2(obj2[key2], obj2));
      } else {
        xs.push(key2 + ": " + inspect2(obj2[key2], obj2));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj2, syms[j])) {
          xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj2[syms[j]], obj2));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var isLeadingSurrogate;
var hasRequiredIsLeadingSurrogate;
function requireIsLeadingSurrogate() {
  if (hasRequiredIsLeadingSurrogate) return isLeadingSurrogate;
  hasRequiredIsLeadingSurrogate = 1;
  isLeadingSurrogate = function isLeadingSurrogate2(charCode) {
    return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
  };
  return isLeadingSurrogate;
}
var isTrailingSurrogate;
var hasRequiredIsTrailingSurrogate;
function requireIsTrailingSurrogate() {
  if (hasRequiredIsTrailingSurrogate) return isTrailingSurrogate;
  hasRequiredIsTrailingSurrogate = 1;
  isTrailingSurrogate = function isTrailingSurrogate2(charCode) {
    return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
  };
  return isTrailingSurrogate;
}
var UTF16SurrogatePairToCodePoint;
var hasRequiredUTF16SurrogatePairToCodePoint;
function requireUTF16SurrogatePairToCodePoint() {
  if (hasRequiredUTF16SurrogatePairToCodePoint) return UTF16SurrogatePairToCodePoint;
  hasRequiredUTF16SurrogatePairToCodePoint = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $TypeError2 = type;
  var $fromCharCode = GetIntrinsic3("%String.fromCharCode%");
  var isLeadingSurrogate2 = requireIsLeadingSurrogate();
  var isTrailingSurrogate2 = requireIsTrailingSurrogate();
  UTF16SurrogatePairToCodePoint = function UTF16SurrogatePairToCodePoint2(lead, trail) {
    if (!isLeadingSurrogate2(lead) || !isTrailingSurrogate2(trail)) {
      throw new $TypeError2("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
    }
    return $fromCharCode(lead) + $fromCharCode(trail);
  };
  return UTF16SurrogatePairToCodePoint;
}
var CodePointAt;
var hasRequiredCodePointAt;
function requireCodePointAt() {
  if (hasRequiredCodePointAt) return CodePointAt;
  hasRequiredCodePointAt = 1;
  var $TypeError2 = type;
  var callBound2 = requireCallBound();
  var isLeadingSurrogate2 = requireIsLeadingSurrogate();
  var isTrailingSurrogate2 = requireIsTrailingSurrogate();
  var UTF16SurrogatePairToCodePoint2 = requireUTF16SurrogatePairToCodePoint();
  var $charAt = callBound2("String.prototype.charAt");
  var $charCodeAt = callBound2("String.prototype.charCodeAt");
  CodePointAt = function CodePointAt2(string, position) {
    if (typeof string !== "string") {
      throw new $TypeError2("Assertion failed: `string` must be a String");
    }
    var size = string.length;
    if (position < 0 || position >= size) {
      throw new $TypeError2("Assertion failed: `position` must be >= 0, and < the length of `string`");
    }
    var first = $charCodeAt(string, position);
    var cp = $charAt(string, position);
    var firstIsLeading = isLeadingSurrogate2(first);
    var firstIsTrailing = isTrailingSurrogate2(first);
    if (!firstIsLeading && !firstIsTrailing) {
      return {
        "[[CodePoint]]": cp,
        "[[CodeUnitCount]]": 1,
        "[[IsUnpairedSurrogate]]": false
      };
    }
    if (firstIsTrailing || position + 1 === size) {
      return {
        "[[CodePoint]]": cp,
        "[[CodeUnitCount]]": 1,
        "[[IsUnpairedSurrogate]]": true
      };
    }
    var second = $charCodeAt(string, position + 1);
    if (!isTrailingSurrogate2(second)) {
      return {
        "[[CodePoint]]": cp,
        "[[CodeUnitCount]]": 1,
        "[[IsUnpairedSurrogate]]": true
      };
    }
    return {
      "[[CodePoint]]": UTF16SurrogatePairToCodePoint2(first, second),
      "[[CodeUnitCount]]": 2,
      "[[IsUnpairedSurrogate]]": false
    };
  };
  return CodePointAt;
}
var _isFinite;
var hasRequired_isFinite;
function require_isFinite() {
  if (hasRequired_isFinite) return _isFinite;
  hasRequired_isFinite = 1;
  var $isNaN2 = _isNaN;
  _isFinite = function isFinite2(x) {
    return (typeof x === "number" || typeof x === "bigint") && !$isNaN2(x) && x !== Infinity && x !== -Infinity;
  };
  return _isFinite;
}
var isInteger;
var hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger) return isInteger;
  hasRequiredIsInteger = 1;
  var $abs = abs$1;
  var $floor = floor$1;
  var $isNaN2 = _isNaN;
  var $isFinite = require_isFinite();
  isInteger = function isInteger2(argument) {
    if (typeof argument !== "number" || $isNaN2(argument) || !$isFinite(argument)) {
      return false;
    }
    var absValue = $abs(argument);
    return $floor(absValue) === absValue;
  };
  return isInteger;
}
var maxSafeInteger;
var hasRequiredMaxSafeInteger;
function requireMaxSafeInteger() {
  if (hasRequiredMaxSafeInteger) return maxSafeInteger;
  hasRequiredMaxSafeInteger = 1;
  maxSafeInteger = /** @type {import('./maxSafeInteger')} */
  Number.MAX_SAFE_INTEGER || 9007199254740991;
  return maxSafeInteger;
}
var AdvanceStringIndex$1;
var hasRequiredAdvanceStringIndex;
function requireAdvanceStringIndex() {
  if (hasRequiredAdvanceStringIndex) return AdvanceStringIndex$1;
  hasRequiredAdvanceStringIndex = 1;
  var CodePointAt2 = requireCodePointAt();
  var $TypeError2 = type;
  var isInteger2 = requireIsInteger();
  var MAX_SAFE_INTEGER2 = requireMaxSafeInteger();
  AdvanceStringIndex$1 = function AdvanceStringIndex2(S, index, unicode) {
    if (typeof S !== "string") {
      throw new $TypeError2("Assertion failed: `S` must be a String");
    }
    if (!isInteger2(index) || index < 0 || index > MAX_SAFE_INTEGER2) {
      throw new $TypeError2("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
    }
    if (typeof unicode !== "boolean") {
      throw new $TypeError2("Assertion failed: `unicode` must be a Boolean");
    }
    if (!unicode) {
      return index + 1;
    }
    var length = S.length;
    if (index + 1 >= length) {
      return index + 1;
    }
    var cp = CodePointAt2(S, index);
    return index + cp["[[CodeUnitCount]]"];
  };
  return AdvanceStringIndex$1;
}
var CreateIteratorResultObject;
var hasRequiredCreateIteratorResultObject;
function requireCreateIteratorResultObject() {
  if (hasRequiredCreateIteratorResultObject) return CreateIteratorResultObject;
  hasRequiredCreateIteratorResultObject = 1;
  var $TypeError2 = type;
  CreateIteratorResultObject = function CreateIteratorResultObject2(value, done) {
    if (typeof done !== "boolean") {
      throw new $TypeError2("Assertion failed: Type(done) is not Boolean");
    }
    return {
      value,
      done
    };
  };
  return CreateIteratorResultObject;
}
var $TypeError$a = type;
var inspect$1 = requireObjectInspect();
var isPropertyKey2 = isPropertyKey$7;
var isObject$5 = isObject$e;
var Get$2 = function Get(O, P) {
  if (!isObject$5(O)) {
    throw new $TypeError$a("Assertion failed: Type(O) is not Object");
  }
  if (!isPropertyKey2(P)) {
    throw new $TypeError$a("Assertion failed: P is not a Property Key, got " + inspect$1(P));
  }
  return O[P];
};
var $TypeError$9 = type;
var isObject$4 = isObject$e;
var Get$1 = Get$2;
var ToBoolean3 = ToBoolean$4;
var IteratorComplete$1 = function IteratorComplete(iterResult) {
  if (!isObject$4(iterResult)) {
    throw new $TypeError$9("Assertion failed: Type(iterResult) is not Object");
  }
  return ToBoolean3(Get$1(iterResult, "done"));
};
var $TypeError$8 = type;
var isObject$3 = isObject$e;
var Get2 = Get$2;
var IteratorValue$1 = function IteratorValue(iterResult) {
  if (!isObject$3(iterResult)) {
    throw new $TypeError$8("Assertion failed: Type(iterResult) is not Object");
  }
  return Get2(iterResult, "value");
};
var callBind$1 = { exports: {} };
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic3 = getIntrinsic;
  var define2 = defineDataProperty$2;
  var hasDescriptors2 = hasPropertyDescriptors_1();
  var gOPD2 = gopd$1;
  var $TypeError2 = type;
  var $floor = GetIntrinsic3("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError2("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError2("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc2 = gOPD2(fn, "length");
      if (desc2 && !desc2.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc2 && !desc2.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors2) {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind3 = functionBind;
  var $apply2 = requireFunctionApply();
  var actualApply$1 = actualApply;
  applyBind = function applyBind2() {
    return actualApply$1(bind3, $apply2, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind$1.exports;
  hasRequiredCallBind = 1;
  (function(module2) {
    var setFunctionLength2 = requireSetFunctionLength();
    var $defineProperty2 = esDefineProperty;
    var callBindBasic2 = callBindApplyHelpers;
    var applyBind2 = requireApplyBind();
    module2.exports = function callBind2(originalFunction) {
      var func = callBindBasic2(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty2) {
      $defineProperty2(module2.exports, "apply", { value: applyBind2 });
    } else {
      module2.exports.apply = applyBind2;
    }
  })(callBind$1);
  return callBind$1.exports;
}
var PromiseResolve;
var hasRequiredPromiseResolve;
function requirePromiseResolve() {
  if (hasRequiredPromiseResolve) return PromiseResolve;
  hasRequiredPromiseResolve = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBind2 = requireCallBind();
  var $SyntaxError2 = syntax;
  var $resolve = GetIntrinsic3("%Promise.resolve%", true);
  var $PromiseResolve = $resolve && callBind2($resolve);
  PromiseResolve = function PromiseResolve2(C, x) {
    if (!$PromiseResolve) {
      throw new $SyntaxError2("This environment does not support Promises.");
    }
    return $PromiseResolve(C, x);
  };
  return PromiseResolve;
}
var AsyncFromSyncIteratorContinuation;
var hasRequiredAsyncFromSyncIteratorContinuation;
function requireAsyncFromSyncIteratorContinuation() {
  if (hasRequiredAsyncFromSyncIteratorContinuation) return AsyncFromSyncIteratorContinuation;
  hasRequiredAsyncFromSyncIteratorContinuation = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $SyntaxError2 = syntax;
  var $TypeError2 = type;
  var isObject3 = isObject$e;
  var $Promise = GetIntrinsic3("%Promise%", true);
  var callBound2 = requireCallBound();
  var CreateIteratorResultObject2 = requireCreateIteratorResultObject();
  var IteratorComplete3 = IteratorComplete$1;
  var IteratorValue3 = IteratorValue$1;
  var PromiseResolve2 = requirePromiseResolve();
  var $then = callBound2("Promise.prototype.then", true);
  AsyncFromSyncIteratorContinuation = function AsyncFromSyncIteratorContinuation2(result) {
    if (!isObject3(result)) {
      throw new $TypeError2("Assertion failed: Type(O) is not Object");
    }
    if (arguments.length > 1) {
      throw new $SyntaxError2("although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation");
    }
    if (!$Promise) {
      throw new $SyntaxError2("This environment does not support Promises.");
    }
    return new $Promise(function(resolve) {
      var done = IteratorComplete3(result);
      var value = IteratorValue3(result);
      var valueWrapper = PromiseResolve2($Promise, value);
      var onFulfilled = function(value2) {
        return CreateIteratorResultObject2(value2, done);
      };
      resolve($then(valueWrapper, onFulfilled));
    });
  };
  return AsyncFromSyncIteratorContinuation;
}
var IsArray;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return IsArray;
  hasRequiredIsArray = 1;
  IsArray = requireIsArray$1();
  return IsArray;
}
var Call$1;
var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall) return Call$1;
  hasRequiredCall = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var $TypeError2 = type;
  var IsArray2 = requireIsArray();
  var $apply2 = GetIntrinsic3("%Reflect.apply%", true) || callBound2("Function.prototype.apply");
  Call$1 = function Call2(F, V) {
    var argumentsList = arguments.length > 2 ? arguments[2] : [];
    if (!IsArray2(argumentsList)) {
      throw new $TypeError2("Assertion failed: optional `argumentsList`, if provided, must be a List");
    }
    return $apply2(F, V, argumentsList);
  };
  return Call$1;
}
var GetV;
var hasRequiredGetV;
function requireGetV() {
  if (hasRequiredGetV) return GetV;
  hasRequiredGetV = 1;
  var $TypeError2 = type;
  var inspect2 = requireObjectInspect();
  var isPropertyKey3 = isPropertyKey$7;
  GetV = function GetV2(V, P) {
    if (!isPropertyKey3(P)) {
      throw new $TypeError2("Assertion failed: P is not a Property Key, got " + inspect2(P));
    }
    return V[P];
  };
  return GetV;
}
var GetMethod$1;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod) return GetMethod$1;
  hasRequiredGetMethod = 1;
  var $TypeError2 = type;
  var GetV2 = requireGetV();
  var IsCallable2 = requireIsCallable();
  var isPropertyKey3 = isPropertyKey$7;
  var inspect2 = requireObjectInspect();
  GetMethod$1 = function GetMethod2(O, P) {
    if (!isPropertyKey3(P)) {
      throw new $TypeError2("Assertion failed: P is not a Property Key");
    }
    var func = GetV2(O, P);
    if (func == null) {
      return void 0;
    }
    if (!IsCallable2(func)) {
      throw new $TypeError2(inspect2(P) + " is not a function: " + inspect2(func));
    }
    return func;
  };
  return GetMethod$1;
}
var hasOwn = hasown;
var iteratorRecord = function isIteratorRecord(value) {
  return !!value && typeof value === "object" && hasOwn(value, "[[Iterator]]") && hasOwn(value, "[[NextMethod]]") && hasOwn(value, "[[Done]]") && typeof value["[[Done]]"] === "boolean";
};
var $TypeError$7 = type;
var isObject$2 = isObject$e;
var Call = requireCall();
var isIteratorRecord$2 = iteratorRecord;
var IteratorNext$1 = function IteratorNext(iteratorRecord2) {
  if (!isIteratorRecord$2(iteratorRecord2)) {
    throw new $TypeError$7("Assertion failed: `iteratorRecord` must be an Iterator Record");
  }
  var result;
  try {
    if (arguments.length < 2) {
      result = Call(iteratorRecord2["[[NextMethod]]"], iteratorRecord2["[[Iterator]]"]);
    } else {
      result = Call(iteratorRecord2["[[NextMethod]]"], iteratorRecord2["[[Iterator]]"], [arguments[1]]);
    }
  } catch (e) {
    iteratorRecord2["[[Done]]"] = true;
    throw e;
  }
  if (!isObject$2(result)) {
    iteratorRecord2["[[Done]]"] = true;
    throw new $TypeError$7("iterator next must return an object");
  }
  return result;
};
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  forEach = function forEach2(array, callback) {
    for (var i = 0; i < array.length; i += 1) {
      callback(array[i], i, array);
    }
  };
  return forEach;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect2 = requireObjectInspect();
  var $TypeError2 = type;
  var listGetNode = function(list, key2, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key2) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key2) {
    if (!objects) {
      return void 0;
    }
    var node2 = listGetNode(objects, key2);
    return node2 && node2.value;
  };
  var listSet = function(objects, key2, value) {
    var node2 = listGetNode(objects, key2);
    if (node2) {
      node2.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key2,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key2) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key2);
  };
  var listDelete = function(objects, key2) {
    if (objects) {
      return listGetNode(objects, key2, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError2("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key2);
        if (deletedNode && root && root === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key2) {
        return listGet($o, key2);
      },
      has: function(key2) {
        return listHas($o, key2);
      },
      set: function(key2, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key2,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var inspect2 = requireObjectInspect();
  var $TypeError2 = type;
  var $Map = GetIntrinsic3("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError2("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        if ($m) {
          var result = $mapDelete($m, key2);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key2) {
        if ($m) {
          return $mapGet($m, key2);
        }
      },
      has: function(key2) {
        if ($m) {
          return $mapHas($m, key2);
        }
        return false;
      },
      set: function(key2, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var inspect2 = requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError2 = type;
  var $WeakMap = GetIntrinsic3("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError2("Side channel does not contain " + inspect2(key2));
          }
        },
        "delete": function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key2);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key2);
            }
          }
          return false;
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          }
          return $m && $m.get(key2);
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          }
          return !!$m && $m.has(key2);
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key2, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError2 = type;
  var inspect2 = requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError2("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        return !!$channelData && $channelData["delete"](key2);
      },
      get: function(key2) {
        return $channelData && $channelData.get(key2);
      },
      has: function(key2) {
        return !!$channelData && $channelData.has(key2);
      },
      set: function(key2, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key2, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var internalSlot;
var hasRequiredInternalSlot;
function requireInternalSlot() {
  if (hasRequiredInternalSlot) return internalSlot;
  hasRequiredInternalSlot = 1;
  var hasOwn2 = hasown;
  var channel = requireSideChannel()();
  var $TypeError2 = type;
  var SLOT = {
    assert: function(O, slot) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new $TypeError2("`O` is not an object");
      }
      if (typeof slot !== "string") {
        throw new $TypeError2("`slot` must be a string");
      }
      channel.assert(O);
      if (!SLOT.has(O, slot)) {
        throw new $TypeError2("`" + slot + "` is not present on `O`");
      }
    },
    get: function(O, slot) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new $TypeError2("`O` is not an object");
      }
      if (typeof slot !== "string") {
        throw new $TypeError2("`slot` must be a string");
      }
      var slots = channel.get(O);
      return slots && slots[
        /** @type {SaltedInternalSlot} */
        "$" + slot
      ];
    },
    has: function(O, slot) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new $TypeError2("`O` is not an object");
      }
      if (typeof slot !== "string") {
        throw new $TypeError2("`slot` must be a string");
      }
      var slots = channel.get(O);
      return !!slots && hasOwn2(
        slots,
        /** @type {SaltedInternalSlot} */
        "$" + slot
      );
    },
    set: function(O, slot, V) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new $TypeError2("`O` is not an object");
      }
      if (typeof slot !== "string") {
        throw new $TypeError2("`slot` must be a string");
      }
      var slots = channel.get(O);
      if (!slots) {
        slots = {};
        channel.set(O, slots);
      }
      slots[
        /** @type {SaltedInternalSlot} */
        "$" + slot
      ] = V;
    }
  };
  if (Object.freeze) {
    Object.freeze(SLOT);
  }
  internalSlot = SLOT;
  return internalSlot;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var test = {
    __proto__: null,
    foo: {}
  };
  var result = { __proto__: test }.foo === test.foo && !(test instanceof Object);
  hasProto = function hasProto2() {
    return result;
  };
  return hasProto;
}
var OrdinaryObjectCreate;
var hasRequiredOrdinaryObjectCreate;
function requireOrdinaryObjectCreate() {
  if (hasRequiredOrdinaryObjectCreate) return OrdinaryObjectCreate;
  hasRequiredOrdinaryObjectCreate = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $ObjectCreate = GetIntrinsic3("%Object.create%", true);
  var $TypeError2 = type;
  var $SyntaxError2 = syntax;
  var isObject3 = isObject$e;
  var IsArray2 = requireIsArray();
  var forEach2 = requireForEach();
  var SLOT = requireInternalSlot();
  var hasProto2 = requireHasProto()();
  OrdinaryObjectCreate = function OrdinaryObjectCreate2(proto2) {
    if (proto2 !== null && !isObject3(proto2)) {
      throw new $TypeError2("Assertion failed: `proto` must be null or an object");
    }
    var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
    if (!IsArray2(additionalInternalSlotsList)) {
      throw new $TypeError2("Assertion failed: `additionalInternalSlotsList` must be an Array");
    }
    var O;
    if (hasProto2) {
      O = { __proto__: proto2 };
    } else if ($ObjectCreate) {
      O = $ObjectCreate(proto2);
    } else {
      if (proto2 === null) {
        throw new $SyntaxError2("native Object.create support is required to create null objects");
      }
      var T = function T2() {
      };
      T.prototype = proto2;
      O = new T();
    }
    if (additionalInternalSlotsList.length > 0) {
      forEach2(additionalInternalSlotsList, function(slot) {
        SLOT.set(O, slot, void 0);
      });
    }
    return O;
  };
  return OrdinaryObjectCreate;
}
var CreateAsyncFromSyncIterator$1;
var hasRequiredCreateAsyncFromSyncIterator;
function requireCreateAsyncFromSyncIterator() {
  if (hasRequiredCreateAsyncFromSyncIterator) return CreateAsyncFromSyncIterator$1;
  hasRequiredCreateAsyncFromSyncIterator = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $SyntaxError2 = syntax;
  var $TypeError2 = type;
  var isObject3 = isObject$e;
  var $Promise = GetIntrinsic3("%Promise%", true);
  var AsyncFromSyncIteratorContinuation2 = requireAsyncFromSyncIteratorContinuation();
  var Call2 = requireCall();
  var CreateIteratorResultObject2 = requireCreateIteratorResultObject();
  var Get3 = Get$2;
  var GetMethod2 = requireGetMethod();
  var IteratorNext3 = IteratorNext$1;
  var OrdinaryObjectCreate2 = requireOrdinaryObjectCreate();
  var isIteratorRecord3 = iteratorRecord;
  var SLOT = requireInternalSlot();
  var $AsyncFromSyncIteratorPrototype = GetIntrinsic3("%AsyncFromSyncIteratorPrototype%", true) || {
    next: function next(value) {
      if (!$Promise) {
        throw new $SyntaxError2("This environment does not support Promises.");
      }
      var O = this;
      SLOT.assert(O, "[[SyncIteratorRecord]]");
      var argsLength = arguments.length;
      return new $Promise(function(resolve) {
        var syncIteratorRecord = SLOT.get(O, "[[SyncIteratorRecord]]");
        var result;
        if (argsLength > 0) {
          result = IteratorNext3(syncIteratorRecord, value);
        } else {
          result = IteratorNext3(syncIteratorRecord);
        }
        resolve(AsyncFromSyncIteratorContinuation2(result));
      });
    },
    "return": function() {
      if (!$Promise) {
        throw new $SyntaxError2("This environment does not support Promises.");
      }
      var O = this;
      SLOT.assert(O, "[[SyncIteratorRecord]]");
      var valueIsPresent = arguments.length > 0;
      var value = valueIsPresent ? arguments[0] : void 0;
      return new $Promise(function(resolve, reject) {
        var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
        var iteratorReturn = GetMethod2(syncIterator, "return");
        if (typeof iteratorReturn === "undefined") {
          var iterResult = CreateIteratorResultObject2(value, true);
          Call2(resolve, void 0, [iterResult]);
          return;
        }
        var result;
        if (valueIsPresent) {
          result = Call2(iteratorReturn, syncIterator, [value]);
        } else {
          result = Call2(iteratorReturn, syncIterator);
        }
        if (!isObject3(result)) {
          Call2(reject, void 0, [new $TypeError2("Iterator `return` method returned a non-object value.")]);
          return;
        }
        resolve(AsyncFromSyncIteratorContinuation2(result));
      });
    },
    "throw": function() {
      if (!$Promise) {
        throw new $SyntaxError2("This environment does not support Promises.");
      }
      var O = this;
      SLOT.assert(O, "[[SyncIteratorRecord]]");
      var valueIsPresent = arguments.length > 0;
      var value = valueIsPresent ? arguments[0] : void 0;
      return new $Promise(function(resolve, reject) {
        var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
        var throwMethod = GetMethod2(syncIterator, "throw");
        if (typeof throwMethod === "undefined") {
          Call2(reject, void 0, [value]);
          return;
        }
        var result;
        if (valueIsPresent) {
          result = Call2(throwMethod, syncIterator, [value]);
        } else {
          result = Call2(throwMethod, syncIterator);
        }
        if (!isObject3(result)) {
          Call2(reject, void 0, [new $TypeError2("Iterator `throw` method returned a non-object value.")]);
          return;
        }
        resolve(AsyncFromSyncIteratorContinuation2(
          result
          /* , promiseCapability */
        ));
      });
    }
  };
  CreateAsyncFromSyncIterator$1 = function CreateAsyncFromSyncIterator2(syncIteratorRecord) {
    if (!isIteratorRecord3(syncIteratorRecord)) {
      throw new $TypeError2("Assertion failed: `syncIteratorRecord` must be an Iterator Record");
    }
    var asyncIterator = OrdinaryObjectCreate2($AsyncFromSyncIteratorPrototype);
    SLOT.set(asyncIterator, "[[SyncIteratorRecord]]", syncIteratorRecord);
    var nextMethod = Get3(asyncIterator, "next");
    return {
      // steps 3-4
      "[[Iterator]]": asyncIterator,
      "[[NextMethod]]": nextMethod,
      "[[Done]]": false
    };
  };
  return CreateAsyncFromSyncIterator$1;
}
var GetIteratorFromMethod$1;
var hasRequiredGetIteratorFromMethod;
function requireGetIteratorFromMethod() {
  if (hasRequiredGetIteratorFromMethod) return GetIteratorFromMethod$1;
  hasRequiredGetIteratorFromMethod = 1;
  var $TypeError2 = type;
  var isObject3 = isObject$e;
  var Call2 = requireCall();
  var Get3 = Get$2;
  var IsCallable2 = requireIsCallable();
  GetIteratorFromMethod$1 = function GetIteratorFromMethod2(obj2, method) {
    if (!IsCallable2(method)) {
      throw new $TypeError2("method must be a function");
    }
    var iterator = Call2(method, obj2);
    if (!isObject3(iterator)) {
      throw new $TypeError2("iterator must return an object");
    }
    var nextMethod = Get3(iterator, "next");
    return {
      // steps 4-5
      "[[Iterator]]": iterator,
      "[[NextMethod]]": nextMethod,
      "[[Done]]": false
    };
  };
  return GetIteratorFromMethod$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var isString;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString;
  hasRequiredIsString = 1;
  var callBound2 = requireCallBound();
  var $strValueOf = callBound2("String.prototype.valueOf");
  var tryStringObject = function tryStringObject2(value) {
    try {
      $strValueOf(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var $toString = callBound2("Object.prototype.toString");
  var strClass = "[object String]";
  var hasToStringTag = requireShams()();
  isString = function isString2(value) {
    if (typeof value === "string") {
      return true;
    }
    if (!value || typeof value !== "object") {
      return false;
    }
    return hasToStringTag ? tryStringObject(value) : $toString(value) === strClass;
  };
  return isString;
}
var getIteratorMethod$1;
var hasRequiredGetIteratorMethod;
function requireGetIteratorMethod() {
  if (hasRequiredGetIteratorMethod) return getIteratorMethod$1;
  hasRequiredGetIteratorMethod = 1;
  var hasSymbols2 = requireHasSymbols()();
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var isString2 = requireIsString();
  var $iterator = GetIntrinsic3("%Symbol.iterator%", true);
  var $stringSlice = callBound2("String.prototype.slice");
  var $String = GetIntrinsic3("%String%");
  var IsArray2 = requireIsArray$1();
  getIteratorMethod$1 = function getIteratorMethod2(ES2, iterable) {
    var usingIterator;
    if (hasSymbols2) {
      usingIterator = ES2.GetMethod(iterable, $iterator);
    } else if (IsArray2(iterable)) {
      usingIterator = function() {
        var i = -1;
        var arr = this;
        return {
          next: function() {
            i += 1;
            return {
              done: i >= arr.length,
              value: arr[i]
            };
          }
        };
      };
    } else if (isString2(iterable)) {
      usingIterator = function() {
        var i = 0;
        return {
          next: function() {
            var nextIndex = ES2.AdvanceStringIndex($String(iterable), i, true);
            var value = $stringSlice(iterable, i, nextIndex);
            i = nextIndex;
            var done = nextIndex > iterable.length;
            return {
              done,
              value: done ? void 0 : value
            };
          }
        };
      };
    }
    return usingIterator;
  };
  return getIteratorMethod$1;
}
var GetIntrinsic2 = getIntrinsic;
var $TypeError$6 = type;
var $asyncIterator = GetIntrinsic2("%Symbol.asyncIterator%", true);
var inspect = requireObjectInspect();
var hasSymbols = requireHasSymbols()();
var AdvanceStringIndex = requireAdvanceStringIndex();
var CreateAsyncFromSyncIterator = requireCreateAsyncFromSyncIterator();
var GetIteratorFromMethod = requireGetIteratorFromMethod();
var GetMethod = requireGetMethod();
var ES = {
  AdvanceStringIndex,
  GetMethod
};
var getIteratorMethod = requireGetIteratorMethod();
var GetIterator$1 = function GetIterator(obj2, kind) {
  if (kind !== "SYNC" && kind !== "ASYNC") {
    throw new $TypeError$6("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
  }
  var method;
  if (kind === "ASYNC") {
    if (hasSymbols && $asyncIterator) {
      method = GetMethod(obj2, $asyncIterator);
    }
  }
  if (typeof method === "undefined") {
    var syncMethod = getIteratorMethod(ES, obj2);
    if (kind === "ASYNC") {
      if (typeof syncMethod === "undefined") {
        throw new $TypeError$6("iterator method is `undefined`");
      }
      var syncIteratorRecord = GetIteratorFromMethod(obj2, syncMethod);
      return CreateAsyncFromSyncIterator(syncIteratorRecord);
    }
    method = syncMethod;
  }
  if (typeof method === "undefined") {
    throw new $TypeError$6("iterator method is `undefined`");
  }
  return GetIteratorFromMethod(obj2, method);
};
var $TypeError$5 = type;
var IteratorComplete2 = IteratorComplete$1;
var IteratorNext2 = IteratorNext$1;
var isIteratorRecord$1 = iteratorRecord;
var IteratorStep$1 = function IteratorStep(iteratorRecord2) {
  if (!isIteratorRecord$1(iteratorRecord2)) {
    throw new $TypeError$5("Assertion failed: `iteratorRecord` must be an Iterator Record");
  }
  var result = IteratorNext2(iteratorRecord2);
  try {
    var done = IteratorComplete2(result);
  } catch (e) {
    iteratorRecord2["[[Done]]"] = true;
    throw e;
  }
  if (done) {
    iteratorRecord2["[[Done]]"] = true;
    return false;
  }
  return result;
};
var $TypeError$4 = type;
var IteratorStep2 = IteratorStep$1;
var IteratorValue2 = IteratorValue$1;
var isIteratorRecord2 = iteratorRecord;
var IteratorToList$1 = function IteratorToList(iteratorRecord2) {
  if (!isIteratorRecord2(iteratorRecord2)) {
    throw new $TypeError$4("Assertion failed: `iteratorRecord` must be an Iterator Record");
  }
  var values2 = [];
  var next = true;
  while (next) {
    next = IteratorStep2(iteratorRecord2);
    if (next) {
      var nextValue = IteratorValue2(next);
      values2[values2.length] = nextValue;
    }
  }
  return values2;
};
var Reflect_setPrototypeOf = typeof Reflect !== "undefined" && Reflect.setPrototypeOf || null;
var $Object = esObjectAtoms;
var Object_setPrototypeOf = $Object.setPrototypeOf || null;
var callBind = callBindApplyHelpers;
var gOPD$1 = gopd$1;
var $TypeError$3 = type;
var obj = {};
try {
  obj.__proto__ = null;
} catch (e) {
  if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
    throw e;
  }
}
var hasProtoMutator = !("toString" in obj);
var desc = gOPD$1 && gOPD$1(
  Object.prototype,
  /** @type {keyof typeof Object.prototype} */
  "__proto__"
);
var set = hasProtoMutator && // eslint-disable-next-line no-extra-parens
(!!desc && typeof desc.set === "function" && /** @type {import('./set')} */
callBind([desc.set]) || /** @type {import('./set')} */
function setDunder(object, proto2) {
  if (object == null) {
    throw new $TypeError$3("set Object.prototype.__proto__ called on null or undefined");
  }
  object.__proto__ = proto2;
  return proto2;
});
var reflectSetProto = Reflect_setPrototypeOf;
var originalSetProto = Object_setPrototypeOf;
var setDunderProto = set;
var $TypeError$2 = type;
var setProto = reflectSetProto ? function setProto2(O, proto2) {
  if (reflectSetProto(O, proto2)) {
    return O;
  }
  throw new $TypeError$2("Reflect.setPrototypeOf: failed to set [[Prototype]]");
} : originalSetProto || (setDunderProto ? function setProto3(O, proto2) {
  setDunderProto(O, proto2);
  return O;
} : null);
var $TypeError$1 = type;
var isObject$1 = isObject$e;
var $getProto = getProto$1;
var OrdinaryGetPrototypeOf$1 = function OrdinaryGetPrototypeOf(O) {
  if (!isObject$1(O)) {
    throw new $TypeError$1("Assertion failed: O must be an Object");
  }
  if (!$getProto) {
    throw new $TypeError$1("This environment does not support fetching prototypes.");
  }
  return $getProto(O);
};
var $TypeError = type;
var $setProto = setProto;
var isObject2 = isObject$e;
var OrdinaryGetPrototypeOf2 = OrdinaryGetPrototypeOf$1;
var OrdinarySetPrototypeOf$1 = function OrdinarySetPrototypeOf(O, V) {
  if (V !== null && !isObject2(V)) {
    throw new $TypeError("Assertion failed: V must be Object or Null");
  }
  try {
    $setProto(O, V);
  } catch (e) {
    return false;
  }
  return OrdinaryGetPrototypeOf2(O) === V;
};
var CreateDataPropertyOrThrow2 = CreateDataPropertyOrThrow$1;
var CreateNonEnumerableDataPropertyOrThrow2 = CreateNonEnumerableDataPropertyOrThrow$1;
var GetIterator2 = GetIterator$1;
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var IteratorToList2 = IteratorToList$1;
var OrdinarySetPrototypeOf2 = OrdinarySetPrototypeOf$1;
var $Error = esErrors;
function AggregateError$1(errors2, message2) {
  var error2 = new $Error(message2);
  OrdinarySetPrototypeOf2(error2, proto);
  delete error2.constructor;
  var errorsList = IteratorToList2(GetIterator2(errors2, "SYNC"));
  CreateDataPropertyOrThrow2(error2, "errors", errorsList);
  return error2;
}
if (hasPropertyDescriptors2) {
  Object.defineProperty(AggregateError$1, "prototype", { writable: false });
}
var proto = AggregateError$1.prototype;
CreateNonEnumerableDataPropertyOrThrow2(proto, "constructor", AggregateError$1);
CreateNonEnumerableDataPropertyOrThrow2(proto, "message", "");
CreateNonEnumerableDataPropertyOrThrow2(proto, "name", "AggregateError");
OrdinarySetPrototypeOf2(AggregateError$1.prototype, Error.prototype);
var implementation$5 = AggregateError$1;
var implementation$4 = implementation$5;
var polyfill$3 = function getPolyfill() {
  return typeof AggregateError === "function" ? AggregateError : implementation$4;
};
var implementation$3 = commonjsGlobal;
var implementation$2 = implementation$3;
var polyfill$2 = function getPolyfill2() {
  if (typeof commonjsGlobal !== "object" || !commonjsGlobal || commonjsGlobal.Math !== Math || commonjsGlobal.Array !== Array) {
    return implementation$2;
  }
  return commonjsGlobal;
};
var define$2 = defineProperties_1;
var gOPD = gopd$1;
var getPolyfill$3 = polyfill$2;
var shim$3 = function shimGlobal() {
  var polyfill2 = getPolyfill$3();
  if (define$2.supportsDescriptors) {
    var descriptor = gOPD(polyfill2, "globalThis");
    if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill2)) {
      Object.defineProperty(polyfill2, "globalThis", {
        configurable: true,
        enumerable: false,
        value: polyfill2,
        writable: true
      });
    }
  } else if (typeof globalThis !== "object" || globalThis !== polyfill2) {
    polyfill2.globalThis = polyfill2;
  }
  return polyfill2;
};
var defineProperties = defineProperties_1;
var implementation$1 = implementation$3;
var getPolyfill$2 = polyfill$2;
var shim$2 = shim$3;
var polyfill$1 = getPolyfill$2();
var getGlobal = function() {
  return polyfill$1;
};
defineProperties(getGlobal, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$1,
  shim: shim$2
});
var globalthis = getGlobal;
var define$1 = defineProperties_1;
var globalThis$1 = globalthis();
var getPolyfill$1 = polyfill$3;
var shim$1 = function shimAggregateError() {
  var polyfill2 = getPolyfill$1();
  define$1(
    globalThis$1,
    { AggregateError: polyfill2 },
    {
      AggregateError: function testAggregateError() {
        return globalThis$1.AggregateError !== polyfill2;
      }
    }
  );
  return polyfill2;
};
var bind2 = functionBind;
var define = defineProperties_1;
var setFunctionName2 = setFunctionName$1;
var defineDataProperty2 = defineDataProperty$2;
var implementation = implementation$5;
var getPolyfill3 = polyfill$3;
var shim = shim$1;
var polyfill = getPolyfill3();
var bound = setFunctionName2(bind2.call(polyfill), polyfill.name, true);
defineDataProperty2(bound, "prototype", polyfill.prototype, true, true, true, true);
define(bound, {
  getPolyfill: getPolyfill3,
  implementation,
  shim
});
var esAggregateError = bound;
Object.defineProperty(connector, "__esModule", {
  value: true
});
connector.connectInParallel = connectInParallel;
connector.connectInSequence = connectInSequence;
connector.lookupAllAddresses = lookupAllAddresses;
var _net = _interopRequireDefault$1(require$$0$6);
var punycode = _interopRequireWildcard(require$$2$2);
var _abortError = _interopRequireDefault$1(abortError);
var _esAggregateError$1 = _interopRequireDefault$1(esAggregateError);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj2, nodeInterop) {
  if (obj2 && obj2.__esModule) {
    return obj2;
  }
  if (obj2 === null || typeof obj2 !== "object" && typeof obj2 !== "function") {
    return { default: obj2 };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj2)) {
    return cache.get(obj2);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key2 in obj2) {
    if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj2, key2)) {
      var desc2 = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj2, key2) : null;
      if (desc2 && (desc2.get || desc2.set)) {
        Object.defineProperty(newObj, key2, desc2);
      } else {
        newObj[key2] = obj2[key2];
      }
    }
  }
  newObj.default = obj2;
  if (cache) {
    cache.set(obj2, newObj);
  }
  return newObj;
}
function _interopRequireDefault$1(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
async function connectInParallel(options, lookup, signal) {
  if (signal.aborted) {
    throw new _abortError.default();
  }
  const addresses = await lookupAllAddresses(options.host, lookup, signal);
  return await new Promise((resolve, reject) => {
    const sockets = new Array(addresses.length);
    const errors2 = [];
    function onError(err) {
      errors2.push(err);
      this.removeListener("error", onError);
      this.removeListener("connect", onConnect);
      this.destroy();
      if (errors2.length === addresses.length) {
        signal.removeEventListener("abort", onAbort);
        reject(new _esAggregateError$1.default(errors2, "Could not connect (parallel)"));
      }
    }
    function onConnect() {
      signal.removeEventListener("abort", onAbort);
      for (let j = 0; j < sockets.length; j++) {
        const socket = sockets[j];
        if (this === socket) {
          continue;
        }
        socket.removeListener("error", onError);
        socket.removeListener("connect", onConnect);
        socket.destroy();
      }
      resolve(this);
    }
    const onAbort = () => {
      for (let j = 0; j < sockets.length; j++) {
        const socket = sockets[j];
        socket.removeListener("error", onError);
        socket.removeListener("connect", onConnect);
        socket.destroy();
      }
      reject(new _abortError.default());
    };
    for (let i = 0, len = addresses.length; i < len; i++) {
      const socket = sockets[i] = _net.default.connect({
        ...options,
        host: addresses[i].address,
        family: addresses[i].family
      });
      socket.on("error", onError);
      socket.on("connect", onConnect);
    }
    signal.addEventListener("abort", onAbort, {
      once: true
    });
  });
}
async function connectInSequence(options, lookup, signal) {
  if (signal.aborted) {
    throw new _abortError.default();
  }
  const errors2 = [];
  const addresses = await lookupAllAddresses(options.host, lookup, signal);
  for (const address of addresses) {
    try {
      return await new Promise((resolve, reject) => {
        const socket = _net.default.connect({
          ...options,
          host: address.address,
          family: address.family
        });
        const onAbort = () => {
          socket.removeListener("error", onError);
          socket.removeListener("connect", onConnect);
          socket.destroy();
          reject(new _abortError.default());
        };
        const onError = (err) => {
          signal.removeEventListener("abort", onAbort);
          socket.removeListener("error", onError);
          socket.removeListener("connect", onConnect);
          socket.destroy();
          reject(err);
        };
        const onConnect = () => {
          signal.removeEventListener("abort", onAbort);
          socket.removeListener("error", onError);
          socket.removeListener("connect", onConnect);
          resolve(socket);
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        socket.on("error", onError);
        socket.on("connect", onConnect);
      });
    } catch (err) {
      if (err instanceof Error && err.name === "AbortError") {
        throw err;
      }
      errors2.push(err);
      continue;
    }
  }
  throw new _esAggregateError$1.default(errors2, "Could not connect (sequence)");
}
async function lookupAllAddresses(host, lookup, signal) {
  if (signal.aborted) {
    throw new _abortError.default();
  }
  if (_net.default.isIPv6(host)) {
    return [{
      address: host,
      family: 6
    }];
  } else if (_net.default.isIPv4(host)) {
    return [{
      address: host,
      family: 4
    }];
  } else {
    return await new Promise((resolve, reject) => {
      const onAbort = () => {
        reject(new _abortError.default());
      };
      signal.addEventListener("abort", onAbort);
      lookup(punycode.toASCII(host), {
        all: true
      }, (err, addresses) => {
        signal.removeEventListener("abort", onAbort);
        err ? reject(err) : resolve(addresses);
      });
    });
  }
}
var library = {};
Object.defineProperty(library, "__esModule", {
  value: true
});
library.name = void 0;
const name = "Tedious";
library.name = name;
var ntlm = {};
Object.defineProperty(ntlm, "__esModule", {
  value: true
});
ntlm.createNTLMRequest = createNTLMRequest;
const NTLMFlags = {
  NTLM_NegotiateUnicode: 1,
  NTLM_NegotiateOEM: 2,
  NTLM_RequestTarget: 4,
  NTLM_NegotiateNTLM: 512,
  NTLM_NegotiateOemDomainSupplied: 4096,
  NTLM_NegotiateOemWorkstationSupplied: 8192,
  NTLM_NegotiateAlwaysSign: 32768,
  NTLM_NegotiateExtendedSecurity: 524288,
  NTLM_NegotiateVersion: 33554432,
  NTLM_Negotiate128: 536870912,
  NTLM_Negotiate56: 2147483648
};
function createNTLMRequest(options) {
  const domain = escape(options.domain.toUpperCase());
  const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
  let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
  if (workstation === "") {
    type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
  }
  const fixedData = Buffer.alloc(40);
  const buffers = [fixedData];
  let offset = 0;
  offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
  offset = fixedData.writeUInt8(0, offset);
  offset = fixedData.writeUInt32LE(1, offset);
  offset = fixedData.writeUInt32LE(type1flags, offset);
  offset = fixedData.writeUInt16LE(domain.length, offset);
  offset = fixedData.writeUInt16LE(domain.length, offset);
  offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
  offset = fixedData.writeUInt16LE(workstation.length, offset);
  offset = fixedData.writeUInt16LE(workstation.length, offset);
  offset = fixedData.writeUInt32LE(fixedData.length, offset);
  offset = fixedData.writeUInt8(5, offset);
  offset = fixedData.writeUInt8(0, offset);
  offset = fixedData.writeUInt16LE(2195, offset);
  offset = fixedData.writeUInt8(0, offset);
  offset = fixedData.writeUInt8(0, offset);
  offset = fixedData.writeUInt8(0, offset);
  fixedData.writeUInt8(15, offset);
  buffers.push(Buffer.from(workstation, "ascii"));
  buffers.push(Buffer.from(domain, "ascii"));
  return Buffer.concat(buffers);
}
var bulkLoadPayload = {};
Object.defineProperty(bulkLoadPayload, "__esModule", {
  value: true
});
bulkLoadPayload.BulkLoadPayload = void 0;
let _Symbol$asyncIterator;
_Symbol$asyncIterator = Symbol.asyncIterator;
class BulkLoadPayload {
  constructor(bulkLoad2) {
    this.bulkLoad = void 0;
    this.iterator = void 0;
    this.bulkLoad = bulkLoad2;
    this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
  }
  [_Symbol$asyncIterator]() {
    return this.iterator;
  }
  toString(indent = "") {
    return indent + "BulkLoad";
  }
}
bulkLoadPayload.BulkLoadPayload = BulkLoadPayload;
const version = "15.1.3";
const require$$31 = {
  version
};
var handler = {};
Object.defineProperty(handler, "__esModule", {
  value: true
});
handler.UnexpectedTokenError = handler.TokenHandler = handler.RequestTokenHandler = handler.Login7TokenHandler = handler.InitialSqlTokenHandler = handler.AttentionTokenHandler = void 0;
var _request = _interopRequireDefault(requestExports);
var _errors = errors$1;
var _esAggregateError = _interopRequireDefault(esAggregateError);
function _interopRequireDefault(obj2) {
  return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
}
class UnexpectedTokenError extends Error {
  constructor(handler2, token2) {
    super("Unexpected token `" + token2.name + "` in `" + handler2.constructor.name + "`");
  }
}
handler.UnexpectedTokenError = UnexpectedTokenError;
class TokenHandler {
  onInfoMessage(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onErrorMessage(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onSSPI(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onDatabaseChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onLanguageChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onCharsetChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onSqlCollationChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onRoutingChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onPacketSizeChange(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onResetConnection(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onBeginTransaction(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onCommitTransaction(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onRollbackTransaction(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onFedAuthInfo(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onFeatureExtAck(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onLoginAck(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onColMetadata(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onOrder(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onRow(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onReturnStatus(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onReturnValue(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onDoneProc(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onDoneInProc(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onDone(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
  onDatabaseMirroringPartner(token2) {
    throw new UnexpectedTokenError(this, token2);
  }
}
handler.TokenHandler = TokenHandler;
class InitialSqlTokenHandler extends TokenHandler {
  constructor(connection2) {
    super();
    this.connection = void 0;
    this.connection = connection2;
  }
  onInfoMessage(token2) {
    this.connection.emit("infoMessage", token2);
  }
  onErrorMessage(token2) {
    this.connection.emit("errorMessage", token2);
  }
  onDatabaseChange(token2) {
    this.connection.emit("databaseChange", token2.newValue);
  }
  onLanguageChange(token2) {
    this.connection.emit("languageChange", token2.newValue);
  }
  onCharsetChange(token2) {
    this.connection.emit("charsetChange", token2.newValue);
  }
  onSqlCollationChange(token2) {
    this.connection.databaseCollation = token2.newValue;
  }
  onPacketSizeChange(token2) {
    this.connection.messageIo.packetSize(token2.newValue);
  }
  onBeginTransaction(token2) {
    this.connection.transactionDescriptors.push(token2.newValue);
    this.connection.inTransaction = true;
  }
  onCommitTransaction(token2) {
    this.connection.transactionDescriptors.length = 1;
    this.connection.inTransaction = false;
  }
  onRollbackTransaction(token2) {
    this.connection.transactionDescriptors.length = 1;
    this.connection.inTransaction = false;
    this.connection.emit("rollbackTransaction");
  }
  onColMetadata(token2) {
    this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
    this.connection.close();
  }
  onOrder(token2) {
    this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
    this.connection.close();
  }
  onRow(token2) {
    this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
    this.connection.close();
  }
  onReturnStatus(token2) {
  }
  onReturnValue(token2) {
  }
  onDoneProc(token2) {
  }
  onDoneInProc(token2) {
  }
  onDone(token2) {
  }
  onResetConnection(token2) {
    this.connection.emit("resetConnection");
  }
}
handler.InitialSqlTokenHandler = InitialSqlTokenHandler;
class Login7TokenHandler extends TokenHandler {
  constructor(connection2) {
    super();
    this.connection = void 0;
    this.fedAuthInfoToken = void 0;
    this.routingData = void 0;
    this.loginAckReceived = false;
    this.connection = connection2;
  }
  onInfoMessage(token2) {
    this.connection.emit("infoMessage", token2);
  }
  onErrorMessage(token2) {
    this.connection.emit("errorMessage", token2);
    const error2 = new _errors.ConnectionError(token2.message, "ELOGIN");
    const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token2.number);
    if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
      error2.isTransient = true;
    }
    this.connection.loginError = error2;
  }
  onSSPI(token2) {
    if (token2.ntlmpacket) {
      this.connection.ntlmpacket = token2.ntlmpacket;
      this.connection.ntlmpacketBuffer = token2.ntlmpacketBuffer;
    }
  }
  onDatabaseChange(token2) {
    this.connection.emit("databaseChange", token2.newValue);
  }
  onLanguageChange(token2) {
    this.connection.emit("languageChange", token2.newValue);
  }
  onCharsetChange(token2) {
    this.connection.emit("charsetChange", token2.newValue);
  }
  onSqlCollationChange(token2) {
    this.connection.databaseCollation = token2.newValue;
  }
  onFedAuthInfo(token2) {
    this.fedAuthInfoToken = token2;
  }
  onFeatureExtAck(token2) {
    const {
      authentication
    } = this.connection.config;
    if (authentication.type === "azure-active-directory-password" || authentication.type === "azure-active-directory-access-token" || authentication.type === "azure-active-directory-msi-vm" || authentication.type === "azure-active-directory-msi-app-service" || authentication.type === "azure-active-directory-service-principal-secret" || authentication.type === "azure-active-directory-default") {
      if (token2.fedAuth === void 0) {
        this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
      } else if (token2.fedAuth.length !== 0) {
        this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
      }
    } else if (token2.fedAuth === void 0 && token2.utf8Support === void 0) {
      this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
    } else if (token2.fedAuth) {
      this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
    }
  }
  onLoginAck(token2) {
    if (!token2.tdsVersion) {
      this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
      return;
    }
    if (!token2.interface) {
      this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
      return;
    }
    this.connection.config.options.tdsVersion = token2.tdsVersion;
    this.loginAckReceived = true;
  }
  onRoutingChange(token2) {
    const [server] = token2.newValue.server.split("\\");
    this.routingData = {
      server,
      port: token2.newValue.port
    };
  }
  onDoneInProc(token2) {
  }
  onDone(token2) {
  }
  onPacketSizeChange(token2) {
    this.connection.messageIo.packetSize(token2.newValue);
  }
  onDatabaseMirroringPartner(token2) {
  }
}
handler.Login7TokenHandler = Login7TokenHandler;
class RequestTokenHandler extends TokenHandler {
  constructor(connection2, request2) {
    super();
    this.connection = void 0;
    this.request = void 0;
    this.errors = void 0;
    this.connection = connection2;
    this.request = request2;
    this.errors = [];
  }
  onInfoMessage(token2) {
    this.connection.emit("infoMessage", token2);
  }
  onErrorMessage(token2) {
    this.connection.emit("errorMessage", token2);
    if (!this.request.canceled) {
      const error2 = new _errors.RequestError(token2.message, "EREQUEST");
      error2.number = token2.number;
      error2.state = token2.state;
      error2.class = token2.class;
      error2.serverName = token2.serverName;
      error2.procName = token2.procName;
      error2.lineNumber = token2.lineNumber;
      this.errors.push(error2);
      this.request.error = error2;
      if (this.request instanceof _request.default && this.errors.length > 1) {
        this.request.error = new _esAggregateError.default(this.errors);
      }
    }
  }
  onDatabaseChange(token2) {
    this.connection.emit("databaseChange", token2.newValue);
  }
  onLanguageChange(token2) {
    this.connection.emit("languageChange", token2.newValue);
  }
  onCharsetChange(token2) {
    this.connection.emit("charsetChange", token2.newValue);
  }
  onSqlCollationChange(token2) {
    this.connection.databaseCollation = token2.newValue;
  }
  onPacketSizeChange(token2) {
    this.connection.messageIo.packetSize(token2.newValue);
  }
  onBeginTransaction(token2) {
    this.connection.transactionDescriptors.push(token2.newValue);
    this.connection.inTransaction = true;
  }
  onCommitTransaction(token2) {
    this.connection.transactionDescriptors.length = 1;
    this.connection.inTransaction = false;
  }
  onRollbackTransaction(token2) {
    this.connection.transactionDescriptors.length = 1;
    this.connection.inTransaction = false;
    this.connection.emit("rollbackTransaction");
  }
  onColMetadata(token2) {
    if (!this.request.canceled) {
      if (this.connection.config.options.useColumnNames) {
        const columns = /* @__PURE__ */ Object.create(null);
        for (let j = 0, len = token2.columns.length; j < len; j++) {
          const col = token2.columns[j];
          if (columns[col.colName] == null) {
            columns[col.colName] = col;
          }
        }
        this.request.emit("columnMetadata", columns);
      } else {
        this.request.emit("columnMetadata", token2.columns);
      }
    }
  }
  onOrder(token2) {
    if (!this.request.canceled) {
      this.request.emit("order", token2.orderColumns);
    }
  }
  onRow(token2) {
    if (!this.request.canceled) {
      if (this.connection.config.options.rowCollectionOnRequestCompletion) {
        this.request.rows.push(token2.columns);
      }
      if (this.connection.config.options.rowCollectionOnDone) {
        this.request.rst.push(token2.columns);
      }
      this.request.emit("row", token2.columns);
    }
  }
  onReturnStatus(token2) {
    if (!this.request.canceled) {
      this.connection.procReturnStatusValue = token2.value;
    }
  }
  onReturnValue(token2) {
    if (!this.request.canceled) {
      this.request.emit("returnValue", token2.paramName, token2.value, token2.metadata);
    }
  }
  onDoneProc(token2) {
    if (!this.request.canceled) {
      if (token2.sqlError && !this.request.error) {
        this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
      }
      this.request.emit("doneProc", token2.rowCount, token2.more, this.connection.procReturnStatusValue, this.request.rst);
      this.connection.procReturnStatusValue = void 0;
      if (token2.rowCount !== void 0) {
        this.request.rowCount += token2.rowCount;
      }
      if (this.connection.config.options.rowCollectionOnDone) {
        this.request.rst = [];
      }
    }
  }
  onDoneInProc(token2) {
    if (!this.request.canceled) {
      this.request.emit("doneInProc", token2.rowCount, token2.more, this.request.rst);
      if (token2.rowCount !== void 0) {
        this.request.rowCount += token2.rowCount;
      }
      if (this.connection.config.options.rowCollectionOnDone) {
        this.request.rst = [];
      }
    }
  }
  onDone(token2) {
    if (!this.request.canceled) {
      if (token2.sqlError && !this.request.error) {
        this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
      }
      this.request.emit("done", token2.rowCount, token2.more, this.request.rst);
      if (token2.rowCount !== void 0) {
        this.request.rowCount += token2.rowCount;
      }
      if (this.connection.config.options.rowCollectionOnDone) {
        this.request.rst = [];
      }
    }
  }
  onResetConnection(token2) {
    this.connection.emit("resetConnection");
  }
}
handler.RequestTokenHandler = RequestTokenHandler;
class AttentionTokenHandler extends TokenHandler {
  /**
   * Returns whether an attention acknowledgement was received.
   */
  constructor(connection2, request2) {
    super();
    this.connection = void 0;
    this.request = void 0;
    this.attentionReceived = void 0;
    this.connection = connection2;
    this.request = request2;
    this.attentionReceived = false;
  }
  onDone(token2) {
    if (token2.attention) {
      this.attentionReceived = true;
    }
  }
}
handler.AttentionTokenHandler = AttentionTokenHandler;
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  exports$1.default = void 0;
  var _crypto = _interopRequireDefault2(crypto$2);
  var _os = _interopRequireDefault2(require$$0$2);
  var _dns2 = _interopRequireDefault2(require$$0$8);
  var _constants = _interopRequireDefault2(require$$3$1);
  var _stream2 = require$$0$4;
  var _identity = require$$5$1;
  var _bulkLoad = _interopRequireDefault2(bulkLoadExports);
  var _debug = _interopRequireDefault2(debugExports);
  var _events2 = require$$0$3;
  var _instanceLookup = instanceLookup$1;
  var _transientErrorLookup = transientErrorLookup;
  var _packet = packet;
  var _preloginPayload = _interopRequireDefault2(preloginPayloadExports);
  var _login7Payload = _interopRequireDefault2(login7PayloadExports);
  var _ntlmPayload = _interopRequireDefault2(ntlmPayloadExports);
  var _request2 = _interopRequireDefault2(requestExports);
  var _rpcrequestPayload = _interopRequireDefault2(rpcrequestPayloadExports);
  var _sqlbatchPayload = _interopRequireDefault2(sqlbatchPayloadExports);
  var _messageIo = _interopRequireDefault2(messageIoExports);
  var _tokenStreamParser = tokenStreamParser;
  var _transaction = transaction$1;
  var _errors2 = errors$1;
  var _connector = connector;
  var _library = library;
  var _tdsVersions = tdsVersions;
  var _message = _interopRequireDefault2(messageExports);
  var _ntlm = ntlm;
  var _nodeAbortController2 = nodeAbortController;
  var _dataType = dataType;
  var _bulkLoadPayload = bulkLoadPayload;
  var _esAggregateError2 = _interopRequireDefault2(esAggregateError);
  var _package = require$$31;
  var _url = require$$5$2;
  var _handler = handler;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
  const DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
  const DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
  const DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
  const DEFAULT_CONNECT_RETRY_INTERVAL = 500;
  const DEFAULT_PACKET_SIZE = 4 * 1024;
  const DEFAULT_TEXTSIZE = 2147483647;
  const DEFAULT_DATEFIRST = 7;
  const DEFAULT_PORT = 1433;
  const DEFAULT_TDS_VERSION = "7_4";
  const DEFAULT_LANGUAGE = "us_english";
  const DEFAULT_DATEFORMAT = "mdy";
  const CLEANUP_TYPE = {
    NORMAL: 0,
    REDIRECT: 1,
    RETRY: 2
  };
  class Connection extends _events2.EventEmitter {
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * @private
     */
    /**
     * Note: be aware of the different options field:
     * 1. config.authentication.options
     * 2. config.options
     *
     * ```js
     * const { Connection } = require('tedious');
     *
     * const config = {
     *  "authentication": {
     *    ...,
     *    "options": {...}
     *  },
     *  "options": {...}
     * };
     *
     * const connection = new Connection(config);
     * ```
     *
     * @param config
     */
    constructor(config) {
      super();
      this.fedAuthRequired = void 0;
      this.config = void 0;
      this.secureContextOptions = void 0;
      this.inTransaction = void 0;
      this.transactionDescriptors = void 0;
      this.transactionDepth = void 0;
      this.isSqlBatch = void 0;
      this.curTransientRetryCount = void 0;
      this.transientErrorLookup = void 0;
      this.closed = void 0;
      this.loginError = void 0;
      this.debug = void 0;
      this.ntlmpacket = void 0;
      this.ntlmpacketBuffer = void 0;
      this.routingData = void 0;
      this.messageIo = void 0;
      this.state = void 0;
      this.resetConnectionOnNextRequest = void 0;
      this.request = void 0;
      this.procReturnStatusValue = void 0;
      this.socket = void 0;
      this.messageBuffer = void 0;
      this.connectTimer = void 0;
      this.cancelTimer = void 0;
      this.requestTimer = void 0;
      this.retryTimer = void 0;
      this._cancelAfterRequestSent = void 0;
      this.databaseCollation = void 0;
      if (typeof config !== "object" || config === null) {
        throw new TypeError('The "config" argument is required and must be of type Object.');
      }
      if (typeof config.server !== "string") {
        throw new TypeError('The "config.server" property is required and must be of type string.');
      }
      this.fedAuthRequired = false;
      let authentication;
      if (config.authentication !== void 0) {
        if (typeof config.authentication !== "object" || config.authentication === null) {
          throw new TypeError('The "config.authentication" property must be of type Object.');
        }
        const type2 = config.authentication.type;
        const options = config.authentication.options === void 0 ? {} : config.authentication.options;
        if (typeof type2 !== "string") {
          throw new TypeError('The "config.authentication.type" property must be of type string.');
        }
        if (type2 !== "default" && type2 !== "ntlm" && type2 !== "azure-active-directory-password" && type2 !== "azure-active-directory-access-token" && type2 !== "azure-active-directory-msi-vm" && type2 !== "azure-active-directory-msi-app-service" && type2 !== "azure-active-directory-service-principal-secret" && type2 !== "azure-active-directory-default") {
          throw new TypeError('The "type" property must one of "default", "ntlm", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError('The "config.authentication.options" property must be of type object.');
        }
        if (type2 === "ntlm") {
          if (typeof options.domain !== "string") {
            throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
          }
          if (options.userName !== void 0 && typeof options.userName !== "string") {
            throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
          }
          if (options.password !== void 0 && typeof options.password !== "string") {
            throw new TypeError('The "config.authentication.options.password" property must be of type string.');
          }
          authentication = {
            type: "ntlm",
            options: {
              userName: options.userName,
              password: options.password,
              domain: options.domain && options.domain.toUpperCase()
            }
          };
        } else if (type2 === "azure-active-directory-password") {
          if (typeof options.clientId !== "string") {
            throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
          }
          if (options.userName !== void 0 && typeof options.userName !== "string") {
            throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
          }
          if (options.password !== void 0 && typeof options.password !== "string") {
            throw new TypeError('The "config.authentication.options.password" property must be of type string.');
          }
          if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
            throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-password",
            options: {
              userName: options.userName,
              password: options.password,
              tenantId: options.tenantId,
              clientId: options.clientId
            }
          };
        } else if (type2 === "azure-active-directory-access-token") {
          if (typeof options.token !== "string") {
            throw new TypeError('The "config.authentication.options.token" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-access-token",
            options: {
              token: options.token
            }
          };
        } else if (type2 === "azure-active-directory-msi-vm") {
          if (options.clientId !== void 0 && typeof options.clientId !== "string") {
            throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-msi-vm",
            options: {
              clientId: options.clientId
            }
          };
        } else if (type2 === "azure-active-directory-default") {
          if (options.clientId !== void 0 && typeof options.clientId !== "string") {
            throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-default",
            options: {
              clientId: options.clientId
            }
          };
        } else if (type2 === "azure-active-directory-msi-app-service") {
          if (options.clientId !== void 0 && typeof options.clientId !== "string") {
            throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-msi-app-service",
            options: {
              clientId: options.clientId
            }
          };
        } else if (type2 === "azure-active-directory-service-principal-secret") {
          if (typeof options.clientId !== "string") {
            throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
          }
          if (typeof options.clientSecret !== "string") {
            throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
          }
          if (typeof options.tenantId !== "string") {
            throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
          }
          authentication = {
            type: "azure-active-directory-service-principal-secret",
            options: {
              clientId: options.clientId,
              clientSecret: options.clientSecret,
              tenantId: options.tenantId
            }
          };
        } else {
          if (options.userName !== void 0 && typeof options.userName !== "string") {
            throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
          }
          if (options.password !== void 0 && typeof options.password !== "string") {
            throw new TypeError('The "config.authentication.options.password" property must be of type string.');
          }
          authentication = {
            type: "default",
            options: {
              userName: options.userName,
              password: options.password
            }
          };
        }
      } else {
        authentication = {
          type: "default",
          options: {
            userName: void 0,
            password: void 0
          }
        };
      }
      this.config = {
        server: config.server,
        authentication,
        options: {
          abortTransactionOnError: false,
          appName: void 0,
          camelCaseColumns: false,
          cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
          columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
          // Units: miliseconds
          columnEncryptionSetting: false,
          columnNameReplacer: void 0,
          connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
          connectTimeout: DEFAULT_CONNECT_TIMEOUT,
          connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
          cryptoCredentialsDetails: {},
          database: void 0,
          datefirst: DEFAULT_DATEFIRST,
          dateFormat: DEFAULT_DATEFORMAT,
          debug: {
            data: false,
            packet: false,
            payload: false,
            token: false
          },
          enableAnsiNull: true,
          enableAnsiNullDefault: true,
          enableAnsiPadding: true,
          enableAnsiWarnings: true,
          enableArithAbort: true,
          enableConcatNullYieldsNull: true,
          enableCursorCloseOnCommit: null,
          enableImplicitTransactions: false,
          enableNumericRoundabort: false,
          enableQuotedIdentifier: true,
          encrypt: true,
          fallbackToDefaultDb: false,
          encryptionKeyStoreProviders: void 0,
          instanceName: void 0,
          isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
          language: DEFAULT_LANGUAGE,
          localAddress: void 0,
          maxRetriesOnTransientErrors: 3,
          multiSubnetFailover: false,
          packetSize: DEFAULT_PACKET_SIZE,
          port: DEFAULT_PORT,
          readOnlyIntent: false,
          requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
          rowCollectionOnDone: false,
          rowCollectionOnRequestCompletion: false,
          serverName: void 0,
          serverSupportsColumnEncryption: false,
          tdsVersion: DEFAULT_TDS_VERSION,
          textsize: DEFAULT_TEXTSIZE,
          trustedServerNameAE: void 0,
          trustServerCertificate: false,
          useColumnNames: false,
          useUTC: true,
          workstationId: void 0,
          lowerCaseGuids: false
        }
      };
      if (config.options) {
        if (config.options.port && config.options.instanceName) {
          throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
        }
        if (config.options.abortTransactionOnError !== void 0) {
          if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
            throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
          }
          this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
        }
        if (config.options.appName !== void 0) {
          if (typeof config.options.appName !== "string") {
            throw new TypeError('The "config.options.appName" property must be of type string.');
          }
          this.config.options.appName = config.options.appName;
        }
        if (config.options.camelCaseColumns !== void 0) {
          if (typeof config.options.camelCaseColumns !== "boolean") {
            throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
          }
          this.config.options.camelCaseColumns = config.options.camelCaseColumns;
        }
        if (config.options.cancelTimeout !== void 0) {
          if (typeof config.options.cancelTimeout !== "number") {
            throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
          }
          this.config.options.cancelTimeout = config.options.cancelTimeout;
        }
        if (config.options.columnNameReplacer) {
          if (typeof config.options.columnNameReplacer !== "function") {
            throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
          }
          this.config.options.columnNameReplacer = config.options.columnNameReplacer;
        }
        if (config.options.connectionIsolationLevel !== void 0) {
          (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
          this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
        }
        if (config.options.connectTimeout !== void 0) {
          if (typeof config.options.connectTimeout !== "number") {
            throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
          }
          this.config.options.connectTimeout = config.options.connectTimeout;
        }
        if (config.options.cryptoCredentialsDetails !== void 0) {
          if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
            throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
          }
          this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
        }
        if (config.options.database !== void 0) {
          if (typeof config.options.database !== "string") {
            throw new TypeError('The "config.options.database" property must be of type string.');
          }
          this.config.options.database = config.options.database;
        }
        if (config.options.datefirst !== void 0) {
          if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
            throw new TypeError('The "config.options.datefirst" property must be of type number.');
          }
          if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
            throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
          }
          this.config.options.datefirst = config.options.datefirst;
        }
        if (config.options.dateFormat !== void 0) {
          if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
            throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
          }
          this.config.options.dateFormat = config.options.dateFormat;
        }
        if (config.options.debug) {
          if (config.options.debug.data !== void 0) {
            if (typeof config.options.debug.data !== "boolean") {
              throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
            }
            this.config.options.debug.data = config.options.debug.data;
          }
          if (config.options.debug.packet !== void 0) {
            if (typeof config.options.debug.packet !== "boolean") {
              throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
            }
            this.config.options.debug.packet = config.options.debug.packet;
          }
          if (config.options.debug.payload !== void 0) {
            if (typeof config.options.debug.payload !== "boolean") {
              throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
            }
            this.config.options.debug.payload = config.options.debug.payload;
          }
          if (config.options.debug.token !== void 0) {
            if (typeof config.options.debug.token !== "boolean") {
              throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
            }
            this.config.options.debug.token = config.options.debug.token;
          }
        }
        if (config.options.enableAnsiNull !== void 0) {
          if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
            throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
          }
          this.config.options.enableAnsiNull = config.options.enableAnsiNull;
        }
        if (config.options.enableAnsiNullDefault !== void 0) {
          if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
            throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
          }
          this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
        }
        if (config.options.enableAnsiPadding !== void 0) {
          if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
            throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
          }
          this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
        }
        if (config.options.enableAnsiWarnings !== void 0) {
          if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
            throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
          }
          this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
        }
        if (config.options.enableArithAbort !== void 0) {
          if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
            throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
          }
          this.config.options.enableArithAbort = config.options.enableArithAbort;
        }
        if (config.options.enableConcatNullYieldsNull !== void 0) {
          if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
            throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
          }
          this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
        }
        if (config.options.enableCursorCloseOnCommit !== void 0) {
          if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
            throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
          }
          this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
        }
        if (config.options.enableImplicitTransactions !== void 0) {
          if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
            throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
          }
          this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
        }
        if (config.options.enableNumericRoundabort !== void 0) {
          if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
            throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
          }
          this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
        }
        if (config.options.enableQuotedIdentifier !== void 0) {
          if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
            throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
          }
          this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
        }
        if (config.options.encrypt !== void 0) {
          if (typeof config.options.encrypt !== "boolean") {
            throw new TypeError('The "config.options.encrypt" property must be of type boolean.');
          }
          this.config.options.encrypt = config.options.encrypt;
        }
        if (config.options.fallbackToDefaultDb !== void 0) {
          if (typeof config.options.fallbackToDefaultDb !== "boolean") {
            throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
          }
          this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
        }
        if (config.options.instanceName !== void 0) {
          if (typeof config.options.instanceName !== "string") {
            throw new TypeError('The "config.options.instanceName" property must be of type string.');
          }
          this.config.options.instanceName = config.options.instanceName;
          this.config.options.port = void 0;
        }
        if (config.options.isolationLevel !== void 0) {
          (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
          this.config.options.isolationLevel = config.options.isolationLevel;
        }
        if (config.options.language !== void 0) {
          if (typeof config.options.language !== "string" && config.options.language !== null) {
            throw new TypeError('The "config.options.language" property must be of type string or null.');
          }
          this.config.options.language = config.options.language;
        }
        if (config.options.localAddress !== void 0) {
          if (typeof config.options.localAddress !== "string") {
            throw new TypeError('The "config.options.localAddress" property must be of type string.');
          }
          this.config.options.localAddress = config.options.localAddress;
        }
        if (config.options.multiSubnetFailover !== void 0) {
          if (typeof config.options.multiSubnetFailover !== "boolean") {
            throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
          }
          this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
        }
        if (config.options.packetSize !== void 0) {
          if (typeof config.options.packetSize !== "number") {
            throw new TypeError('The "config.options.packetSize" property must be of type number.');
          }
          this.config.options.packetSize = config.options.packetSize;
        }
        if (config.options.port !== void 0) {
          if (typeof config.options.port !== "number") {
            throw new TypeError('The "config.options.port" property must be of type number.');
          }
          if (config.options.port <= 0 || config.options.port >= 65536) {
            throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
          }
          this.config.options.port = config.options.port;
          this.config.options.instanceName = void 0;
        }
        if (config.options.readOnlyIntent !== void 0) {
          if (typeof config.options.readOnlyIntent !== "boolean") {
            throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
          }
          this.config.options.readOnlyIntent = config.options.readOnlyIntent;
        }
        if (config.options.requestTimeout !== void 0) {
          if (typeof config.options.requestTimeout !== "number") {
            throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
          }
          this.config.options.requestTimeout = config.options.requestTimeout;
        }
        if (config.options.maxRetriesOnTransientErrors !== void 0) {
          if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
            throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
          }
          if (config.options.maxRetriesOnTransientErrors < 0) {
            throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
          }
          this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
        }
        if (config.options.connectionRetryInterval !== void 0) {
          if (typeof config.options.connectionRetryInterval !== "number") {
            throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
          }
          if (config.options.connectionRetryInterval <= 0) {
            throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
          }
          this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
        }
        if (config.options.rowCollectionOnDone !== void 0) {
          if (typeof config.options.rowCollectionOnDone !== "boolean") {
            throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
          }
          this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
        }
        if (config.options.rowCollectionOnRequestCompletion !== void 0) {
          if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
            throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
          }
          this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
        }
        if (config.options.tdsVersion !== void 0) {
          if (typeof config.options.tdsVersion !== "string") {
            throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
          }
          this.config.options.tdsVersion = config.options.tdsVersion;
        }
        if (config.options.textsize !== void 0) {
          if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
            throw new TypeError('The "config.options.textsize" property must be of type number or null.');
          }
          if (config.options.textsize > 2147483647) {
            throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
          } else if (config.options.textsize < -1) {
            throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
          }
          this.config.options.textsize = config.options.textsize | 0;
        }
        if (config.options.trustServerCertificate !== void 0) {
          if (typeof config.options.trustServerCertificate !== "boolean") {
            throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
          }
          this.config.options.trustServerCertificate = config.options.trustServerCertificate;
        }
        if (config.options.useColumnNames !== void 0) {
          if (typeof config.options.useColumnNames !== "boolean") {
            throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
          }
          this.config.options.useColumnNames = config.options.useColumnNames;
        }
        if (config.options.useUTC !== void 0) {
          if (typeof config.options.useUTC !== "boolean") {
            throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
          }
          this.config.options.useUTC = config.options.useUTC;
        }
        if (config.options.workstationId !== void 0) {
          if (typeof config.options.workstationId !== "string") {
            throw new TypeError('The "config.options.workstationId" property must be of type string.');
          }
          this.config.options.workstationId = config.options.workstationId;
        }
        if (config.options.lowerCaseGuids !== void 0) {
          if (typeof config.options.lowerCaseGuids !== "boolean") {
            throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
          }
          this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
        }
      }
      this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
      if (this.secureContextOptions.secureOptions === void 0) {
        this.secureContextOptions = Object.create(this.secureContextOptions, {
          secureOptions: {
            value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
          }
        });
      }
      this.debug = this.createDebug();
      this.inTransaction = false;
      this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
      this.transactionDepth = 0;
      this.isSqlBatch = false;
      this.closed = false;
      this.messageBuffer = Buffer.alloc(0);
      this.curTransientRetryCount = 0;
      this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
      this.state = this.STATE.INITIALIZED;
      this._cancelAfterRequestSent = () => {
        this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
        this.createCancelTimer();
      };
    }
    connect(connectListener) {
      if (this.state !== this.STATE.INITIALIZED) {
        throw new _errors2.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
      }
      if (connectListener) {
        const onConnect = (err) => {
          this.removeListener("error", onError);
          connectListener(err);
        };
        const onError = (err) => {
          this.removeListener("connect", onConnect);
          connectListener(err);
        };
        this.once("connect", onConnect);
        this.once("error", onError);
      }
      this.transitionTo(this.STATE.CONNECTING);
    }
    /**
     * The server has reported that the charset has changed.
     */
    on(event, listener) {
      return super.on(event, listener);
    }
    /**
     * @private
     */
    emit(event, ...args) {
      return super.emit(event, ...args);
    }
    /**
     * Closes the connection to the database.
     *
     * The [[Event_end]] will be emitted once the connection has been closed.
     */
    close() {
      this.transitionTo(this.STATE.FINAL);
    }
    /**
     * @private
     */
    initialiseConnection() {
      const signal = this.createConnectTimer();
      if (this.config.options.port) {
        return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal);
      } else {
        return (0, _instanceLookup.instanceLookup)({
          server: this.config.server,
          instanceName: this.config.options.instanceName,
          timeout: this.config.options.connectTimeout,
          signal
        }).then((port) => {
          process.nextTick(() => {
            this.connectOnPort(port, this.config.options.multiSubnetFailover, signal);
          });
        }, (err) => {
          this.clearConnectTimer();
          if (err.name === "AbortError") {
            return;
          }
          process.nextTick(() => {
            this.emit("connect", new _errors2.ConnectionError(err.message, "EINSTLOOKUP"));
          });
        });
      }
    }
    /**
     * @private
     */
    cleanupConnection(cleanupType) {
      if (!this.closed) {
        this.clearConnectTimer();
        this.clearRequestTimer();
        this.clearRetryTimer();
        this.closeConnection();
        if (cleanupType === CLEANUP_TYPE.REDIRECT) {
          this.emit("rerouting");
        } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
          process.nextTick(() => {
            this.emit("end");
          });
        }
        const request2 = this.request;
        if (request2) {
          const err = new _errors2.RequestError("Connection closed before request completed.", "ECLOSE");
          request2.callback(err);
          this.request = void 0;
        }
        this.closed = true;
        this.loginError = void 0;
      }
    }
    /**
     * @private
     */
    createDebug() {
      const debug2 = new _debug.default(this.config.options.debug);
      debug2.on("debug", (message2) => {
        this.emit("debug", message2);
      });
      return debug2;
    }
    /**
     * @private
     */
    createTokenStreamParser(message2, handler2) {
      return new _tokenStreamParser.Parser(message2, this.debug, handler2, this.config.options);
    }
    connectOnPort(port, multiSubnetFailover, signal) {
      const connectOpts = {
        host: this.routingData ? this.routingData.server : this.config.server,
        port: this.routingData ? this.routingData.port : port,
        localAddress: this.config.options.localAddress
      };
      const connect = multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence;
      connect(connectOpts, _dns2.default.lookup, signal).then((socket) => {
        process.nextTick(() => {
          socket.on("error", (error2) => {
            this.socketError(error2);
          });
          socket.on("close", () => {
            this.socketClose();
          });
          socket.on("end", () => {
            this.socketEnd();
          });
          socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
          this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
          this.messageIo.on("secure", (cleartext) => {
            this.emit("secure", cleartext);
          });
          this.socket = socket;
          this.closed = false;
          this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
          this.sendPreLogin();
          this.transitionTo(this.STATE.SENT_PRELOGIN);
        });
      }, (err) => {
        this.clearConnectTimer();
        if (err.name === "AbortError") {
          return;
        }
        process.nextTick(() => {
          this.socketError(err);
        });
      });
    }
    /**
     * @private
     */
    closeConnection() {
      if (this.socket) {
        this.socket.destroy();
      }
    }
    /**
     * @private
     */
    createConnectTimer() {
      const controller = new _nodeAbortController2.AbortController();
      this.connectTimer = setTimeout(() => {
        controller.abort();
        this.connectTimeout();
      }, this.config.options.connectTimeout);
      return controller.signal;
    }
    /**
     * @private
     */
    createCancelTimer() {
      this.clearCancelTimer();
      const timeout2 = this.config.options.cancelTimeout;
      if (timeout2 > 0) {
        this.cancelTimer = setTimeout(() => {
          this.cancelTimeout();
        }, timeout2);
      }
    }
    /**
     * @private
     */
    createRequestTimer() {
      this.clearRequestTimer();
      const request2 = this.request;
      const timeout2 = request2.timeout !== void 0 ? request2.timeout : this.config.options.requestTimeout;
      if (timeout2) {
        this.requestTimer = setTimeout(() => {
          this.requestTimeout();
        }, timeout2);
      }
    }
    /**
     * @private
     */
    createRetryTimer() {
      this.clearRetryTimer();
      this.retryTimer = setTimeout(() => {
        this.retryTimeout();
      }, this.config.options.connectionRetryInterval);
    }
    /**
     * @private
     */
    connectTimeout() {
      const message2 = `Failed to connect to ${this.config.server}${this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`} in ${this.config.options.connectTimeout}ms`;
      this.debug.log(message2);
      this.emit("connect", new _errors2.ConnectionError(message2, "ETIMEOUT"));
      this.connectTimer = void 0;
      this.dispatchEvent("connectTimeout");
    }
    /**
     * @private
     */
    cancelTimeout() {
      const message2 = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
      this.debug.log(message2);
      this.dispatchEvent("socketError", new _errors2.ConnectionError(message2, "ETIMEOUT"));
    }
    /**
     * @private
     */
    requestTimeout() {
      this.requestTimer = void 0;
      const request2 = this.request;
      request2.cancel();
      const timeout2 = request2.timeout !== void 0 ? request2.timeout : this.config.options.requestTimeout;
      const message2 = "Timeout: Request failed to complete in " + timeout2 + "ms";
      request2.error = new _errors2.RequestError(message2, "ETIMEOUT");
    }
    /**
     * @private
     */
    retryTimeout() {
      this.retryTimer = void 0;
      this.emit("retry");
      this.transitionTo(this.STATE.CONNECTING);
    }
    /**
     * @private
     */
    clearConnectTimer() {
      if (this.connectTimer) {
        clearTimeout(this.connectTimer);
        this.connectTimer = void 0;
      }
    }
    /**
     * @private
     */
    clearCancelTimer() {
      if (this.cancelTimer) {
        clearTimeout(this.cancelTimer);
        this.cancelTimer = void 0;
      }
    }
    /**
     * @private
     */
    clearRequestTimer() {
      if (this.requestTimer) {
        clearTimeout(this.requestTimer);
        this.requestTimer = void 0;
      }
    }
    /**
     * @private
     */
    clearRetryTimer() {
      if (this.retryTimer) {
        clearTimeout(this.retryTimer);
        this.retryTimer = void 0;
      }
    }
    /**
     * @private
     */
    transitionTo(newState) {
      if (this.state === newState) {
        this.debug.log("State is already " + newState.name);
        return;
      }
      if (this.state && this.state.exit) {
        this.state.exit.call(this, newState);
      }
      this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
      this.state = newState;
      if (this.state.enter) {
        this.state.enter.apply(this);
      }
    }
    /**
     * @private
     */
    getEventHandler(eventName) {
      const handler2 = this.state.events[eventName];
      if (!handler2) {
        throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
      }
      return handler2;
    }
    /**
     * @private
     */
    dispatchEvent(eventName, ...args) {
      const handler2 = this.state.events[eventName];
      if (handler2) {
        handler2.apply(this, args);
      } else {
        this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
        this.close();
      }
    }
    /**
     * @private
     */
    socketError(error2) {
      if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
        const message2 = `Failed to connect to ${this.config.server}:${this.config.options.port} - ${error2.message}`;
        this.debug.log(message2);
        this.emit("connect", new _errors2.ConnectionError(message2, "ESOCKET"));
      } else {
        const message2 = `Connection lost - ${error2.message}`;
        this.debug.log(message2);
        this.emit("error", new _errors2.ConnectionError(message2, "ESOCKET"));
      }
      this.dispatchEvent("socketError", error2);
    }
    /**
     * @private
     */
    socketEnd() {
      this.debug.log("socket ended");
      if (this.state !== this.STATE.FINAL) {
        const error2 = new Error("socket hang up");
        error2.code = "ECONNRESET";
        this.socketError(error2);
      }
    }
    /**
     * @private
     */
    socketClose() {
      this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
      if (this.state === this.STATE.REROUTING) {
        this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
        this.dispatchEvent("reconnect");
      } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? this.routingData.port : this.config.options.port;
        this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
        this.dispatchEvent("retry");
      } else {
        this.transitionTo(this.STATE.FINAL);
      }
    }
    /**
     * @private
     */
    sendPreLogin() {
      const [, major2, minor2, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
      const payload = new _preloginPayload.default({
        encrypt: this.config.options.encrypt,
        version: {
          major: Number(major2),
          minor: Number(minor2),
          build: Number(build),
          subbuild: 0
        }
      });
      this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
      this.debug.payload(function() {
        return payload.toString("  ");
      });
    }
    /**
     * @private
     */
    sendLogin7Packet() {
      const payload = new _login7Payload.default({
        tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
        packetSize: this.config.options.packetSize,
        clientProgVer: 0,
        clientPid: process.pid,
        connectionId: 0,
        clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
        clientLcid: 1033
      });
      const {
        authentication
      } = this.config;
      switch (authentication.type) {
        case "azure-active-directory-password":
          payload.fedAuth = {
            type: "ADAL",
            echo: this.fedAuthRequired,
            workflow: "default"
          };
          break;
        case "azure-active-directory-access-token":
          payload.fedAuth = {
            type: "SECURITYTOKEN",
            echo: this.fedAuthRequired,
            fedAuthToken: authentication.options.token
          };
          break;
        case "azure-active-directory-msi-vm":
        case "azure-active-directory-default":
        case "azure-active-directory-msi-app-service":
        case "azure-active-directory-service-principal-secret":
          payload.fedAuth = {
            type: "ADAL",
            echo: this.fedAuthRequired,
            workflow: "integrated"
          };
          break;
        case "ntlm":
          payload.sspi = (0, _ntlm.createNTLMRequest)({
            domain: authentication.options.domain
          });
          break;
        default:
          payload.userName = authentication.options.userName;
          payload.password = authentication.options.password;
      }
      payload.hostname = this.config.options.workstationId || _os.default.hostname();
      payload.serverName = this.routingData ? this.routingData.server : this.config.server;
      payload.appName = this.config.options.appName || "Tedious";
      payload.libraryName = _library.name;
      payload.language = this.config.options.language;
      payload.database = this.config.options.database;
      payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
      payload.readOnlyIntent = this.config.options.readOnlyIntent;
      payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
      this.routingData = void 0;
      this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
      this.debug.payload(function() {
        return payload.toString("  ");
      });
    }
    /**
     * @private
     */
    sendFedAuthTokenMessage(token2) {
      const accessTokenLen = Buffer.byteLength(token2, "ucs2");
      const data = Buffer.alloc(8 + accessTokenLen);
      let offset = 0;
      offset = data.writeUInt32LE(accessTokenLen + 4, offset);
      offset = data.writeUInt32LE(accessTokenLen, offset);
      data.write(token2, offset, "ucs2");
      this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
      this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
    }
    /**
     * @private
     */
    sendInitialSql() {
      const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
      const message2 = new _message.default({
        type: _packet.TYPE.SQL_BATCH
      });
      this.messageIo.outgoingMessageStream.write(message2);
      _stream2.Readable.from(payload).pipe(message2);
    }
    /**
     * @private
     */
    getInitialSql() {
      const options = [];
      if (this.config.options.enableAnsiNull === true) {
        options.push("set ansi_nulls on");
      } else if (this.config.options.enableAnsiNull === false) {
        options.push("set ansi_nulls off");
      }
      if (this.config.options.enableAnsiNullDefault === true) {
        options.push("set ansi_null_dflt_on on");
      } else if (this.config.options.enableAnsiNullDefault === false) {
        options.push("set ansi_null_dflt_on off");
      }
      if (this.config.options.enableAnsiPadding === true) {
        options.push("set ansi_padding on");
      } else if (this.config.options.enableAnsiPadding === false) {
        options.push("set ansi_padding off");
      }
      if (this.config.options.enableAnsiWarnings === true) {
        options.push("set ansi_warnings on");
      } else if (this.config.options.enableAnsiWarnings === false) {
        options.push("set ansi_warnings off");
      }
      if (this.config.options.enableArithAbort === true) {
        options.push("set arithabort on");
      } else if (this.config.options.enableArithAbort === false) {
        options.push("set arithabort off");
      }
      if (this.config.options.enableConcatNullYieldsNull === true) {
        options.push("set concat_null_yields_null on");
      } else if (this.config.options.enableConcatNullYieldsNull === false) {
        options.push("set concat_null_yields_null off");
      }
      if (this.config.options.enableCursorCloseOnCommit === true) {
        options.push("set cursor_close_on_commit on");
      } else if (this.config.options.enableCursorCloseOnCommit === false) {
        options.push("set cursor_close_on_commit off");
      }
      if (this.config.options.datefirst !== null) {
        options.push(`set datefirst ${this.config.options.datefirst}`);
      }
      if (this.config.options.dateFormat !== null) {
        options.push(`set dateformat ${this.config.options.dateFormat}`);
      }
      if (this.config.options.enableImplicitTransactions === true) {
        options.push("set implicit_transactions on");
      } else if (this.config.options.enableImplicitTransactions === false) {
        options.push("set implicit_transactions off");
      }
      if (this.config.options.language !== null) {
        options.push(`set language ${this.config.options.language}`);
      }
      if (this.config.options.enableNumericRoundabort === true) {
        options.push("set numeric_roundabort on");
      } else if (this.config.options.enableNumericRoundabort === false) {
        options.push("set numeric_roundabort off");
      }
      if (this.config.options.enableQuotedIdentifier === true) {
        options.push("set quoted_identifier on");
      } else if (this.config.options.enableQuotedIdentifier === false) {
        options.push("set quoted_identifier off");
      }
      if (this.config.options.textsize !== null) {
        options.push(`set textsize ${this.config.options.textsize}`);
      }
      if (this.config.options.connectionIsolationLevel !== null) {
        options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
      }
      if (this.config.options.abortTransactionOnError === true) {
        options.push("set xact_abort on");
      } else if (this.config.options.abortTransactionOnError === false) {
        options.push("set xact_abort off");
      }
      return options.join("\n");
    }
    /**
     * @private
     */
    processedInitialSql() {
      this.clearConnectTimer();
      this.emit("connect");
    }
    /**
     * Execute the SQL batch represented by [[Request]].
     * There is no param support, and unlike [[Request.execSql]],
     * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
     *
     * In almost all cases, [[Request.execSql]] will be a better choice.
     *
     * @param request A [[Request]] object representing the request.
     */
    execSqlBatch(request2) {
      this.makeRequest(request2, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request2.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
    }
    /**
     *  Execute the SQL represented by [[Request]].
     *
     * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
     * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
     * for the first execution. This may also result in SQL server treating the request like a stored procedure
     * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
     * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
     *
     * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
     * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
     * See also [issue #24](https://github.com/pekim/tedious/issues/24)
     *
     * @param request A [[Request]] object representing the request.
     */
    execSql(request2) {
      try {
        request2.validateParameters(this.databaseCollation);
      } catch (error2) {
        request2.error = error2;
        process.nextTick(() => {
          this.debug.log(error2.message);
          request2.callback(error2);
        });
        return;
      }
      const parameters = [];
      parameters.push({
        type: _dataType.TYPES.NVarChar,
        name: "statement",
        value: request2.sqlTextOrProcedure,
        output: false,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      if (request2.parameters.length) {
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request2.makeParamsParameter(request2.parameters),
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push(...request2.parameters);
      }
      this.makeRequest(request2, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default("sp_executesql", parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
    }
    /**
     * Creates a new BulkLoad instance.
     *
     * @param table The name of the table to bulk-insert into.
     * @param options A set of bulk load options.
     */
    newBulkLoad(table2, callbackOrOptions, callback) {
      let options;
      if (callback === void 0) {
        callback = callbackOrOptions;
        options = {};
      } else {
        options = callbackOrOptions;
      }
      if (typeof options !== "object") {
        throw new TypeError('"options" argument must be an object');
      }
      return new _bulkLoad.default(table2, this.databaseCollation, this.config.options, options, callback);
    }
    /**
     * Execute a [[BulkLoad]].
     *
     * ```js
     * // We want to perform a bulk load into a table with the following format:
     * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
     *
     * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
     *   // ...
     * });
     *
     * // First, we need to specify the columns that we want to write to,
     * // and their definitions. These definitions must match the actual table,
     * // otherwise the bulk load will fail.
     * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
     * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
     * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
     *
     * // Execute a bulk load with a predefined list of rows.
     * //
     * // Note that these rows are held in memory until the
     * // bulk load was performed, so if you need to write a large
     * // number of rows (e.g. by reading from a CSV file),
     * // passing an `AsyncIterable` is advisable to keep memory usage low.
     * connection.execBulkLoad(bulkLoad, [
     *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
     *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
     * ]);
     * ```
     *
     * @param bulkLoad A previously created [[BulkLoad]].
     * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
     */
    execBulkLoad(bulkLoad2, rows) {
      bulkLoad2.executionStarted = true;
      if (rows) {
        if (bulkLoad2.streamingMode) {
          throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
        }
        if (bulkLoad2.firstRowWritten) {
          throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
        }
        const rowStream = _stream2.Readable.from(rows);
        rowStream.on("error", (err) => {
          bulkLoad2.rowToPacketTransform.destroy(err);
        });
        bulkLoad2.rowToPacketTransform.on("error", (err) => {
          rowStream.destroy(err);
        });
        rowStream.pipe(bulkLoad2.rowToPacketTransform);
      } else if (!bulkLoad2.streamingMode) {
        bulkLoad2.rowToPacketTransform.end();
      }
      const onCancel = () => {
        request2.cancel();
      };
      const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad2);
      const request2 = new _request2.default(bulkLoad2.getBulkInsertSql(), (error2) => {
        bulkLoad2.removeListener("cancel", onCancel);
        if (error2) {
          if (error2.code === "UNKNOWN") {
            error2.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
          }
          bulkLoad2.error = error2;
          bulkLoad2.callback(error2);
          return;
        }
        this.makeRequest(bulkLoad2, _packet.TYPE.BULK_LOAD, payload);
      });
      bulkLoad2.once("cancel", onCancel);
      this.execSqlBatch(request2);
    }
    /**
     * Prepare the SQL represented by the request.
     *
     * The request can then be used in subsequent calls to
     * [[execute]] and [[unprepare]]
     *
     * @param request A [[Request]] object representing the request.
     *   Parameters only require a name and type. Parameter values are ignored.
     */
    prepare(request2) {
      const parameters = [];
      parameters.push({
        type: _dataType.TYPES.Int,
        name: "handle",
        value: void 0,
        output: true,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      parameters.push({
        type: _dataType.TYPES.NVarChar,
        name: "params",
        value: request2.parameters.length ? request2.makeParamsParameter(request2.parameters) : null,
        output: false,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      parameters.push({
        type: _dataType.TYPES.NVarChar,
        name: "stmt",
        value: request2.sqlTextOrProcedure,
        output: false,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      request2.preparing = true;
      request2.on("returnValue", (name2, value) => {
        if (name2 === "handle") {
          request2.handle = value;
        } else {
          request2.error = new _errors2.RequestError(`Tedious > Unexpected output parameter ${name2} from sp_prepare`);
        }
      });
      this.makeRequest(request2, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default("sp_prepare", parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
    }
    /**
     * Release the SQL Server resources associated with a previously prepared request.
     *
     * @param request A [[Request]] object representing the request.
     *   Parameters only require a name and type.
     *   Parameter values are ignored.
     */
    unprepare(request2) {
      const parameters = [];
      parameters.push({
        type: _dataType.TYPES.Int,
        name: "handle",
        // TODO: Abort if `request.handle` is not set
        value: request2.handle,
        output: false,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      this.makeRequest(request2, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default("sp_unprepare", parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
    }
    /**
     * Execute previously prepared SQL, using the supplied parameters.
     *
     * @param request A previously prepared [[Request]].
     * @param parameters  An object whose names correspond to the names of
     *   parameters that were added to the [[Request]] before it was prepared.
     *   The object's values are passed as the parameters' values when the
     *   request is executed.
     */
    execute(request2, parameters) {
      const executeParameters = [];
      executeParameters.push({
        type: _dataType.TYPES.Int,
        name: "handle",
        // TODO: Abort if `request.handle` is not set
        value: request2.handle,
        output: false,
        length: void 0,
        precision: void 0,
        scale: void 0
      });
      try {
        for (let i = 0, len = request2.parameters.length; i < len; i++) {
          const parameter = request2.parameters[i];
          executeParameters.push({
            ...parameter,
            value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
          });
        }
      } catch (error2) {
        request2.error = error2;
        process.nextTick(() => {
          this.debug.log(error2.message);
          request2.callback(error2);
        });
        return;
      }
      this.makeRequest(request2, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default("sp_execute", executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
    }
    /**
     * Call a stored procedure represented by [[Request]].
     *
     * @param request A [[Request]] object representing the request.
     */
    callProcedure(request2) {
      try {
        request2.validateParameters(this.databaseCollation);
      } catch (error2) {
        request2.error = error2;
        process.nextTick(() => {
          this.debug.log(error2.message);
          request2.callback(error2);
        });
        return;
      }
      this.makeRequest(request2, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request2.sqlTextOrProcedure, request2.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
    }
    /**
     * Start a transaction.
     *
     * @param callback
     * @param name A string representing a name to associate with the transaction.
     *   Optional, and defaults to an empty string. Required when `isolationLevel`
     *   is present.
     * @param isolationLevel The isolation level that the transaction is to be run with.
     *
     *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
     *   * `READ_UNCOMMITTED`
     *   * `READ_COMMITTED`
     *   * `REPEATABLE_READ`
     *   * `SERIALIZABLE`
     *   * `SNAPSHOT`
     *
     *   Optional, and defaults to the Connection's isolation level.
     */
    beginTransaction(callback, name2 = "", isolationLevel = this.config.options.isolationLevel) {
      (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
      const transaction2 = new _transaction.Transaction(name2, isolationLevel);
      if (this.config.options.tdsVersion < "7_2") {
        return this.execSqlBatch(new _request2.default("SET TRANSACTION ISOLATION LEVEL " + transaction2.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction2.name, (err) => {
          this.transactionDepth++;
          if (this.transactionDepth === 1) {
            this.inTransaction = true;
          }
          callback(err);
        }));
      }
      const request2 = new _request2.default(void 0, (err) => {
        return callback(err, this.currentTransactionDescriptor());
      });
      return this.makeRequest(request2, _packet.TYPE.TRANSACTION_MANAGER, transaction2.beginPayload(this.currentTransactionDescriptor()));
    }
    /**
     * Commit a transaction.
     *
     * There should be an active transaction - that is, [[beginTransaction]]
     * should have been previously called.
     *
     * @param callback
     * @param name A string representing a name to associate with the transaction.
     *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
     */
    commitTransaction(callback, name2 = "") {
      const transaction2 = new _transaction.Transaction(name2);
      if (this.config.options.tdsVersion < "7_2") {
        return this.execSqlBatch(new _request2.default("COMMIT TRAN " + transaction2.name, (err) => {
          this.transactionDepth--;
          if (this.transactionDepth === 0) {
            this.inTransaction = false;
          }
          callback(err);
        }));
      }
      const request2 = new _request2.default(void 0, callback);
      return this.makeRequest(request2, _packet.TYPE.TRANSACTION_MANAGER, transaction2.commitPayload(this.currentTransactionDescriptor()));
    }
    /**
     * Rollback a transaction.
     *
     * There should be an active transaction - that is, [[beginTransaction]]
     * should have been previously called.
     *
     * @param callback
     * @param name A string representing a name to associate with the transaction.
     *   Optional, and defaults to an empty string.
     *   Required when `isolationLevel` is present.
     */
    rollbackTransaction(callback, name2 = "") {
      const transaction2 = new _transaction.Transaction(name2);
      if (this.config.options.tdsVersion < "7_2") {
        return this.execSqlBatch(new _request2.default("ROLLBACK TRAN " + transaction2.name, (err) => {
          this.transactionDepth--;
          if (this.transactionDepth === 0) {
            this.inTransaction = false;
          }
          callback(err);
        }));
      }
      const request2 = new _request2.default(void 0, callback);
      return this.makeRequest(request2, _packet.TYPE.TRANSACTION_MANAGER, transaction2.rollbackPayload(this.currentTransactionDescriptor()));
    }
    /**
     * Set a savepoint within a transaction.
     *
     * There should be an active transaction - that is, [[beginTransaction]]
     * should have been previously called.
     *
     * @param callback
     * @param name A string representing a name to associate with the transaction.\
     *   Optional, and defaults to an empty string.
     *   Required when `isolationLevel` is present.
     */
    saveTransaction(callback, name2) {
      const transaction2 = new _transaction.Transaction(name2);
      if (this.config.options.tdsVersion < "7_2") {
        return this.execSqlBatch(new _request2.default("SAVE TRAN " + transaction2.name, (err) => {
          this.transactionDepth++;
          callback(err);
        }));
      }
      const request2 = new _request2.default(void 0, callback);
      return this.makeRequest(request2, _packet.TYPE.TRANSACTION_MANAGER, transaction2.savePayload(this.currentTransactionDescriptor()));
    }
    /**
     * Run the given callback after starting a transaction, and commit or
     * rollback the transaction afterwards.
     *
     * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
     * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
     * use of database transactions and automatically handle transaction nesting.
     *
     * @param cb
     * @param isolationLevel
     *   The isolation level that the transaction is to be run with.
     *
     *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
     *   * `READ_UNCOMMITTED`
     *   * `READ_COMMITTED`
     *   * `REPEATABLE_READ`
     *   * `SERIALIZABLE`
     *   * `SNAPSHOT`
     *
     *   Optional, and defaults to the Connection's isolation level.
     */
    transaction(cb, isolationLevel) {
      if (typeof cb !== "function") {
        throw new TypeError("`cb` must be a function");
      }
      const useSavepoint = this.inTransaction;
      const name2 = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
      const txDone = (err, done, ...args) => {
        if (err) {
          if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
            this.rollbackTransaction((txErr) => {
              done(txErr || err, ...args);
            }, name2);
          } else {
            done(err, ...args);
          }
        } else if (useSavepoint) {
          if (this.config.options.tdsVersion < "7_2") {
            this.transactionDepth--;
          }
          done(null, ...args);
        } else {
          this.commitTransaction((txErr) => {
            done(txErr, ...args);
          }, name2);
        }
      };
      if (useSavepoint) {
        return this.saveTransaction((err) => {
          if (err) {
            return cb(err);
          }
          if (isolationLevel) {
            return this.execSqlBatch(new _request2.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
              return cb(err2, txDone);
            }));
          } else {
            return cb(null, txDone);
          }
        }, name2);
      } else {
        return this.beginTransaction((err) => {
          if (err) {
            return cb(err);
          }
          return cb(null, txDone);
        }, name2, isolationLevel);
      }
    }
    /**
     * @private
     */
    makeRequest(request2, packetType, payload) {
      if (this.state !== this.STATE.LOGGED_IN) {
        const message2 = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
        this.debug.log(message2);
        request2.callback(new _errors2.RequestError(message2, "EINVALIDSTATE"));
      } else if (request2.canceled) {
        process.nextTick(() => {
          request2.callback(new _errors2.RequestError("Canceled.", "ECANCEL"));
        });
      } else {
        if (packetType === _packet.TYPE.SQL_BATCH) {
          this.isSqlBatch = true;
        } else {
          this.isSqlBatch = false;
        }
        this.request = request2;
        request2.connection = this;
        request2.rowCount = 0;
        request2.rows = [];
        request2.rst = [];
        const onCancel = () => {
          payloadStream.unpipe(message2);
          payloadStream.destroy(new _errors2.RequestError("Canceled.", "ECANCEL"));
          message2.ignore = true;
          message2.end();
          if (request2 instanceof _request2.default && request2.paused) {
            request2.resume();
          }
        };
        request2.once("cancel", onCancel);
        this.createRequestTimer();
        const message2 = new _message.default({
          type: packetType,
          resetConnection: this.resetConnectionOnNextRequest
        });
        this.messageIo.outgoingMessageStream.write(message2);
        this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
        message2.once("finish", () => {
          request2.removeListener("cancel", onCancel);
          request2.once("cancel", this._cancelAfterRequestSent);
          this.resetConnectionOnNextRequest = false;
          this.debug.payload(function() {
            return payload.toString("  ");
          });
        });
        const payloadStream = _stream2.Readable.from(payload);
        payloadStream.once("error", (error2) => {
          payloadStream.unpipe(message2);
          request2.error ?? (request2.error = error2);
          message2.ignore = true;
          message2.end();
        });
        payloadStream.pipe(message2);
      }
    }
    /**
     * Cancel currently executed request.
     */
    cancel() {
      if (!this.request) {
        return false;
      }
      if (this.request.canceled) {
        return false;
      }
      this.request.cancel();
      return true;
    }
    /**
     * Reset the connection to its initial state.
     * Can be useful for connection pool implementations.
     *
     * @param callback
     */
    reset(callback) {
      const request2 = new _request2.default(this.getInitialSql(), (err) => {
        if (this.config.options.tdsVersion < "7_2") {
          this.inTransaction = false;
        }
        callback(err);
      });
      this.resetConnectionOnNextRequest = true;
      this.execSqlBatch(request2);
    }
    /**
     * @private
     */
    currentTransactionDescriptor() {
      return this.transactionDescriptors[this.transactionDescriptors.length - 1];
    }
    /**
     * @private
     */
    getIsolationLevelText(isolationLevel) {
      switch (isolationLevel) {
        case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
          return "read uncommitted";
        case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
          return "repeatable read";
        case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
          return "serializable";
        case _transaction.ISOLATION_LEVEL.SNAPSHOT:
          return "snapshot";
        default:
          return "read committed";
      }
    }
  }
  function isTransientError(error2) {
    if (error2 instanceof _esAggregateError2.default) {
      error2 = error2.errors[0];
    }
    return error2 instanceof _errors2.ConnectionError && !!error2.isTransient;
  }
  var _default2 = Connection;
  exports$1.default = _default2;
  module2.exports = Connection;
  Connection.prototype.STATE = {
    INITIALIZED: {
      name: "Initialized",
      events: {}
    },
    CONNECTING: {
      name: "Connecting",
      enter: function() {
        this.initialiseConnection();
      },
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_PRELOGIN: {
      name: "SentPrelogin",
      enter: function() {
        (async () => {
          let messageBuffer = Buffer.alloc(0);
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          for await (const data of message2) {
            messageBuffer = Buffer.concat([messageBuffer, data]);
          }
          const preloginPayload2 = new _preloginPayload.default(messageBuffer);
          this.debug.payload(function() {
            return preloginPayload2.toString("  ");
          });
          if (preloginPayload2.fedAuthRequired === 1) {
            this.fedAuthRequired = true;
          }
          if (preloginPayload2.encryptionString === "ON" || preloginPayload2.encryptionString === "REQ") {
            if (!this.config.options.encrypt) {
              this.emit("connect", new _errors2.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
              return this.close();
            }
            try {
              var _this$routingData;
              this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
              await this.messageIo.startTls(this.secureContextOptions, ((_this$routingData = this.routingData) === null || _this$routingData === void 0 ? void 0 : _this$routingData.server) ?? this.config.server, this.config.options.trustServerCertificate);
            } catch (err) {
              return this.socketError(err);
            }
          }
          this.sendLogin7Packet();
          const {
            authentication
          } = this.config;
          switch (authentication.type) {
            case "azure-active-directory-password":
            case "azure-active-directory-msi-vm":
            case "azure-active-directory-msi-app-service":
            case "azure-active-directory-service-principal-secret":
            case "azure-active-directory-default":
              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
              break;
            case "ntlm":
              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
              break;
            default:
              this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
              break;
          }
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    REROUTING: {
      name: "ReRouting",
      enter: function() {
        this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
      },
      events: {
        message: function() {
        },
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        reconnect: function() {
          this.transitionTo(this.STATE.CONNECTING);
        }
      }
    },
    TRANSIENT_FAILURE_RETRY: {
      name: "TRANSIENT_FAILURE_RETRY",
      enter: function() {
        this.curTransientRetryCount++;
        this.cleanupConnection(CLEANUP_TYPE.RETRY);
      },
      events: {
        message: function() {
        },
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        retry: function() {
          this.createRetryTimer();
        }
      }
    },
    SENT_TLSSSLNEGOTIATION: {
      name: "SentTLSSSLNegotiation",
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_LOGIN7_WITH_STANDARD_LOGIN: {
      name: "SentLogin7WithStandardLogin",
      enter: function() {
        (async () => {
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          const handler2 = new _handler.Login7TokenHandler(this);
          const tokenStreamParser2 = this.createTokenStreamParser(message2, handler2);
          await (0, _events2.once)(tokenStreamParser2, "end");
          if (handler2.loginAckReceived) {
            if (handler2.routingData) {
              this.routingData = handler2.routingData;
              this.transitionTo(this.STATE.REROUTING);
            } else {
              this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
            }
          } else if (this.loginError) {
            if (isTransientError(this.loginError)) {
              this.debug.log("Initiating retry on transient error");
              this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
            } else {
              this.emit("connect", this.loginError);
              this.transitionTo(this.STATE.FINAL);
            }
          } else {
            this.emit("connect", new _errors2.ConnectionError("Login failed.", "ELOGIN"));
            this.transitionTo(this.STATE.FINAL);
          }
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_LOGIN7_WITH_NTLM: {
      name: "SentLogin7WithNTLMLogin",
      enter: function() {
        (async () => {
          while (true) {
            let message2;
            try {
              message2 = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler2 = new _handler.Login7TokenHandler(this);
            const tokenStreamParser2 = this.createTokenStreamParser(message2, handler2);
            await (0, _events2.once)(tokenStreamParser2, "end");
            if (handler2.loginAckReceived) {
              if (handler2.routingData) {
                this.routingData = handler2.routingData;
                return this.transitionTo(this.STATE.REROUTING);
              } else {
                return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.ntlmpacket) {
              const authentication = this.config.authentication;
              const payload = new _ntlmPayload.default({
                domain: authentication.options.domain,
                userName: authentication.options.userName,
                password: authentication.options.password,
                ntlmpacket: this.ntlmpacket
              });
              this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
              this.debug.payload(function() {
                return payload.toString("  ");
              });
              this.ntlmpacket = void 0;
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                return this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors2.ConnectionError("Login failed.", "ELOGIN"));
              return this.transitionTo(this.STATE.FINAL);
            }
          }
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_LOGIN7_WITH_FEDAUTH: {
      name: "SentLogin7Withfedauth",
      enter: function() {
        (async () => {
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          const handler2 = new _handler.Login7TokenHandler(this);
          const tokenStreamParser2 = this.createTokenStreamParser(message2, handler2);
          await (0, _events2.once)(tokenStreamParser2, "end");
          if (handler2.loginAckReceived) {
            if (handler2.routingData) {
              this.routingData = handler2.routingData;
              this.transitionTo(this.STATE.REROUTING);
            } else {
              this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
            }
            return;
          }
          const fedAuthInfoToken = handler2.fedAuthInfoToken;
          if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
            const authentication = this.config.authentication;
            const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
            let credentials;
            switch (authentication.type) {
              case "azure-active-directory-password":
                credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? "common", authentication.options.clientId, authentication.options.userName, authentication.options.password);
                break;
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
                const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
                credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                break;
              case "azure-active-directory-default":
                const args = authentication.options.clientId ? {
                  managedIdentityClientId: authentication.options.clientId
                } : {};
                credentials = new _identity.DefaultAzureCredential(args);
                break;
              case "azure-active-directory-service-principal-secret":
                credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
                break;
            }
            let tokenResponse;
            try {
              tokenResponse = await credentials.getToken(tokenScope);
            } catch (err) {
              this.loginError = new _esAggregateError2.default([new _errors2.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
              this.emit("connect", this.loginError);
              this.transitionTo(this.STATE.FINAL);
              return;
            }
            const token2 = tokenResponse.token;
            this.sendFedAuthTokenMessage(token2);
          } else if (this.loginError) {
            if (isTransientError(this.loginError)) {
              this.debug.log("Initiating retry on transient error");
              this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
            } else {
              this.emit("connect", this.loginError);
              this.transitionTo(this.STATE.FINAL);
            }
          } else {
            this.emit("connect", new _errors2.ConnectionError("Login failed.", "ELOGIN"));
            this.transitionTo(this.STATE.FINAL);
          }
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    LOGGED_IN_SENDING_INITIAL_SQL: {
      name: "LoggedInSendingInitialSql",
      enter: function() {
        (async () => {
          this.sendInitialSql();
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          const tokenStreamParser2 = this.createTokenStreamParser(message2, new _handler.InitialSqlTokenHandler(this));
          await (0, _events2.once)(tokenStreamParser2, "end");
          this.transitionTo(this.STATE.LOGGED_IN);
          this.processedInitialSql();
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function socketError() {
          this.transitionTo(this.STATE.FINAL);
        },
        connectTimeout: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    LOGGED_IN: {
      name: "LoggedIn",
      events: {
        socketError: function() {
          this.transitionTo(this.STATE.FINAL);
        }
      }
    },
    SENT_CLIENT_REQUEST: {
      name: "SentClientRequest",
      enter: function() {
        (async () => {
          var _this$request, _this$request3, _this$request10;
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          this.clearRequestTimer();
          const tokenStreamParser2 = this.createTokenStreamParser(message2, new _handler.RequestTokenHandler(this, this.request));
          if ((_this$request = this.request) !== null && _this$request !== void 0 && _this$request.canceled && this.cancelTimer) {
            return this.transitionTo(this.STATE.SENT_ATTENTION);
          }
          const onResume = () => {
            tokenStreamParser2.resume();
          };
          const onPause = () => {
            var _this$request2;
            tokenStreamParser2.pause();
            (_this$request2 = this.request) === null || _this$request2 === void 0 ? void 0 : _this$request2.once("resume", onResume);
          };
          (_this$request3 = this.request) === null || _this$request3 === void 0 ? void 0 : _this$request3.on("pause", onPause);
          if (this.request instanceof _request2.default && this.request.paused) {
            onPause();
          }
          const onCancel = () => {
            var _this$request4, _this$request5;
            tokenStreamParser2.removeListener("end", onEndOfMessage);
            if (this.request instanceof _request2.default && this.request.paused) {
              this.request.resume();
            }
            (_this$request4 = this.request) === null || _this$request4 === void 0 ? void 0 : _this$request4.removeListener("pause", onPause);
            (_this$request5 = this.request) === null || _this$request5 === void 0 ? void 0 : _this$request5.removeListener("resume", onResume);
            this.transitionTo(this.STATE.SENT_ATTENTION);
          };
          const onEndOfMessage = () => {
            var _this$request6, _this$request7, _this$request8, _this$request9;
            (_this$request6 = this.request) === null || _this$request6 === void 0 ? void 0 : _this$request6.removeListener("cancel", this._cancelAfterRequestSent);
            (_this$request7 = this.request) === null || _this$request7 === void 0 ? void 0 : _this$request7.removeListener("cancel", onCancel);
            (_this$request8 = this.request) === null || _this$request8 === void 0 ? void 0 : _this$request8.removeListener("pause", onPause);
            (_this$request9 = this.request) === null || _this$request9 === void 0 ? void 0 : _this$request9.removeListener("resume", onResume);
            this.transitionTo(this.STATE.LOGGED_IN);
            const sqlRequest = this.request;
            this.request = void 0;
            if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
              this.inTransaction = false;
            }
            sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
          };
          tokenStreamParser2.once("end", onEndOfMessage);
          (_this$request10 = this.request) === null || _this$request10 === void 0 ? void 0 : _this$request10.once("cancel", onCancel);
        })();
      },
      exit: function(nextState) {
        this.clearRequestTimer();
      },
      events: {
        socketError: function(err) {
          const sqlRequest = this.request;
          this.request = void 0;
          this.transitionTo(this.STATE.FINAL);
          sqlRequest.callback(err);
        }
      }
    },
    SENT_ATTENTION: {
      name: "SentAttention",
      enter: function() {
        (async () => {
          let message2;
          try {
            message2 = await this.messageIo.readMessage();
          } catch (err) {
            return this.socketError(err);
          }
          const handler2 = new _handler.AttentionTokenHandler(this, this.request);
          const tokenStreamParser2 = this.createTokenStreamParser(message2, handler2);
          await (0, _events2.once)(tokenStreamParser2, "end");
          if (handler2.attentionReceived) {
            this.clearCancelTimer();
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.LOGGED_IN);
            if (sqlRequest.error && sqlRequest.error instanceof _errors2.RequestError && sqlRequest.error.code === "ETIMEOUT") {
              sqlRequest.callback(sqlRequest.error);
            } else {
              sqlRequest.callback(new _errors2.RequestError("Canceled.", "ECANCEL"));
            }
          }
        })().catch((err) => {
          process.nextTick(() => {
            throw err;
          });
        });
      },
      events: {
        socketError: function(err) {
          const sqlRequest = this.request;
          this.request = void 0;
          this.transitionTo(this.STATE.FINAL);
          sqlRequest.callback(err);
        }
      }
    },
    FINAL: {
      name: "Final",
      enter: function() {
        this.cleanupConnection(CLEANUP_TYPE.NORMAL);
      },
      events: {
        connectTimeout: function() {
        },
        message: function() {
        },
        socketError: function() {
        }
      }
    }
  };
})(connection, connection.exports);
var connectionExports = connection.exports;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", {
    value: true
  });
  Object.defineProperty(exports$1, "BulkLoad", {
    enumerable: true,
    get: function() {
      return _bulkLoad.default;
    }
  });
  Object.defineProperty(exports$1, "Connection", {
    enumerable: true,
    get: function() {
      return _connection.default;
    }
  });
  Object.defineProperty(exports$1, "ConnectionError", {
    enumerable: true,
    get: function() {
      return _errors2.ConnectionError;
    }
  });
  Object.defineProperty(exports$1, "ISOLATION_LEVEL", {
    enumerable: true,
    get: function() {
      return _transaction.ISOLATION_LEVEL;
    }
  });
  Object.defineProperty(exports$1, "Request", {
    enumerable: true,
    get: function() {
      return _request2.default;
    }
  });
  Object.defineProperty(exports$1, "RequestError", {
    enumerable: true,
    get: function() {
      return _errors2.RequestError;
    }
  });
  Object.defineProperty(exports$1, "TDS_VERSION", {
    enumerable: true,
    get: function() {
      return _tdsVersions.versions;
    }
  });
  Object.defineProperty(exports$1, "TYPES", {
    enumerable: true,
    get: function() {
      return _dataType.TYPES;
    }
  });
  exports$1.connect = connect;
  exports$1.library = void 0;
  var _bulkLoad = _interopRequireDefault2(bulkLoadExports);
  var _connection = _interopRequireDefault2(connectionExports);
  var _request2 = _interopRequireDefault2(requestExports);
  var _library = library;
  var _errors2 = errors$1;
  var _dataType = dataType;
  var _transaction = transaction$1;
  var _tdsVersions = tdsVersions;
  function _interopRequireDefault2(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  const library$1 = {
    name: _library.name
  };
  exports$1.library = library$1;
  function connect(config, connectListener) {
    const connection2 = new _connection.default(config);
    connection2.connect(connectListener);
    return connection2;
  }
})(tedious);
const tds$1 = tedious;
const debug$2 = srcExports("mssql:tedi");
const BaseConnectionPool = connectionPool$1;
const { IDS: IDS$2 } = utils;
const shared = sharedExports;
const ConnectionError3 = connectionError;
class ConnectionPool2 extends BaseConnectionPool {
  _config() {
    const cfg = {
      server: this.config.server,
      options: Object.assign({
        encrypt: typeof this.config.encrypt === "boolean" ? this.config.encrypt : true,
        trustServerCertificate: typeof this.config.trustServerCertificate === "boolean" ? this.config.trustServerCertificate : false
      }, this.config.options),
      authentication: Object.assign({
        type: this.config.domain !== void 0 ? "ntlm" : this.config.authentication_type !== void 0 ? this.config.authentication_type : "default",
        options: Object.entries({
          userName: this.config.user,
          password: this.config.password,
          domain: this.config.domain,
          clientId: this.config.clientId,
          clientSecret: this.config.clientSecret,
          tenantId: this.config.tenantId,
          token: this.config.token,
          msiEndpoint: this.config.msiEndpoint,
          msiSecret: this.config.msiSecret
        }).reduce((acc, [key2, val]) => {
          if (typeof val !== "undefined") {
            return { ...acc, [key2]: val };
          }
          return acc;
        }, {})
      }, this.config.authentication)
    };
    cfg.options.database = cfg.options.database || this.config.database;
    cfg.options.port = cfg.options.port || this.config.port;
    cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15e3;
    cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15e3;
    cfg.options.tdsVersion = cfg.options.tdsVersion || "7_4";
    cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
    cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
    cfg.options.useColumnNames = cfg.options.useColumnNames || false;
    cfg.options.appName = cfg.options.appName || "node-mssql";
    if (cfg.options.instanceName) delete cfg.options.port;
    if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15e3;
    if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;
    if (!cfg.options.debug && this.config.debug) {
      cfg.options.debug = {
        packet: true,
        token: true,
        data: true,
        payload: true
      };
    }
    return cfg;
  }
  _poolCreate() {
    return new shared.Promise((resolve, reject) => {
      const resolveOnce = (v) => {
        resolve(v);
        resolve = reject = () => {
        };
      };
      const rejectOnce = (e) => {
        reject(e);
        resolve = reject = () => {
        };
      };
      let tedious2;
      try {
        tedious2 = new tds$1.Connection(this._config());
      } catch (err) {
        rejectOnce(err);
        return;
      }
      tedious2.connect((err) => {
        if (err) {
          err = new ConnectionError3(err);
          return rejectOnce(err);
        }
        debug$2("connection(%d): established", IDS$2.get(tedious2));
        this.collation = tedious2.databaseCollation;
        resolveOnce(tedious2);
      });
      IDS$2.add(tedious2, "Connection");
      debug$2("pool(%d): connection #%d created", IDS$2.get(this), IDS$2.get(tedious2));
      debug$2("connection(%d): establishing", IDS$2.get(tedious2));
      tedious2.on("end", () => {
        const err = new ConnectionError3("The connection ended without ever completing the connection");
        rejectOnce(err);
      });
      tedious2.on("error", (err) => {
        if (err.code === "ESOCKET") {
          tedious2.hasError = true;
        } else {
          this.emit("error", err);
        }
        rejectOnce(err);
      });
      if (this.config.debug) {
        tedious2.on("debug", this.emit.bind(this, "debug", tedious2));
      }
      if (typeof this.config.beforeConnect === "function") {
        this.config.beforeConnect(tedious2);
      }
    });
  }
  _poolValidate(tedious2) {
    if (tedious2 && !tedious2.closed && !tedious2.hasError) {
      return !this.config.validateConnection || new shared.Promise((resolve) => {
        const req2 = new tds$1.Request("SELECT 1;", (err) => {
          resolve(!err);
        });
        tedious2.execSql(req2);
      });
    }
    return false;
  }
  _poolDestroy(tedious2) {
    return new shared.Promise((resolve, reject) => {
      if (!tedious2) {
        resolve();
        return;
      }
      debug$2("connection(%d): destroying", IDS$2.get(tedious2));
      if (tedious2.closed) {
        debug$2("connection(%d): already closed", IDS$2.get(tedious2));
        resolve();
      } else {
        tedious2.once("end", () => {
          debug$2("connection(%d): destroyed", IDS$2.get(tedious2));
          resolve();
        });
        tedious2.close();
      }
    });
  }
}
var connectionPool = ConnectionPool2;
const debug$1 = srcExports("mssql:tedi");
const BaseTransaction = transaction$2;
const { IDS: IDS$1 } = utils;
const TransactionError2 = transactionError;
class Transaction3 extends BaseTransaction {
  constructor(parent) {
    super(parent);
    this._abort = () => {
      if (!this._rollbackRequested) {
        const pc = this._acquiredConnection;
        setImmediate(this.parent.release.bind(this.parent), pc);
        this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
        this._acquiredConnection = null;
        this._acquiredConfig = null;
        this._aborted = true;
        this.emit("rollback", true);
      }
    };
  }
  _begin(isolationLevel, callback) {
    super._begin(isolationLevel, (err) => {
      if (err) return callback(err);
      debug$1("transaction(%d): begin", IDS$1.get(this));
      this.parent.acquire(this, (err2, connection2, config) => {
        if (err2) return callback(err2);
        this._acquiredConnection = connection2;
        this._acquiredConnection.on("rollbackTransaction", this._abort);
        this._acquiredConfig = config;
        connection2.beginTransaction((err3) => {
          if (err3) err3 = new TransactionError2(err3);
          debug$1("transaction(%d): begun", IDS$1.get(this));
          callback(err3);
        }, this.name, this.isolationLevel);
      });
    });
  }
  _commit(callback) {
    super._commit((err) => {
      if (err) return callback(err);
      debug$1("transaction(%d): commit", IDS$1.get(this));
      this._acquiredConnection.commitTransaction((err2) => {
        if (err2) err2 = new TransactionError2(err2);
        this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
        this.parent.release(this._acquiredConnection);
        this._acquiredConnection = null;
        this._acquiredConfig = null;
        if (!err2) debug$1("transaction(%d): commited", IDS$1.get(this));
        callback(err2);
      });
    });
  }
  _rollback(callback) {
    super._rollback((err) => {
      if (err) return callback(err);
      debug$1("transaction(%d): rollback", IDS$1.get(this));
      this._acquiredConnection.rollbackTransaction((err2) => {
        if (err2) err2 = new TransactionError2(err2);
        this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
        this.parent.release(this._acquiredConnection);
        this._acquiredConnection = null;
        this._acquiredConfig = null;
        if (!err2) debug$1("transaction(%d): rolled back", IDS$1.get(this));
        callback(err2);
      });
    });
  }
}
var transaction = Transaction3;
var udt = {};
class Point {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.z = null;
    this.m = null;
  }
}
const parsePoints = (buffer2, count, isGeometryPoint) => {
  const points = [];
  if (count < 1) {
    return points;
  }
  if (isGeometryPoint) {
    for (let i = 1; i <= count; i++) {
      const point = new Point();
      points.push(point);
      point.x = buffer2.readDoubleLE(buffer2.position);
      point.y = buffer2.readDoubleLE(buffer2.position + 8);
      buffer2.position += 16;
    }
  } else {
    for (let i = 1; i <= count; i++) {
      const point = new Point();
      points.push(point);
      point.lat = buffer2.readDoubleLE(buffer2.position);
      point.lng = buffer2.readDoubleLE(buffer2.position + 8);
      point.x = point.lat;
      point.y = point.lng;
      buffer2.position += 16;
    }
  }
  return points;
};
const parseZ = (buffer2, points) => {
  if (points < 1) {
    return;
  }
  points.forEach((point) => {
    point.z = buffer2.readDoubleLE(buffer2.position);
    buffer2.position += 8;
  });
};
const parseM = (buffer2, points) => {
  if (points < 1) {
    return;
  }
  points.forEach((point) => {
    point.m = buffer2.readDoubleLE(buffer2.position);
    buffer2.position += 8;
  });
};
const parseFigures = (buffer2, count, properties) => {
  const figures = [];
  if (count < 1) {
    return figures;
  }
  if (properties.P) {
    figures.push({
      attribute: 1,
      pointOffset: 0
    });
  } else if (properties.L) {
    figures.push({
      attribute: 1,
      pointOffset: 0
    });
  } else {
    for (let i = 1; i <= count; i++) {
      figures.push({
        attribute: buffer2.readUInt8(buffer2.position),
        pointOffset: buffer2.readInt32LE(buffer2.position + 1)
      });
      buffer2.position += 5;
    }
  }
  return figures;
};
const parseShapes = (buffer2, count, properties) => {
  const shapes = [];
  if (count < 1) {
    return shapes;
  }
  if (properties.P) {
    shapes.push({
      parentOffset: -1,
      figureOffset: 0,
      type: 1
    });
  } else if (properties.L) {
    shapes.push({
      parentOffset: -1,
      figureOffset: 0,
      type: 2
    });
  } else {
    for (let i = 1; i <= count; i++) {
      shapes.push({
        parentOffset: buffer2.readInt32LE(buffer2.position),
        figureOffset: buffer2.readInt32LE(buffer2.position + 4),
        type: buffer2.readUInt8(buffer2.position + 8)
      });
      buffer2.position += 9;
    }
  }
  return shapes;
};
const parseSegments = (buffer2, count) => {
  const segments = [];
  if (count < 1) {
    return segments;
  }
  for (let i = 1; i <= count; i++) {
    segments.push({ type: buffer2.readUInt8(buffer2.position) });
    buffer2.position++;
  }
  return segments;
};
const parseGeography = (buffer2, isUsingGeometryPoints) => {
  const srid = buffer2.readInt32LE(0);
  if (srid === -1) {
    return null;
  }
  const value = {
    srid,
    version: buffer2.readUInt8(4)
  };
  const flags = buffer2.readUInt8(5);
  buffer2.position = 6;
  const properties = {
    Z: (flags & 1 << 0) > 0,
    M: (flags & 1 << 1) > 0,
    P: (flags & 1 << 3) > 0,
    L: (flags & 1 << 4) > 0
  };
  if (value.version === 2) {
    properties.H = (flags & 1 << 3) > 0;
  }
  let numberOfPoints;
  if (properties.P) {
    numberOfPoints = 1;
  } else if (properties.L) {
    numberOfPoints = 2;
  } else {
    numberOfPoints = buffer2.readUInt32LE(buffer2.position);
    buffer2.position += 4;
  }
  value.points = parsePoints(buffer2, numberOfPoints, isUsingGeometryPoints);
  if (properties.Z) {
    parseZ(buffer2, value.points);
  }
  if (properties.M) {
    parseM(buffer2, value.points);
  }
  let numberOfFigures;
  if (properties.P) {
    numberOfFigures = 1;
  } else if (properties.L) {
    numberOfFigures = 1;
  } else {
    numberOfFigures = buffer2.readUInt32LE(buffer2.position);
    buffer2.position += 4;
  }
  value.figures = parseFigures(buffer2, numberOfFigures, properties);
  let numberOfShapes;
  if (properties.P) {
    numberOfShapes = 1;
  } else if (properties.L) {
    numberOfShapes = 1;
  } else {
    numberOfShapes = buffer2.readUInt32LE(buffer2.position);
    buffer2.position += 4;
  }
  value.shapes = parseShapes(buffer2, numberOfShapes, properties);
  if (value.version === 2 && buffer2.position < buffer2.length) {
    const numberOfSegments = buffer2.readUInt32LE(buffer2.position);
    buffer2.position += 4;
    value.segments = parseSegments(buffer2, numberOfSegments);
  } else {
    value.segments = [];
  }
  return value;
};
udt.PARSERS = {
  geography(buffer2) {
    return parseGeography(
      buffer2,
      /* isUsingGeometryPoints: */
      false
    );
  },
  geometry(buffer2) {
    return parseGeography(
      buffer2,
      /* isUsingGeometryPoints: */
      true
    );
  }
};
const tds = tedious;
const debug = srcExports("mssql:tedi");
const BaseRequest = request$2;
const RequestError3 = requestError;
const { IDS, objectHasProperty } = utils;
const { TYPES, DECLARATIONS, declare: declare2, cast } = datatypesExports;
const Table = table;
const { PARSERS: UDT } = udt;
const { valueHandler } = sharedExports;
const JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
const XML_COLUMN_ID = "XML_F52E2B61-18A1-11d1-B105-00805F49916B";
const N_TYPES = {
  BitN: 104,
  DateTimeN: 111,
  DecimalN: 106,
  FloatN: 109,
  IntN: 38,
  MoneyN: 110,
  NumericN: 108
};
const getTediousType = function(type2) {
  switch (type2) {
    case TYPES.VarChar:
      return tds.TYPES.VarChar;
    case TYPES.NVarChar:
      return tds.TYPES.NVarChar;
    case TYPES.Text:
      return tds.TYPES.Text;
    case TYPES.Int:
      return tds.TYPES.Int;
    case TYPES.BigInt:
      return tds.TYPES.BigInt;
    case TYPES.TinyInt:
      return tds.TYPES.TinyInt;
    case TYPES.SmallInt:
      return tds.TYPES.SmallInt;
    case TYPES.Bit:
      return tds.TYPES.Bit;
    case TYPES.Float:
      return tds.TYPES.Float;
    case TYPES.Decimal:
      return tds.TYPES.Decimal;
    case TYPES.Numeric:
      return tds.TYPES.Numeric;
    case TYPES.Real:
      return tds.TYPES.Real;
    case TYPES.Money:
      return tds.TYPES.Money;
    case TYPES.SmallMoney:
      return tds.TYPES.SmallMoney;
    case TYPES.Time:
      return tds.TYPES.Time;
    case TYPES.Date:
      return tds.TYPES.Date;
    case TYPES.DateTime:
      return tds.TYPES.DateTime;
    case TYPES.DateTime2:
      return tds.TYPES.DateTime2;
    case TYPES.DateTimeOffset:
      return tds.TYPES.DateTimeOffset;
    case TYPES.SmallDateTime:
      return tds.TYPES.SmallDateTime;
    case TYPES.UniqueIdentifier:
      return tds.TYPES.UniqueIdentifier;
    case TYPES.Xml:
      return tds.TYPES.NVarChar;
    case TYPES.Char:
      return tds.TYPES.Char;
    case TYPES.NChar:
      return tds.TYPES.NChar;
    case TYPES.NText:
      return tds.TYPES.NVarChar;
    case TYPES.Image:
      return tds.TYPES.Image;
    case TYPES.Binary:
      return tds.TYPES.Binary;
    case TYPES.VarBinary:
      return tds.TYPES.VarBinary;
    case TYPES.UDT:
    case TYPES.Geography:
    case TYPES.Geometry:
      return tds.TYPES.UDT;
    case TYPES.TVP:
      return tds.TYPES.TVP;
    case TYPES.Variant:
      return tds.TYPES.Variant;
    default:
      return type2;
  }
};
const getMssqlType = function(type2, length) {
  if (typeof type2 !== "object") return void 0;
  switch (type2) {
    case tds.TYPES.Char:
      return TYPES.Char;
    case tds.TYPES.NChar:
      return TYPES.NChar;
    case tds.TYPES.VarChar:
      return TYPES.VarChar;
    case tds.TYPES.NVarChar:
      return TYPES.NVarChar;
    case tds.TYPES.Text:
      return TYPES.Text;
    case tds.TYPES.NText:
      return TYPES.NText;
    case tds.TYPES.Int:
      return TYPES.Int;
    case tds.TYPES.BigInt:
      return TYPES.BigInt;
    case tds.TYPES.TinyInt:
      return TYPES.TinyInt;
    case tds.TYPES.SmallInt:
      return TYPES.SmallInt;
    case tds.TYPES.Bit:
      return TYPES.Bit;
    case tds.TYPES.Float:
      return TYPES.Float;
    case tds.TYPES.Real:
      return TYPES.Real;
    case tds.TYPES.Money:
      return TYPES.Money;
    case tds.TYPES.SmallMoney:
      return TYPES.SmallMoney;
    case tds.TYPES.Numeric:
      return TYPES.Numeric;
    case tds.TYPES.Decimal:
      return TYPES.Decimal;
    case tds.TYPES.DateTime:
      return TYPES.DateTime;
    case tds.TYPES.Time:
      return TYPES.Time;
    case tds.TYPES.Date:
      return TYPES.Date;
    case tds.TYPES.DateTime2:
      return TYPES.DateTime2;
    case tds.TYPES.DateTimeOffset:
      return TYPES.DateTimeOffset;
    case tds.TYPES.SmallDateTime:
      return TYPES.SmallDateTime;
    case tds.TYPES.UniqueIdentifier:
      return TYPES.UniqueIdentifier;
    case tds.TYPES.Image:
      return TYPES.Image;
    case tds.TYPES.Binary:
      return TYPES.Binary;
    case tds.TYPES.VarBinary:
      return TYPES.VarBinary;
    case tds.TYPES.Xml:
      return TYPES.Xml;
    case tds.TYPES.UDT:
      return TYPES.UDT;
    case tds.TYPES.TVP:
      return TYPES.TVP;
    case tds.TYPES.Variant:
      return TYPES.Variant;
    default:
      switch (type2.id) {
        case N_TYPES.BitN:
          return TYPES.Bit;
        case N_TYPES.NumericN:
          return TYPES.Numeric;
        case N_TYPES.DecimalN:
          return TYPES.Decimal;
        case N_TYPES.IntN:
          if (length === 8) return TYPES.BigInt;
          if (length === 4) return TYPES.Int;
          if (length === 2) return TYPES.SmallInt;
          return TYPES.TinyInt;
        case N_TYPES.FloatN:
          if (length === 8) return TYPES.Float;
          return TYPES.Real;
        case N_TYPES.MoneyN:
          if (length === 8) return TYPES.Money;
          return TYPES.SmallMoney;
        case N_TYPES.DateTimeN:
          if (length === 8) return TYPES.DateTime;
          return TYPES.SmallDateTime;
      }
  }
};
const createColumns = function(metadata, arrayRowMode) {
  let out = {};
  if (arrayRowMode) out = [];
  for (let index = 0, length = metadata.length; index < length; index++) {
    const column = metadata[index];
    const outColumn = {
      index,
      name: column.colName,
      length: column.dataLength,
      type: getMssqlType(column.type, column.dataLength),
      scale: column.scale,
      precision: column.precision,
      nullable: !!(column.flags & 1),
      caseSensitive: !!(column.flags & 2),
      identity: !!(column.flags & 16),
      readOnly: !(column.flags & 12)
    };
    if (column.udtInfo) {
      outColumn.udt = {
        name: column.udtInfo.typeName,
        database: column.udtInfo.dbname,
        schema: column.udtInfo.owningSchema,
        assembly: column.udtInfo.assemblyName
      };
      if (DECLARATIONS[column.udtInfo.typeName]) {
        outColumn.type = DECLARATIONS[column.udtInfo.typeName];
      }
    }
    if (arrayRowMode) {
      out.push(outColumn);
    } else {
      out[column.colName] = outColumn;
    }
  }
  return out;
};
const valueCorrection = function(value, metadata) {
  const type2 = getMssqlType(metadata.type);
  if (valueHandler.has(type2)) {
    return valueHandler.get(type2)(value);
  } else if (metadata.type === tds.TYPES.UDT && value != null) {
    if (UDT[metadata.udtInfo.typeName]) {
      return UDT[metadata.udtInfo.typeName](value);
    } else {
      return value;
    }
  } else {
    return value;
  }
};
const parameterCorrection = function(value) {
  if (value instanceof Table) {
    const tvp2 = {
      name: value.name,
      schema: value.schema,
      columns: [],
      rows: value.rows
    };
    for (const col of value.columns) {
      tvp2.columns.push({
        name: col.name,
        type: getTediousType(col.type),
        length: col.length,
        scale: col.scale,
        precision: col.precision
      });
    }
    return tvp2;
  } else {
    return value;
  }
};
class Request2 extends BaseRequest {
  /*
  Execute specified sql batch.
  */
  _batch(batch, callback) {
    this._isBatch = true;
    this._query(batch, callback);
  }
  /*
  Bulk load.
  */
  _bulk(table2, options, callback) {
    super._bulk(table2, options, (err) => {
      if (err) return callback(err);
      try {
        table2._makeBulk();
      } catch (e) {
        return callback(new RequestError3(e, "EREQUEST"));
      }
      if (!table2.name) {
        return callback(new RequestError3("Table name must be specified for bulk insert.", "ENAME"));
      }
      if (table2.name.charAt(0) === "@") {
        return callback(new RequestError3("You can't use table variables for bulk insert.", "ENAME"));
      }
      const errors2 = [];
      const errorHandlers = {};
      let hasReturned = false;
      const handleError = (doReturn, connection2, info) => {
        let err2 = new Error(info.message);
        err2.info = info;
        err2 = new RequestError3(err2, "EREQUEST");
        if (this.stream) {
          this.emit("error", err2);
        } else {
          if (doReturn && !hasReturned) {
            if (connection2) {
              for (const event in errorHandlers) {
                connection2.removeListener(event, errorHandlers[event]);
              }
              this.parent.release(connection2);
            }
            hasReturned = true;
            callback(err2);
          }
        }
        errors2.push(err2);
      };
      const handleInfo = (msg) => {
        this.emit("info", {
          message: msg.message,
          number: msg.number,
          state: msg.state,
          class: msg.class,
          lineNumber: msg.lineNumber,
          serverName: msg.serverName,
          procName: msg.procName
        });
      };
      this.parent.acquire(this, (err2, connection2) => {
        const callbackWithRelease = (err3, ...args) => {
          try {
            this.parent.release(connection2);
          } catch (e) {
          }
          callback(err3, ...args);
        };
        if (err2) return callbackWithRelease(err2);
        debug("connection(%d): borrowed to request #%d", IDS.get(connection2), IDS.get(this));
        if (this.canceled) {
          debug("request(%d): canceled", IDS.get(this));
          return callbackWithRelease(new RequestError3("Canceled.", "ECANCEL"));
        }
        this._cancel = () => {
          debug("request(%d): cancel", IDS.get(this));
          connection2.cancel();
        };
        connection2.on("infoMessage", errorHandlers.infoMessage = handleInfo);
        connection2.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection2));
        connection2.on("error", errorHandlers.error = handleError.bind(null, true, connection2));
        const done = (err3, rowCount) => {
          if (err3 && (!errors2.length || errors2.length && err3.message !== errors2[errors2.length - 1].message)) {
            err3 = new RequestError3(err3, "EREQUEST");
            if (this.stream) this.emit("error", err3);
            errors2.push(err3);
          }
          delete this._cancel;
          let error2;
          if (errors2.length && !this.stream) {
            error2 = errors2.pop();
            error2.precedingErrors = errors2;
          }
          if (!hasReturned) {
            for (const event in errorHandlers) {
              connection2.removeListener(event, errorHandlers[event]);
            }
            hasReturned = true;
            if (this.stream) {
              callbackWithRelease(null, rowCount);
            } else {
              callbackWithRelease(error2, rowCount);
            }
          }
        };
        const bulk = connection2.newBulkLoad(table2.path, options, done);
        for (const col of table2.columns) {
          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
        }
        if (table2.create) {
          const objectid = table2.temporary ? `tempdb..[${table2.name}]` : table2.path;
          const req2 = new tds.Request(`if object_id('${objectid.replace(/'/g, "''")}') is null ${table2.declare()}`, (err3) => {
            if (err3) return done(err3);
            connection2.execBulkLoad(bulk, table2.rows);
          });
          this._setCurrentRequest(req2);
          connection2.execSqlBatch(req2);
        } else {
          connection2.execBulkLoad(bulk, table2.rows);
        }
      });
    });
  }
  /*
  Execute specified sql command.
  */
  _query(command, callback) {
    super._query(command, (err) => {
      if (err) return callback(err);
      const recordsets = [];
      const recordsetcolumns = [];
      const errors2 = [];
      const errorHandlers = {};
      const output = {};
      const rowsAffected = [];
      let columns = {};
      let recordset = [];
      let batchLastRow = null;
      let batchHasOutput = false;
      let isChunkedRecordset = false;
      let chunksBuffer = null;
      let hasReturned = false;
      const handleError = (doReturn, connection2, info) => {
        let err2 = new Error(info.message);
        err2.info = info;
        err2 = new RequestError3(err2, "EREQUEST");
        if (this.stream) {
          this.emit("error", err2);
        } else {
          if (doReturn && !hasReturned) {
            if (connection2) {
              for (const event in errorHandlers) {
                connection2.removeListener(event, errorHandlers[event]);
              }
              this.parent.release(connection2);
            }
            hasReturned = true;
            callback(err2);
          }
        }
        errors2.push(err2);
      };
      const handleInfo = (msg) => {
        this.emit("info", {
          message: msg.message,
          number: msg.number,
          state: msg.state,
          class: msg.class,
          lineNumber: msg.lineNumber,
          serverName: msg.serverName,
          procName: msg.procName
        });
      };
      this.parent.acquire(this, (err2, connection2, config) => {
        if (err2) return callback(err2);
        debug("connection(%d): borrowed to request #%d", IDS.get(connection2), IDS.get(this));
        let row;
        if (this.canceled) {
          debug("request(%d): canceled", IDS.get(this));
          this.parent.release(connection2);
          return callback(new RequestError3("Canceled.", "ECANCEL"));
        }
        this._cancel = () => {
          debug("request(%d): cancel", IDS.get(this));
          connection2.cancel();
        };
        connection2.on("infoMessage", errorHandlers.infoMessage = handleInfo);
        connection2.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection2));
        connection2.on("error", errorHandlers.error = handleError.bind(null, true, connection2));
        debug("request(%d): query", IDS.get(this), command);
        const req2 = new tds.Request(command, (err3) => {
          ((err3 == null ? void 0 : err3.errors) ? err3.errors : [err3]).forEach((e, i, { length }) => {
            if (e && (!errors2.length || errors2.length && errors2.length >= length && e.message !== errors2[errors2.length - length + i].message)) {
              e = new RequestError3(e, "EREQUEST");
              if (this.stream) this.emit("error", e);
              errors2.push(e);
            }
          });
          if (batchHasOutput) {
            if (!this.stream) batchLastRow = recordsets.pop()[0];
            for (const name2 in batchLastRow) {
              const value = batchLastRow[name2];
              if (name2 !== "___return___") {
                output[name2] = value;
              }
            }
          }
          delete this._cancel;
          let error2;
          if (errors2.length && !this.stream) {
            error2 = errors2.pop();
            error2.precedingErrors = errors2;
          }
          if (!hasReturned) {
            for (const event in errorHandlers) {
              connection2.removeListener(event, errorHandlers[event]);
            }
            this.parent.release(connection2);
            hasReturned = true;
            if (error2) {
              debug("request(%d): failed", IDS.get(this), error2);
            } else {
              debug("request(%d): completed", IDS.get(this));
            }
            if (this.stream) {
              callback(null, null, output, rowsAffected, recordsetcolumns);
            } else {
              callback(error2, recordsets, output, rowsAffected, recordsetcolumns);
            }
          }
        });
        this._setCurrentRequest(req2);
        req2.on("columnMetadata", (metadata) => {
          columns = createColumns(metadata, this.arrayRowMode);
          isChunkedRecordset = false;
          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
            isChunkedRecordset = true;
            chunksBuffer = [];
          }
          if (this.stream) {
            if (this._isBatch) {
              if (!columns.___return___) {
                this.emit("recordset", columns);
              }
            } else {
              this.emit("recordset", columns);
            }
          }
          if (this.arrayRowMode) recordsetcolumns.push(columns);
        });
        const doneHandler = (rowCount, more) => {
          if (rowCount != null) {
            rowsAffected.push(rowCount);
            if (this.stream) {
              this.emit("rowsaffected", rowCount);
            }
          }
          if (Object.keys(columns).length === 0) return;
          if (isChunkedRecordset) {
            const concatenatedChunks = chunksBuffer.join("");
            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
              try {
                if (concatenatedChunks === "") {
                  row = null;
                } else {
                  row = JSON.parse(concatenatedChunks);
                }
              } catch (ex) {
                row = null;
                const ex2 = new RequestError3(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                if (this.stream) this.emit("error", ex2);
                errors2.push(ex2);
              }
            } else {
              row = {};
              row[Object.keys(columns)[0]] = concatenatedChunks;
            }
            chunksBuffer = null;
            if (this.stream) {
              this.emit("row", row);
            } else {
              recordset.push(row);
            }
          }
          if (!this.stream) {
            Object.defineProperty(recordset, "columns", {
              enumerable: false,
              configurable: true,
              value: columns
            });
            Object.defineProperty(recordset, "toTable", {
              enumerable: false,
              configurable: true,
              value(name2) {
                return Table.fromRecordset(this, name2);
              }
            });
            recordsets.push(recordset);
          }
          recordset = [];
          columns = {};
        };
        req2.on("doneInProc", doneHandler);
        req2.on("done", doneHandler);
        req2.on("returnValue", (parameterName, value, metadata) => {
          output[parameterName] = value;
        });
        req2.on("row", (columns2) => {
          if (!recordset) recordset = [];
          if (isChunkedRecordset) {
            return chunksBuffer.push(columns2[0].value);
          }
          if (this.arrayRowMode) {
            row = [];
          } else {
            row = {};
          }
          for (const col of columns2) {
            col.value = valueCorrection(col.value, col.metadata);
            if (this.arrayRowMode) {
              row.push(col.value);
            } else {
              const exi = row[col.metadata.colName];
              if (exi !== void 0) {
                if (exi instanceof Array) {
                  exi.push(col.value);
                } else {
                  row[col.metadata.colName] = [exi, col.value];
                }
              } else {
                row[col.metadata.colName] = col.value;
              }
            }
          }
          if (this.stream) {
            if (this._isBatch) {
              if (row.___return___) {
                batchLastRow = row;
              } else {
                this.emit("row", row);
              }
            } else {
              this.emit("row", row);
            }
          } else {
            recordset.push(row);
          }
        });
        if (this._isBatch) {
          if (Object.keys(this.parameters).length) {
            for (const name2 in this.parameters) {
              if (!objectHasProperty(this.parameters, name2)) {
                continue;
              }
              const param = this.parameters[name2];
              try {
                param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
              } catch (e) {
                e.message = `Validation failed for parameter '${name2}'. ${e.message}`;
                const err3 = new RequestError3(e, "EPARAM");
                this.parent.release(connection2);
                return callback(err3);
              }
            }
            const declarations = [];
            for (const name2 in this.parameters) {
              if (!objectHasProperty(this.parameters, name2)) {
                continue;
              }
              const param = this.parameters[name2];
              declarations.push(`@${name2} ${declare2(param.type, param)}`);
            }
            const assigns = [];
            for (const name2 in this.parameters) {
              if (!objectHasProperty(this.parameters, name2)) {
                continue;
              }
              const param = this.parameters[name2];
              assigns.push(`@${name2} = ${cast(param.value, param.type, param)}`);
            }
            const selects = [];
            for (const name2 in this.parameters) {
              if (!objectHasProperty(this.parameters, name2)) {
                continue;
              }
              const param = this.parameters[name2];
              if (param.io === 2) {
                selects.push(`@${name2} as [${name2}]`);
              }
            }
            batchHasOutput = selects.length > 0;
            req2.sqlTextOrProcedure = `declare ${declarations.join(", ")};select ${assigns.join(", ")};${req2.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(", ")}` : ""}`;
          }
        } else {
          for (const name2 in this.parameters) {
            if (!objectHasProperty(this.parameters, name2)) {
              continue;
            }
            const param = this.parameters[name2];
            if (param.io === 1) {
              req2.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
            } else {
              req2.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
            }
          }
        }
        try {
          connection2[this._isBatch ? "execSqlBatch" : "execSql"](req2);
        } catch (error2) {
          handleError(true, connection2, error2);
        }
      });
    });
  }
  /*
  Execute stored procedure with specified parameters.
  */
  _execute(procedure, callback) {
    super._execute(procedure, (err) => {
      if (err) return callback(err);
      const recordsets = [];
      const recordsetcolumns = [];
      const errors2 = [];
      const errorHandlers = {};
      const output = {};
      const rowsAffected = [];
      let columns = {};
      let recordset = [];
      let returnValue = 0;
      let isChunkedRecordset = false;
      let chunksBuffer = null;
      let hasReturned = false;
      const handleError = (doReturn, connection2, info) => {
        let err2 = new Error(info.message);
        err2.info = info;
        err2 = new RequestError3(err2, "EREQUEST");
        if (this.stream) {
          this.emit("error", err2);
        } else {
          if (doReturn && !hasReturned) {
            if (connection2) {
              for (const event in errorHandlers) {
                connection2.removeListener(event, errorHandlers[event]);
              }
              this.parent.release(connection2);
            }
            hasReturned = true;
            callback(err2);
          }
        }
        errors2.push(err2);
      };
      const handleInfo = (msg) => {
        this.emit("info", {
          message: msg.message,
          number: msg.number,
          state: msg.state,
          class: msg.class,
          lineNumber: msg.lineNumber,
          serverName: msg.serverName,
          procName: msg.procName
        });
      };
      this.parent.acquire(this, (err2, connection2, config) => {
        if (err2) return callback(err2);
        debug("connection(%d): borrowed to request #%d", IDS.get(connection2), IDS.get(this));
        let row;
        if (this.canceled) {
          debug("request(%d): canceled", IDS.get(this));
          this.parent.release(connection2);
          return callback(new RequestError3("Canceled.", "ECANCEL"));
        }
        this._cancel = () => {
          debug("request(%d): cancel", IDS.get(this));
          connection2.cancel();
        };
        connection2.on("infoMessage", errorHandlers.infoMessage = handleInfo);
        connection2.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection2));
        connection2.on("error", errorHandlers.error = handleError.bind(null, true, connection2));
        if (debug.enabled) {
          const params = Object.keys(this.parameters).map((k) => this.parameters[k]);
          const logValue = (s) => typeof s === "string" && s.length > 50 ? s.substring(0, 47) + "..." : s;
          const logName = (param) => param.name + " [sql." + param.type.name + "]";
          const logParams = {};
          params.forEach((p) => {
            logParams[logName(p)] = logValue(p.value);
          });
          debug("request(%d): execute %s %O", IDS.get(this), procedure, logParams);
        }
        const req2 = new tds.Request(procedure, (err3) => {
          if (err3 && (!errors2.length || errors2.length && err3.message !== errors2[errors2.length - 1].message)) {
            err3 = new RequestError3(err3, "EREQUEST");
            if (this.stream) this.emit("error", err3);
            errors2.push(err3);
          }
          delete this._cancel;
          let error2;
          if (errors2.length && !this.stream) {
            error2 = errors2.pop();
            error2.precedingErrors = errors2;
          }
          if (!hasReturned) {
            for (const event in errorHandlers) {
              connection2.removeListener(event, errorHandlers[event]);
            }
            this.parent.release(connection2);
            hasReturned = true;
            if (error2) {
              debug("request(%d): failed", IDS.get(this), error2);
            } else {
              debug("request(%d): complete", IDS.get(this));
            }
            if (this.stream) {
              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
            } else {
              callback(error2, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
            }
          }
        });
        this._setCurrentRequest(req2);
        req2.on("columnMetadata", (metadata) => {
          columns = createColumns(metadata, this.arrayRowMode);
          isChunkedRecordset = false;
          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
            isChunkedRecordset = true;
            chunksBuffer = [];
          }
          if (this.stream) this.emit("recordset", columns);
          if (this.arrayRowMode) recordsetcolumns.push(columns);
        });
        req2.on("row", (columns2) => {
          if (!recordset) recordset = [];
          if (isChunkedRecordset) {
            return chunksBuffer.push(columns2[0].value);
          }
          if (this.arrayRowMode) {
            row = [];
          } else {
            row = {};
          }
          for (const col of columns2) {
            col.value = valueCorrection(col.value, col.metadata);
            if (this.arrayRowMode) {
              row.push(col.value);
            } else {
              const exi = row[col.metadata.colName];
              if (exi != null) {
                if (exi instanceof Array) {
                  exi.push(col.value);
                } else {
                  row[col.metadata.colName] = [exi, col.value];
                }
              } else {
                row[col.metadata.colName] = col.value;
              }
            }
          }
          if (this.stream) {
            this.emit("row", row);
          } else {
            recordset.push(row);
          }
        });
        req2.on("doneInProc", (rowCount, more) => {
          if (rowCount != null) {
            rowsAffected.push(rowCount);
            if (this.stream) {
              this.emit("rowsaffected", rowCount);
            }
          }
          if (Object.keys(columns).length === 0) return;
          if (isChunkedRecordset) {
            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
              try {
                if (chunksBuffer.length === 0) {
                  row = null;
                } else {
                  row = JSON.parse(chunksBuffer.join(""));
                }
              } catch (ex) {
                row = null;
                const ex2 = new RequestError3(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                if (this.stream) this.emit("error", ex2);
                errors2.push(ex2);
              }
            } else {
              row = {};
              row[Object.keys(columns)[0]] = chunksBuffer.join("");
            }
            chunksBuffer = null;
            if (this.stream) {
              this.emit("row", row);
            } else {
              recordset.push(row);
            }
          }
          if (!this.stream) {
            Object.defineProperty(recordset, "columns", {
              enumerable: false,
              configurable: true,
              value: columns
            });
            Object.defineProperty(recordset, "toTable", {
              enumerable: false,
              configurable: true,
              value(name2) {
                return Table.fromRecordset(this, name2);
              }
            });
            recordsets.push(recordset);
          }
          recordset = [];
          columns = {};
        });
        req2.on("doneProc", (rowCount, more, returnStatus) => {
          returnValue = returnStatus;
        });
        req2.on("returnValue", (parameterName, value, metadata) => {
          output[parameterName] = value;
        });
        for (const name2 in this.parameters) {
          if (!objectHasProperty(this.parameters, name2)) {
            continue;
          }
          const param = this.parameters[name2];
          if (param.io === 1) {
            req2.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
          } else {
            req2.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
          }
        }
        connection2.callProcedure(req2);
      });
    });
  }
  _pause() {
    super._pause();
    if (this._currentRequest) {
      this._currentRequest.pause();
    }
  }
  _resume() {
    super._resume();
    if (this._currentRequest) {
      this._currentRequest.resume();
    }
  }
}
var request = Request2;
(function(module2) {
  const base2 = baseExports;
  const ConnectionPool3 = connectionPool;
  const Transaction4 = transaction;
  const Request3 = request;
  module2.exports = Object.assign({
    ConnectionPool: ConnectionPool3,
    Transaction: Transaction4,
    Request: Request3,
    PreparedStatement: base2.PreparedStatement
  }, base2.exports);
  Object.defineProperty(module2.exports, "Promise", {
    enumerable: true,
    get: () => {
      return base2.Promise;
    },
    set: (value) => {
      base2.Promise = value;
    }
  });
  Object.defineProperty(module2.exports, "valueHandler", {
    enumerable: true,
    value: base2.valueHandler,
    writable: false,
    configurable: false
  });
  base2.driver.name = "tedious";
  base2.driver.ConnectionPool = ConnectionPool3;
  base2.driver.Transaction = Transaction4;
  base2.driver.Request = Request3;
})(tedious$1);
var tediousExports = tedious$1.exports;
var mssql = tediousExports;
const sql = /* @__PURE__ */ getDefaultExportFromCjs(mssql);
const connectionConfig = {
  user: "TRIAL",
  password: "napindo",
  server: "SERVER-TRIAL\\NAPINDOSQL",
  database: "NAPINDO",
  options: {
    encrypt: false,
    trustServerCertificate: true
  }
};
let pool = null;
async function ensurePool() {
  if (pool) return pool;
  pool = await sql.connect(connectionConfig);
  return pool;
}
async function testConnection() {
  var _a2, _b2;
  const currentPool = await ensurePool();
  const result = await currentPool.request().query("SELECT GETDATE() AS currentTime");
  return {
    success: true,
    serverTime: (_b2 = (_a2 = result.recordset) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.currentTime
  };
}
async function fetchTopRows(tableName, top = 10) {
  const safeTableName = tableName.replace(/[^\w.]/g, "");
  if (!safeTableName) {
    throw new Error("Nama tabel tidak valid");
  }
  const currentPool = await ensurePool();
  const query = `SELECT TOP (${top}) * FROM ${safeTableName}`;
  const result = await currentPool.request().query(query);
  return result.recordset ?? [];
}
async function loginUser(payload) {
  var _a2, _b2;
  const username = payload.username.trim();
  const password = payload.password;
  const division = (_a2 = payload.division) == null ? void 0 : _a2.trim();
  if (!username || !password) {
    throw new Error("Username dan password wajib diisi");
  }
  const currentPool = await ensurePool();
  const request2 = currentPool.request();
  request2.input("username", sql.VarChar(128), username);
  request2.input("password", sql.VarChar(256), password);
  let whereClause = "WHERE USERNAME = @username AND PASSWORD = @password";
  if (division) {
    request2.input("division", sql.VarChar(128), division);
    whereClause += " AND DIVISION = @division";
  }
  const query = `SELECT TOP (1) * FROM dbo.PENGGUNA ${whereClause}`;
  const result = await request2.query(query);
  const user = (_b2 = result.recordset) == null ? void 0 : _b2[0];
  if (!user) {
    return null;
  }
  const resolvedUsername = user.USERNAME ?? user.username ?? username;
  const resolvedDivision = user.DIVISION ?? user.division ?? (division ?? null);
  const resolvedName = user.NAMA ?? user.nama ?? null;
  return {
    username: resolvedUsername,
    division: resolvedDivision ?? null,
    name: resolvedName
  };
}
async function closePool() {
  if (!pool) return;
  await pool.close();
  pool = null;
}
async function fetchUserHints() {
  const currentPool = await ensurePool();
  const result = await currentPool.request().query("SELECT DISTINCT USERNAME, DIVISION FROM dbo.PENGGUNA ORDER BY USERNAME ASC");
  const usernames = /* @__PURE__ */ new Set();
  const divisions = /* @__PURE__ */ new Set();
  for (const row of result.recordset ?? []) {
    const username = row.USERNAME ?? row.username;
    const division = row.DIVISION ?? row.division;
    if (username) usernames.add(String(username));
    if (division) divisions.add(String(division));
  }
  return {
    usernames: Array.from(usernames),
    divisions: Array.from(divisions)
  };
}
const __dirname$1 = path$2.dirname(node_url.fileURLToPath(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("main.cjs", document.baseURI).href));
process.env.APP_ROOT = path$2.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$2.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$2.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$2.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new electron.BrowserWindow({
    icon: path$2.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: path$2.join(__dirname$1, "preload.mjs")
    }
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$2.join(RENDERER_DIST, "index.html"));
  }
}
function registerDatabaseHandlers() {
  electron.ipcMain.handle("db:testConnection", async () => {
    try {
      const result = await testConnection();
      return { ...result };
    } catch (error2) {
      return { success: false, message: error2 instanceof Error ? error2.message : String(error2) };
    }
  });
  electron.ipcMain.handle("db:fetchTableData", async (_event, tableName) => {
    try {
      const rows = await fetchTopRows(tableName);
      return { success: true, rows };
    } catch (error2) {
      return { success: false, message: error2 instanceof Error ? error2.message : String(error2) };
    }
  });
  electron.ipcMain.handle("db:login", async (_event, payload) => {
    try {
      const user = await loginUser(payload);
      if (!user) {
        return { success: false, message: "Username, password, atau divisi tidak cocok." };
      }
      return { success: true, user };
    } catch (error2) {
      return { success: false, message: error2 instanceof Error ? error2.message : String(error2) };
    }
  });
  electron.ipcMain.handle("db:userHints", async () => {
    try {
      const hints = await fetchUserHints();
      return { success: true, hints };
    } catch (error2) {
      return { success: false, message: error2 instanceof Error ? error2.message : String(error2) };
    }
  });
}
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron.app.quit();
    win = null;
  }
});
electron.app.on("activate", () => {
  if (electron.BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
electron.app.whenReady().then(() => {
  registerDatabaseHandlers();
  createWindow();
});
electron.app.on("before-quit", async () => {
  await closePool();
});
exports.MAIN_DIST = MAIN_DIST;
exports.RENDERER_DIST = RENDERER_DIST;
exports.VITE_DEV_SERVER_URL = VITE_DEV_SERVER_URL;
